From a1edfadb9376ca186afabe554d894d44ef0ccc97 Mon Sep 17 00:00:00 2001
From: Jan Petrous <jan.petrous@nxp.com>
Date: Mon, 20 Sep 2021 14:23:26 +0200
Subject: [PATCH] version BLN_PFE-DRV_S32G_A53_LNX_BETA_0.9.5 PATCH1

Provide support for using PFE Linux driver BETA 0.9.5
with PFE FW 0.9.5 (API: 881342f42552cf52de7c154c2e437c63).

Signed-off-by: Jan Petrous <jan.petrous@nxp.com>
---
 sw/fci/public/fci.h                           |    2 +
 sw/fci/src/fci.c                              |    9 +
 sw/fci/src/fci_interfaces.c                   |   17 -
 sw/fci/src/fci_internal.h                     |    3 +
 sw/fci/src/fci_qos.c                          |   78 +-
 sw/libfci_cli/Makefile                        |   28 +-
 sw/libfci_cli/src/libfci_cli.c                |   13 +-
 sw/libfci_cli/src/libfci_cli_cmds_bd.c        |  141 +-
 .../src/libfci_cli_cmds_demo_feature.c        |  160 +
 ...ci_ep.h => libfci_cli_cmds_demo_feature.h} |   11 +-
 sw/libfci_cli/src/libfci_cli_cmds_fp.c        |   99 +-
 sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c    |   39 +-
 sw/libfci_cli/src/libfci_cli_cmds_if.c        |  404 ++-
 sw/libfci_cli/src/libfci_cli_cmds_qos.c       |  143 +-
 .../src/libfci_cli_cmds_route_and_cntk.c      |  299 +-
 sw/libfci_cli/src/libfci_cli_cmds_spd.c       |  160 +-
 sw/libfci_cli/src/libfci_cli_common.h         |   22 +-
 sw/libfci_cli/src/libfci_cli_def_cmds.h       |    9 +
 sw/libfci_cli/src/libfci_cli_def_help.c       |   48 +-
 .../src/libfci_cli_def_optarg_keywords.c      |    1 +
 .../src/libfci_cli_def_optarg_keywords.h      |    1 +
 sw/libfci_cli/src/libfci_cli_parser.c         |   19 +-
 .../demo_common.c}                            |  108 +-
 .../demo_common.h}                            |   42 +-
 .../demo_feature_L2L3_bridge_simple.c         |  337 ++
 .../demo_feature_L2L3_bridge_vlan.c           |  505 +++
 .../demo_feature_L2_bridge_simple.c           |  170 +
 .../libfci_demo/demo_feature_L2_bridge_vlan.c |  308 ++
 .../demo_feature_flexible_filter.c            |  313 ++
 .../demo_feature_flexible_router.c            |  283 ++
 .../src/libfci_demo/demo_feature_qos.c        |  382 +++
 .../src/libfci_demo/demo_feature_router_nat.c |  309 ++
 .../libfci_demo/demo_feature_router_simple.c  |  215 ++
 .../src/libfci_demo/demo_feature_spd.c        |  302 ++
 .../fci_fp.c => libfci_demo/demo_fp.c}        |  512 +--
 sw/libfci_cli/src/libfci_demo/demo_fp.h       |   89 +
 .../demo_fwfeat.c}                            |  185 +-
 .../demo_fwfeat.h}                            |   30 +-
 sw/libfci_cli/src/libfci_demo/demo_l2_bd.c    | 1220 +++++++
 sw/libfci_cli/src/libfci_demo/demo_l2_bd.h    |  126 +
 sw/libfci_cli/src/libfci_demo/demo_log_if.c   | 1590 +++++++++
 sw/libfci_cli/src/libfci_demo/demo_log_if.h   |  144 +
 sw/libfci_cli/src/libfci_demo/demo_phy_if.c   |  897 ++++++
 sw/libfci_cli/src/libfci_demo/demo_phy_if.h   |  123 +
 sw/libfci_cli/src/libfci_demo/demo_qos.c      | 1245 +++++++
 sw/libfci_cli/src/libfci_demo/demo_qos.h      |  113 +
 sw/libfci_cli/src/libfci_demo/demo_rt_ct.c    | 2069 ++++++++++++
 sw/libfci_cli/src/libfci_demo/demo_rt_ct.h    |  170 +
 .../fci_spd.c => libfci_demo/demo_spd.c}      |  503 +--
 .../fci_spd.h => libfci_demo/demo_spd.h}      |   49 +-
 sw/libfci_cli/src/libfci_interface/fci_ep.c   |   87 -
 sw/libfci_cli/src/libfci_interface/fci_fp.h   |   73 -
 .../src/libfci_interface/fci_l2_bd.c          | 1208 -------
 .../src/libfci_interface/fci_l2_bd.h          |  107 -
 .../src/libfci_interface/fci_log_if.c         | 1730 ----------
 .../src/libfci_interface/fci_log_if.h         |  117 -
 .../src/libfci_interface/fci_phy_if.c         |  994 ------
 .../src/libfci_interface/fci_phy_if.h         |  108 -
 sw/libfci_cli/src/libfci_interface/fci_qos.c  | 1134 -------
 sw/libfci_cli/src/libfci_interface/fci_qos.h  |   89 -
 .../src/libfci_interface/fci_rt_ct.c          | 1800 -----------
 .../src/libfci_interface/fci_rt_ct.h          |  131 -
 sw/linux-pfeng/pfeng.h                        |    2 +-
 sw/pfe_platform/hw/s32g/pfe_platform_master.c |   50 +-
 sw/pfe_platform/hw/s32g/pfe_tmu_csr.c         |   70 +-
 sw/pfe_platform/hw/s32g/pfe_tmu_csr.h         |    3 +
 sw/pfe_platform/public/pfe_ct.h               |   27 +-
 sw/pfe_platform/public/pfe_l2br.h             |    2 +-
 sw/pfe_platform/public/pfe_platform.h         |    1 -
 sw/pfe_platform/src/pfe_hif_chnl.c            |   45 +-
 sw/pfe_platform/src/pfe_l2br.c                |   65 +-
 sw/pfe_platform/src/pfe_log_if.c              |    7 +
 sw/pfe_platform/src/pfe_log_if_slave.c        |    7 +
 sw/pfe_platform/src/pfe_pe.c                  |    4 +
 sw/pfe_platform/src/pfe_phy_if.c              |    7 +
 sw/pfe_platform/src/pfe_phy_if_slave.c        |   33 +-
 sw/pfe_platform/src/pfe_tmu.c                 |    3 +
 sw/xfci/libfci/public/fpp.h                   | 1112 ++++---
 sw/xfci/libfci/public/fpp_ext.h               | 2856 ++++++++++-------
 sw/xfci/libfci/public/libfci.h                | 1415 ++++----
 80 files changed, 16249 insertions(+), 11083 deletions(-)
 create mode 100644 sw/libfci_cli/src/libfci_cli_cmds_demo_feature.c
 rename sw/libfci_cli/src/{libfci_interface/fci_ep.h => libfci_cli_cmds_demo_feature.h} (88%)
 rename sw/libfci_cli/src/{libfci_interface/fci_common.c => libfci_demo/demo_common.c} (61%)
 rename sw/libfci_cli/src/{libfci_interface/fci_common.h => libfci_demo/demo_common.h} (80%)
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_simple.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_vlan.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_simple.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_vlan.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_flexible_filter.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_flexible_router.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_qos.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_router_nat.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_router_simple.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_feature_spd.c
 rename sw/libfci_cli/src/{libfci_interface/fci_fp.c => libfci_demo/demo_fp.c} (55%)
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_fp.h
 rename sw/libfci_cli/src/{libfci_interface/fci_fwfeat.c => libfci_demo/demo_fwfeat.c} (56%)
 rename sw/libfci_cli/src/{libfci_interface/fci_fwfeat.h => libfci_demo/demo_fwfeat.h} (63%)
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_l2_bd.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_l2_bd.h
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_log_if.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_log_if.h
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_phy_if.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_phy_if.h
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_qos.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_qos.h
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_rt_ct.c
 create mode 100644 sw/libfci_cli/src/libfci_demo/demo_rt_ct.h
 rename sw/libfci_cli/src/{libfci_interface/fci_spd.c => libfci_demo/demo_spd.c} (53%)
 rename sw/libfci_cli/src/{libfci_interface/fci_spd.h => libfci_demo/demo_spd.h} (50%)
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_ep.c
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_fp.h
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_l2_bd.c
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_l2_bd.h
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_log_if.c
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_log_if.h
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_phy_if.c
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_phy_if.h
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_qos.c
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_qos.h
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_rt_ct.c
 delete mode 100644 sw/libfci_cli/src/libfci_interface/fci_rt_ct.h

diff --git a/sw/fci/public/fci.h b/sw/fci/public/fci.h
index c592722..11e183f 100644
--- a/sw/fci/public/fci.h
+++ b/sw/fci/public/fci.h
@@ -14,6 +14,7 @@
 #include "pfe_l2br.h" /* pfe_l2br_t */
 #include "pfe_class.h" /* pfe_class_t */
 #include "pfe_if_db.h"
+#include "pfe_tmu.h"	/* pfe_tmu_t */
 #include "fci_msg.h"
 
 
@@ -28,6 +29,7 @@ typedef struct
 	pfe_class_t *class;		/* The classifier instance */
 	pfe_if_db_t *phy_if_db;	/* Pointer to platform driver phy_if DB */
 	pfe_if_db_t *log_if_db;	/* Pointer to platform driver log_if DB */
+	pfe_tmu_t *tmu;			/* Pointer to platform driver tmu */
 } fci_init_info_t;
 
 /**
diff --git a/sw/fci/src/fci.c b/sw/fci/src/fci.c
index 8db08f7..7802632 100644
--- a/sw/fci/src/fci.c
+++ b/sw/fci/src/fci.c
@@ -332,6 +332,7 @@ errno_t fci_init(fci_init_info_t *info, const char_t *const identifier)
 	context->phy_if_db_initialized = FALSE;
 	context->rt_db_initialized = FALSE;
 	context->rtable_initialized = FALSE;
+	context->tmu_initialized = FALSE;
 
 	/*	Sanity check */
 	if (6 != sizeof(pfe_mac_addr_t))
@@ -398,6 +399,14 @@ errno_t fci_init(fci_init_info_t *info, const char_t *const identifier)
 		}
 	}
 
+	/*	Initialize the TMU  */
+	context->tmu = info->tmu;
+
+	if(NULL != context->tmu)
+	{
+		context->tmu_initialized = TRUE;
+	}
+
 	context->default_timeouts.timeout_tcp = 5U * 24U * 60U * 60U; 	/* 5 days */
 	context->default_timeouts.timeout_udp = 300U; 					/* 5 min */
 	context->default_timeouts.timeout_other = 240U; 				/* 4 min */
diff --git a/sw/fci/src/fci_interfaces.c b/sw/fci/src/fci_interfaces.c
index 5fcc274..ba74052 100644
--- a/sw/fci/src/fci_interfaces.c
+++ b/sw/fci/src/fci_interfaces.c
@@ -1101,22 +1101,6 @@ errno_t fci_interfaces_phy_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_phy_if_cmd
 				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
 			}
 
-			/*	TTL discard control */
-			if(0U != (oal_ntohl(if_cmd->flags) & FPP_IF_DISCARD_TTL))
-			{
-				ret = pfe_phy_if_set_flag(phy_if, IF_FL_DISCARD_TTL);
-			}
-			else
-			{
-				ret = pfe_phy_if_clear_flag(phy_if, IF_FL_DISCARD_TTL);
-			}
-
-			if(EOK != ret)
-			{
-				NXP_LOG_ERROR("DISCARD_TTL flag wasn't updated correctly on %s\n",  pfe_phy_if_get_name(phy_if));
-				*fci_ret = FPP_ERR_IF_OP_UPDATE_FAILED;
-			}
-
 			/*	Flexible Filter */
 			if (0U != strlen((char_t *)if_cmd->ftable))
 			{
@@ -1242,7 +1226,6 @@ errno_t fci_interfaces_phy_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_phy_if_cmd
 			reply_buf->flags |= (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_PTP_CONF_CHECK)) ? oal_htonl(FPP_IF_PTP_CONF_CHECK) : 0;
 			reply_buf->flags |= (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_PTP_PROMISC)) ? oal_htonl(FPP_IF_PTP_PROMISC) : 0;
 			reply_buf->flags |= (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_ALLOW_Q_IN_Q)) ? oal_htonl(FPP_IF_ALLOW_Q_IN_Q) : 0;
-			reply_buf->flags |= (IF_FL_NONE != pfe_phy_if_get_flag(phy_if, IF_FL_DISCARD_TTL)) ? oal_htonl(FPP_IF_DISCARD_TTL) : 0;
 
 			/* Get the mode - use the fact enums have same values */
 			reply_buf->mode = (fpp_phy_if_op_mode_t) pfe_phy_if_get_op_mode(phy_if);
diff --git a/sw/fci/src/fci_internal.h b/sw/fci/src/fci_internal.h
index 55028f1..c1f89f4 100644
--- a/sw/fci/src/fci_internal.h
+++ b/sw/fci/src/fci_internal.h
@@ -58,6 +58,9 @@ struct fci_tag
 	oal_mutex_t db_mutex;
 	bool_t db_mutex_initialized;
 
+	pfe_tmu_t *tmu;					/* Pointer to platform driver tmu */
+	bool_t tmu_initialized;			/* Platform TMU was initialized */
+
 	pfe_class_t *class;
 
 	struct
diff --git a/sw/fci/src/fci_qos.c b/sw/fci/src/fci_qos.c
index 2efc0bb..067250b 100644
--- a/sw/fci/src/fci_qos.c
+++ b/sw/fci/src/fci_qos.c
@@ -83,7 +83,7 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 	fpp_qos_queue_cmd_t *q;
 	errno_t ret = EOK;
 	pfe_phy_if_t *phy_if = NULL;
-	pfe_platform_t *pfe = pfe_platform_get_instance();
+	fci_t *fci = (fci_t *)&__context;
 	uint32_t cnt, ii;
 	static const pfe_tmu_queue_mode_t fci_qmode_to_qmode[] =
 		{TMU_Q_MODE_INVALID, TMU_Q_MODE_DEFAULT, TMU_Q_MODE_TAIL_DROP, TMU_Q_MODE_WRED};
@@ -133,7 +133,7 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 			}
 
 			/*	Check queue ID */
-			cnt = pfe_tmu_queue_get_cnt(pfe->tmu, pfe_phy_if_get_id(phy_if));
+			cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
 			if (q->id > cnt)
 			{
 				NXP_LOG_ERROR("Queue ID %d out of range. Interface %s implements %d queues\n",
@@ -156,12 +156,12 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 				if (q->mode == 0U)
 				{
 					/*	Disable the queue to drop all packets */
-					ret = pfe_tmu_queue_set_mode(pfe->tmu, pfe_phy_if_get_id(phy_if), q->id,
+					ret = pfe_tmu_queue_set_mode(fci->tmu, pfe_phy_if_get_id(phy_if), q->id,
 							TMU_Q_MODE_TAIL_DROP, 0U, 0U);
 				}
 				else
 				{
-					ret = pfe_tmu_queue_set_mode(pfe->tmu, pfe_phy_if_get_id(phy_if), q->id,
+					ret = pfe_tmu_queue_set_mode(fci->tmu, pfe_phy_if_get_id(phy_if), q->id,
 						fci_qmode_to_qmode[q->mode], oal_ntohl(q->min), oal_ntohl(q->max));
 				}
 
@@ -176,7 +176,7 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 				{
 					NXP_LOG_DEBUG("Setting WRED zones probabilities\n");
 
-					cnt = pfe_tmu_queue_get_cnt(pfe->tmu, pfe_phy_if_get_id(phy_if));
+					cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
 
 					if (cnt > 32U)
 					{
@@ -190,7 +190,7 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 					{
 						NXP_LOG_DEBUG("Setting queue %d zone %d probability %d%%\n",
 								(int_t)q->id, (int_t)ii, (int_t)q->zprob[ii]);
-						ret = pfe_tmu_queue_set_wred_prob(pfe->tmu,
+						ret = pfe_tmu_queue_set_wred_prob(fci->tmu,
 								pfe_phy_if_get_id(phy_if), q->id, ii, q->zprob[ii]);
 						if (EOK != ret)
 						{
@@ -220,7 +220,7 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 			}
 
 			/*	Check queue ID */
-			cnt = pfe_tmu_queue_get_cnt(pfe->tmu, pfe_phy_if_get_id(phy_if));
+			cnt = pfe_tmu_queue_get_cnt(fci->tmu, pfe_phy_if_get_id(phy_if));
 			if (q->id > cnt)
 			{
 				NXP_LOG_ERROR("Queue ID %d out of range. Interface %s implements %d queues\n",
@@ -236,7 +236,7 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 			reply_buf->if_name[sizeof(reply_buf->if_name) - 1] = '\0';
 
 			/*	Get queue mode */
-			switch (pfe_tmu_queue_get_mode(pfe->tmu, pfe_phy_if_get_id(phy_if),
+			switch (pfe_tmu_queue_get_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
 					q->id, &reply_buf->min, &reply_buf->max))
 			{
 				case TMU_Q_MODE_TAIL_DROP:
@@ -272,13 +272,13 @@ errno_t fci_qos_queue_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_queue_cmd_t
 					reply_buf->min = oal_htonl(reply_buf->min);
 
 					/*	Get zone probabilities */
-					cnt = pfe_tmu_queue_get_wred_zones(pfe->tmu, pfe_phy_if_get_id(phy_if), q->id);
+					cnt = pfe_tmu_queue_get_wred_zones(fci->tmu, pfe_phy_if_get_id(phy_if), q->id);
 					for (ii=0U; ii<32U; ii++)
 					{
 						if (ii < cnt)
 						{
 							ret = pfe_tmu_queue_get_wred_prob(
-									pfe->tmu, pfe_phy_if_get_id(phy_if), q->id, ii, &reply_buf->zprob[ii]);
+									fci->tmu, pfe_phy_if_get_id(phy_if), q->id, ii, &reply_buf->zprob[ii]);
 							if (EOK != ret)
 							{
 								NXP_LOG_ERROR("Could not get queue %d zone %d probability: %d\n", (int_t)q->id, (int_t)ii, (int_t)ret);
@@ -332,7 +332,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 	fpp_qos_scheduler_cmd_t *sch;
 	errno_t ret = EOK;
 	pfe_phy_if_t *phy_if = NULL;
-	pfe_platform_t *pfe = pfe_platform_get_instance();
+	fci_t *fci = (fci_t *)&__context;
 	uint32_t ii, cnt;
 	uint8_t queue;
 
@@ -391,13 +391,13 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 			else if (1U == sch->mode)
 			{
 				NXP_LOG_INFO("Setting scheduler %d mode: Data rate\n", sch->id);
-				ret = pfe_tmu_sch_set_rate_mode(pfe->tmu,
+				ret = pfe_tmu_sch_set_rate_mode(fci->tmu,
 						pfe_phy_if_get_id(phy_if), sch->id, RATE_MODE_DATA_RATE);
 			}
 			else if (2U == sch->mode)
 			{
 				NXP_LOG_INFO("Setting scheduler %d mode: Packet rate\n", sch->id);
-				ret = pfe_tmu_sch_set_rate_mode(pfe->tmu,
+				ret = pfe_tmu_sch_set_rate_mode(fci->tmu,
 						pfe_phy_if_get_id(phy_if), sch->id, RATE_MODE_PACKET_RATE);
 			}
 			else
@@ -424,7 +424,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 
 			NXP_LOG_INFO("Setting scheduler %d algorithm: %s\n",
 					sch->id, sch_algos_str[sch->algo]);
-			ret = pfe_tmu_sch_set_algo(pfe->tmu, pfe_phy_if_get_id(phy_if),
+			ret = pfe_tmu_sch_set_algo(fci->tmu, pfe_phy_if_get_id(phy_if),
 					sch->id, sch_algos[sch->algo]);
 			if (EOK != ret)
 			{
@@ -434,14 +434,14 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 			}
 
 			/*	Configure scheduler inputs */
-			cnt = pfe_tmu_sch_get_input_cnt(pfe->tmu, pfe_phy_if_get_id(phy_if), sch->id);
+			cnt = pfe_tmu_sch_get_input_cnt(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
 			sch->input_en = oal_ntohl(sch->input_en);
 			for (ii=0U; ii<cnt; ii++)
 			{
 				if ((0U == ((1U << ii) & sch->input_en)) || (sch->input_src[ii] == 255U))
 				{
 					NXP_LOG_DEBUG("Disabling scheduler %d input %d\n", (int_t)sch->id, (int_t)ii);
-					ret = pfe_tmu_sch_bind_queue(pfe->tmu, pfe_phy_if_get_id(phy_if),
+					ret = pfe_tmu_sch_bind_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
 								sch->id, ii, PFE_TMU_INVALID_QUEUE);
 					if (EOK != ret)
 					{
@@ -456,7 +456,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 					{
 						NXP_LOG_DEBUG("Connecting source %d to scheduler %d input %d\n",
 								(int_t)sch->input_src[ii], (int_t)sch->id, (int_t)ii);
-						ret = pfe_tmu_sch_bind_queue(pfe->tmu, pfe_phy_if_get_id(phy_if),
+						ret = pfe_tmu_sch_bind_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
 								sch->id, ii, sch->input_src[ii]);
 						if (EOK != ret)
 						{
@@ -470,7 +470,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 					{
 						NXP_LOG_DEBUG("Connecting scheduler %d output to scheduler %d input %d\n",
 								(int_t)(sch->id-1U), (int_t)sch->id, (int_t)ii);
-						ret = pfe_tmu_sch_bind_sch_output(pfe->tmu, pfe_phy_if_get_id(phy_if),
+						ret = pfe_tmu_sch_bind_sch_output(fci->tmu, pfe_phy_if_get_id(phy_if),
 								sch->id-1U, sch->id, ii);
 						if (EOK != ret)
 						{
@@ -489,7 +489,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 
 					NXP_LOG_DEBUG("Setting scheduler %d input %d weight: %d\n",
 							(int_t)sch->id, (int_t)ii, (int_t)oal_ntohl(sch->input_w[ii]));
-					ret = pfe_tmu_sch_set_input_weight(pfe->tmu, pfe_phy_if_get_id(phy_if),
+					ret = pfe_tmu_sch_set_input_weight(fci->tmu, pfe_phy_if_get_id(phy_if),
 							sch->id, ii, oal_ntohl(sch->input_w[ii]));
 					if (EOK != ret)
 					{
@@ -524,7 +524,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 			reply_buf->if_name[sizeof(reply_buf->if_name) - 1] = '\0';
 
 			/*	Get scheduler mode */
-			switch (pfe_tmu_sch_get_rate_mode(pfe->tmu, pfe_phy_if_get_id(phy_if), sch->id))
+			switch (pfe_tmu_sch_get_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id))
 			{
 				case RATE_MODE_DATA_RATE:
 				{
@@ -548,7 +548,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 			}
 
 			/*	Get scheduler algo */
-			reply_buf->algo = (uint8_t)pfe_tmu_sch_get_algo(pfe->tmu,
+			reply_buf->algo = (uint8_t)pfe_tmu_sch_get_algo(fci->tmu,
 					pfe_phy_if_get_id(phy_if), sch->id);
 			if (reply_buf->algo == (uint8_t)SCHED_ALGO_INVALID)
 			{
@@ -559,15 +559,15 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 			}
 
 			/*	Get enabled inputs and associated sources. See the Egress QoS chapter in FCI doc. */
-			cnt = pfe_tmu_sch_get_input_cnt(pfe->tmu, pfe_phy_if_get_id(phy_if), sch->id);
+			cnt = pfe_tmu_sch_get_input_cnt(fci->tmu, pfe_phy_if_get_id(phy_if), sch->id);
 			reply_buf->input_en = 0U;
 			for (ii=0U; ii<cnt; ii++)
 			{
-				queue = pfe_tmu_sch_get_bound_queue(pfe->tmu, pfe_phy_if_get_id(phy_if),
+				queue = pfe_tmu_sch_get_bound_queue(fci->tmu, pfe_phy_if_get_id(phy_if),
 						sch->id, ii);
 				if (PFE_TMU_INVALID_QUEUE == queue)
 				{
-					if (PFE_TMU_INVALID_SCHEDULER == pfe_tmu_sch_get_bound_sch_output(pfe->tmu,
+					if (PFE_TMU_INVALID_SCHEDULER == pfe_tmu_sch_get_bound_sch_output(fci->tmu,
 							pfe_phy_if_get_id(phy_if), sch->id, ii))
 					{
 						/*	Scheduler input 'ii' is not connected */
@@ -577,7 +577,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 					{
 						/*	Scheduler input 'ii' is connected to prepend scheduler output */
 						reply_buf->input_src[ii] = 8U;
-						reply_buf->input_w[ii] = oal_htonl(pfe_tmu_sch_get_input_weight(pfe->tmu,
+						reply_buf->input_w[ii] = oal_htonl(pfe_tmu_sch_get_input_weight(fci->tmu,
 								pfe_phy_if_get_id(phy_if), sch->id, ii));
 						reply_buf->input_en |= (1U << ii);
 					}
@@ -586,7 +586,7 @@ errno_t fci_qos_scheduler_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_schedul
 				{
 					/*	Scheduler input 'ii' is connected to queue */
 					reply_buf->input_src[ii] = queue;
-					reply_buf->input_w[ii] = oal_htonl(pfe_tmu_sch_get_input_weight(pfe->tmu,
+					reply_buf->input_w[ii] = oal_htonl(pfe_tmu_sch_get_input_weight(fci->tmu,
 							pfe_phy_if_get_id(phy_if), sch->id, ii));
 					reply_buf->input_en |= (1U << ii);
 				}
@@ -624,7 +624,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 	fpp_qos_shaper_cmd_t *shp;
 	errno_t ret = EOK;
 	pfe_phy_if_t *phy_if = NULL;
-	pfe_platform_t *pfe = pfe_platform_get_instance();
+	fci_t *fci = (fci_t *)&__context;
 
 #if defined(PFE_CFG_NULL_ARG_CHECK)
 	if (unlikely((NULL == msg) || (NULL == fci_ret) || (NULL == reply_buf) || (NULL == reply_len)))
@@ -675,7 +675,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 				if (255U == shp->position)
 				{
 					NXP_LOG_DEBUG("Disconnecting shaper %d\n", shp->id);
-					ret = pfe_tmu_shp_set_position(pfe->tmu, pfe_phy_if_get_id(phy_if),
+					ret = pfe_tmu_shp_set_position(fci->tmu, pfe_phy_if_get_id(phy_if),
 							shp->id, PFE_TMU_INVALID_POSITION);
 					if (EOK != ret)
 					{
@@ -686,7 +686,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 				}
 
 				NXP_LOG_DEBUG("Disabling shaper %d\n", shp->id);
-				ret = pfe_tmu_shp_disable(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+				ret = pfe_tmu_shp_disable(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Could not disable shaper %d: %d\n", shp->id, ret);
@@ -697,7 +697,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 			else
 			{
 				NXP_LOG_DEBUG("Enabling shaper %d\n", shp->id);
-				ret = pfe_tmu_shp_enable(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+				ret = pfe_tmu_shp_enable(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Could not enable shaper %d: %d\n", shp->id, ret);
@@ -708,12 +708,12 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 				NXP_LOG_DEBUG("Setting shaper %d rate mode %d\n", shp->id, shp->mode);
 				if (1U == shp->mode)
 				{
-					ret = pfe_tmu_shp_set_rate_mode(pfe->tmu, pfe_phy_if_get_id(phy_if),
+					ret = pfe_tmu_shp_set_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
 						shp->id, RATE_MODE_DATA_RATE);
 				}
 				else if (2U == shp->mode)
 				{
-					ret = pfe_tmu_shp_set_rate_mode(pfe->tmu, pfe_phy_if_get_id(phy_if),
+					ret = pfe_tmu_shp_set_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if),
 						shp->id, RATE_MODE_PACKET_RATE);
 				}
 				else
@@ -733,7 +733,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 
 				NXP_LOG_DEBUG("Setting shaper %d credit limits %d-%d\n",
 						(int_t)shp->id, (int_t)oal_ntohl(shp->max_credit), (int_t)oal_ntohl(shp->min_credit));
-				ret = pfe_tmu_shp_set_limits(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id,
+				ret = pfe_tmu_shp_set_limits(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id,
 						oal_ntohl(shp->max_credit), oal_ntohl(shp->min_credit));
 				if (EOK != ret)
 				{
@@ -743,7 +743,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 				}
 
 				NXP_LOG_DEBUG("Setting shaper %d position to %d\n", shp->id, shp->position);
-				ret = pfe_tmu_shp_set_position(pfe->tmu, pfe_phy_if_get_id(phy_if),
+				ret = pfe_tmu_shp_set_position(fci->tmu, pfe_phy_if_get_id(phy_if),
 						shp->id, shp->position);
 				if (EOK != ret)
 				{
@@ -755,7 +755,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 
 				NXP_LOG_DEBUG("Setting shaper %d idle slope: %d\n",
 						(int_t)shp->id, (int_t)oal_ntohl(shp->isl));
-				ret = pfe_tmu_shp_set_idle_slope(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id,
+				ret = pfe_tmu_shp_set_idle_slope(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id,
 						oal_ntohl(shp->isl));
 				if (EOK != ret)
 				{
@@ -789,7 +789,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 			reply_buf->if_name[sizeof(reply_buf->if_name) - 1] = '\0';
 
 			/*	Get shaper mode */
-			switch (pfe_tmu_shp_get_rate_mode(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id))
+			switch (pfe_tmu_shp_get_rate_mode(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id))
 			{
 				case RATE_MODE_DATA_RATE:
 				{
@@ -812,7 +812,7 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 			}
 
 			/*	Get credit limits */
-			ret = pfe_tmu_shp_get_limits(pfe->tmu, pfe_phy_if_get_id(phy_if),
+			ret = pfe_tmu_shp_get_limits(fci->tmu, pfe_phy_if_get_id(phy_if),
 					shp->id, &reply_buf->max_credit, &reply_buf->min_credit);
 			if (ret != EOK)
 			{
@@ -827,11 +827,11 @@ errno_t fci_qos_shaper_cmd(fci_msg_t *msg, uint16_t *fci_ret, fpp_qos_shaper_cmd
 
 			/*	Get idle slope */
 			reply_buf->isl = oal_htonl(
-					pfe_tmu_shp_get_idle_slope(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id));
+					pfe_tmu_shp_get_idle_slope(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id));
 
 			/*	Get shaper position */
 			reply_buf->position =
-					pfe_tmu_shp_get_position(pfe->tmu, pfe_phy_if_get_id(phy_if), shp->id);
+					pfe_tmu_shp_get_position(fci->tmu, pfe_phy_if_get_id(phy_if), shp->id);
 
 			*reply_len = sizeof(fpp_qos_shaper_cmd_t);
 			break;
diff --git a/sw/libfci_cli/Makefile b/sw/libfci_cli/Makefile
index 601225b..dca2004 100644
--- a/sw/libfci_cli/Makefile
+++ b/sw/libfci_cli/Makefile
@@ -44,32 +44,37 @@ OUTPUT_DIR = build/$(CONFIG_NAME)
 
 TARGET_OS ?= QNX
 
+#This is for cleaner YOCTO recipe (cross-compiling from yocto needs explicit path to the target sysroot).
+SYSROOT_DIR ?= ""
+ifneq ($(SYSROOT_DIR), "")
+	CC += --sysroot=$(SYSROOT_DIR)
+endif
+
 #Specific configuration per TARGET_OS.
 ifeq ($(TARGET_OS),LINUX)
-	LD = $(PLATFORM)-gcc
+	LD = $(CC)
 	LIBS += -L../xfci/libfci/build/$(PLATFORM)-$(BUILD_PROFILE) -l:libfci.a
 	
 	#Expand GLOBAL_CCFLAGS to get rid of single quotes around string parameters of GLOBAL_CCFLAGS.
 	#Those single quotes are utilized in build process of the Linux PFE driver, but they cause warnings in this makefile.
 	GLOBAL_CCFLAGS := $(shell echo $(GLOBAL_CCFLAGS))
 	
-	LIBFCI_CLI_TARGET_OS = "LNX"
-	LIBFCI_CLI_VERSION = "BETA 0.9.5"
+	CLI_TARGET_OS = "LNX"
+	CLI_DRV_VERSION = "BETA 0.9.5 PATCH1"
 else
 #This branch by defaut means QNX.
 	LIBS += -L../xfci/libfci/build/$(PLATFORM)-$(BUILD_PROFILE) -l:libfci.a
 	LIBS_all += -lsocket
 	
-	LIBFCI_CLI_TARGET_OS = "QNX"
-	LIBFCI_CLI_VERSION = "$(RELEASE_VERSION)"
+	CLI_TARGET_OS = "QNX"
+	CLI_DRV_VERSION = "$(RELEASE_VERSION)"
 endif
 
 #User defined include/preprocessor flags and libraries
-INCLUDES += -Isrc/libfci_interface \
-			-I../xfci/libfci/public \
+INCLUDES += -I../xfci/libfci/public \
 			-I../fci/public \
 			-I../common/public \
-			-I./src/libfci_interface
+			-I./src/libfci_demo
 
 #Dependencies
 DEPENDENCIES = $(subst -L,,$(subst $(EMPTY) $(EMPTY)-l:,/,$(LIBS)))
@@ -92,13 +97,12 @@ LDFLAGS_all += $(LDFLAGS_$(BUILD_PROFILE))
 LIBS_all += $(LIBS_$(BUILD_PROFILE))
 DEPS = -Wp,-MMD,$(@:%.o=%.d),-MT,$@
 
-#Versioning info - MD5 hash of pfe_ct.h + most recent commit in this project's git.
+#Driver versioning info - MD5 hash of pfe_ct.h, drv version, target OS.
 PFE_CT_H_START_OFFSET=$(word 1, $(shell cat -n ../pfe_platform/public/pfe_ct.h | sed -n '/=== \*/,$$p'))
 PFE_CT_H_MD5 = $(word 1, $(shell cat ../pfe_platform/public/pfe_ct.h | sed -n '$(PFE_CT_H_START_OFFSET),$$p' | tr -d '\040\011\012\015' | md5sum))
-CCFLAGS += -DGLOBAL_VERSION_CONTROL_ID=\"$(shell git log -1 --pretty=format:"%h")\"
 CCFLAGS += -DPFE_CT_H_MD5=\"$(PFE_CT_H_MD5)\"
-CCFLAGS += -DLIBFCI_CLI_VERSION=\"$(LIBFCI_CLI_VERSION)\"
-CCFLAGS += -DLIBFCI_CLI_TARGET_OS=\"$(LIBFCI_CLI_TARGET_OS)\"
+CCFLAGS += -DCLI_DRV_VERSION=\"$(CLI_DRV_VERSION)\"
+CCFLAGS += -DCLI_TARGET_OS=\"$(CLI_TARGET_OS)\"
 
 #Macro to expand files recursively: parameters $1 -  directory, $2 - extension, i.e. cpp
 rwildcard = $(wildcard $(addprefix $1/*.,$2)) $(foreach d,$(wildcard $1/*),$(call rwildcard,$d,$2))
diff --git a/sw/libfci_cli/src/libfci_cli.c b/sw/libfci_cli/src/libfci_cli.c
index 358b77d..f0ad2e5 100644
--- a/sw/libfci_cli/src/libfci_cli.c
+++ b/sw/libfci_cli/src/libfci_cli.c
@@ -31,10 +31,17 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_help.h"
 #include "libfci_cli_parser.h"
-#include "fci_ep.h"
+
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_common.h"
 
 /* ==== TYPEDEFS & DATA ==================================================== */
 
@@ -74,7 +81,7 @@ int main(int argc, char* argv[])
         cli_print_help(0);
     }
     
-    rtn = fci_ep_open_in_cmd_mode(&cli_p_cl);
+    rtn = demo_client_open_in_cmd_mode(&cli_p_cl);
     if (CLI_OK != rtn)
     {
         cli_print_error(rtn, "FCI endpoint failed to open.");
@@ -87,7 +94,7 @@ int main(int argc, char* argv[])
     /* close FCI (do not hide behind rtn check) */
     if (NULL != cli_p_cl)
     {
-        const int rtn_close = fci_ep_close(cli_p_cl);
+        const int rtn_close = demo_client_close(cli_p_cl);
         rtn = ((CLI_OK == rtn) ? (rtn_close) : (rtn));
         if (CLI_OK != rtn_close)
         {
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_bd.c b/sw/libfci_cli/src/libfci_cli_cmds_bd.c
index e613661..5e367bf 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_bd.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_bd.c
@@ -33,13 +33,19 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
 #include "libfci_cli_cmds_bd.h"
 
-#include "libfci_interface/fci_l2_bd.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_l2_bd.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -62,9 +68,9 @@ static int stent_print_aux(const fpp_l2_static_ent_cmd_t* p_stent, bool is_neste
     int indent = ((is_nested_in_bd) ? (8) : (0));
     
     {
-        const char* p_txt_local = (0 != (p_stent->local)) ? ("[local address]") : ("");
+        const char* p_txt_local = (demo_l2_stent_ld_is_local(p_stent) ? ("[local address]") : (""));
         printf("%-*sMAC: ", indent, "");
-        cli_print_mac(p_stent->mac);
+        cli_print_mac(demo_l2_stent_ld_get_mac(p_stent));
         printf("  %s\n", p_txt_local);
     }
     
@@ -72,18 +78,18 @@ static int stent_print_aux(const fpp_l2_static_ent_cmd_t* p_stent, bool is_neste
     
     if (!is_nested_in_bd)
     {
-        printf("%-*svlan: %"PRIu16"\n", indent, "", (p_stent->vlan));
+        printf("%-*svlan: %"PRIu16"\n", indent, "", demo_l2_stent_ld_get_vlan(p_stent));
     }
     
     {
-        const char* p_txt_local = (0 != (p_stent->local)) ? (" (ignored when local)") : ("");
+        const char* p_txt_local = (demo_l2_stent_ld_is_local(p_stent) ? (" (ignored when local)") : (""));
         printf("%-*segress%s: ", indent, "", p_txt_local);
-        cli_print_bitset32((p_stent->forward_list), ",", cli_value2txt_phyif, "---");
+        cli_print_bitset32(demo_l2_stent_ld_get_fwlist(p_stent), ",", cli_value2txt_phyif, "---");
         printf("\n");
     }
     
-    printf("%-*sdiscard-on-match-src: %s\n", indent, "", cli_value2txt_on_off(p_stent->src_discard));
-    printf("%-*sdiscard-on-match-dst: %s\n", indent, "", cli_value2txt_on_off(p_stent->dst_discard));
+    printf("%-*sdiscard-on-match-src: %s\n", indent, "", cli_value2txt_on_off(demo_l2_stent_ld_is_src_discard(p_stent)));
+    printf("%-*sdiscard-on-match-dst: %s\n", indent, "", cli_value2txt_on_off(demo_l2_stent_ld_is_dst_discard(p_stent)));
     
     return (FPP_ERR_OK);
 }
@@ -109,41 +115,45 @@ static int bd_print_aux(const fpp_l2_bd_cmd_t* p_bd, bool is_verbose)
     int indent = 0;
     
     {
-        const char *const p_txt_def = (fci_l2_bd_ld_is_default(p_bd)  ? ("[default]")  : (""));
-        const char *const p_txt_fbk = (fci_l2_bd_ld_is_fallback(p_bd) ? ("[fallback]") : (""));
+        const char *const p_txt_def = (demo_l2_bd_ld_is_default(p_bd)  ? ("[default]")  : (""));
+        const char *const p_txt_fbk = (demo_l2_bd_ld_is_fallback(p_bd) ? ("[fallback]") : (""));
         printf("%-*sdomain %02"PRIu16"  %s%s\n", indent, "",
-        (p_bd->vlan), p_txt_def, p_txt_fbk);
+        demo_l2_bd_ld_get_vlan(p_bd), p_txt_def, p_txt_fbk);
     }
     
     indent += 4;
     
     {
-        const uint32_t phyifs_bitset = (p_bd->if_list) & ~(p_bd->untag_if_list);
+        const uint32_t phyifs_bitset = demo_l2_bd_ld_get_if_list(p_bd) & (~demo_l2_bd_ld_get_untag_if_list(p_bd));
         printf("%-*sphyifs (tagged)   : ", indent, "");
         cli_print_bitset32(phyifs_bitset, ",", cli_value2txt_phyif, "---");
         printf("\n");
     }
     {
-        const uint32_t phyifs_bitset = (p_bd->if_list) & (p_bd->untag_if_list);
+        const uint32_t phyifs_bitset = demo_l2_bd_ld_get_if_list(p_bd) & demo_l2_bd_ld_get_untag_if_list(p_bd);
         printf("%-*sphyifs (untagged) : ", indent, "");
         cli_print_bitset32(phyifs_bitset, ",", cli_value2txt_phyif, "---");
         printf("\n");
     }
     {
+        const uint8_t ucast_hit  = demo_l2_bd_ld_get_ucast_hit(p_bd);
+        const uint8_t ucast_miss = demo_l2_bd_ld_get_ucast_miss(p_bd);
+        const uint8_t mcast_hit  = demo_l2_bd_ld_get_mcast_hit(p_bd);
+        const uint8_t mcast_miss = demo_l2_bd_ld_get_mcast_miss(p_bd);
         printf("%-*sucast-hit  action : %"PRIu8" (%s)\n"
                "%-*sucast-miss action : %"PRIu8" (%s)\n"
                "%-*smcast-hit  action : %"PRIu8" (%s)\n"
                "%-*smcast-miss action : %"PRIu8" (%s)\n",
-               indent, "", (p_bd->ucast_hit) , cli_value2txt_bd_action(p_bd->ucast_hit),
-               indent, "", (p_bd->ucast_miss), cli_value2txt_bd_action(p_bd->ucast_miss),
-               indent, "", (p_bd->mcast_hit) , cli_value2txt_bd_action(p_bd->mcast_hit),
-               indent, "", (p_bd->mcast_miss), cli_value2txt_bd_action(p_bd->mcast_miss));
+               indent, "", (ucast_hit),  cli_value2txt_bd_action(ucast_hit),
+               indent, "", (ucast_miss), cli_value2txt_bd_action(ucast_miss),
+               indent, "", (mcast_hit),  cli_value2txt_bd_action(mcast_hit),
+               indent, "", (mcast_miss), cli_value2txt_bd_action(mcast_miss));
     }
     
     if (is_verbose)
     {
-        uint16_t cnt = 0u;
-        fci_l2_stent_get_count_by_vlan(cli_p_cl, &cnt, (p_bd->vlan));
+        uint32_t cnt = 0u;
+        demo_l2_stent_get_count(cli_p_cl, &cnt, true, demo_l2_bd_ld_get_vlan(p_bd));
         const char* p_txt_dashes_if_none = ((0u == cnt) ? ("---") : (""));
         printf("%-*sstatic entries: %s\n", indent, "", p_txt_dashes_if_none);
     }
@@ -159,7 +169,7 @@ static inline int bd_print(const fpp_l2_bd_cmd_t* p_bd)
 static inline int bd_print_verbose(const fpp_l2_bd_cmd_t* p_bd)
 {
     bd_print_aux(p_bd, true);
-    return fci_l2_stent_print_by_vlan(cli_p_cl, stent_print_in_bd, (p_bd->vlan));
+    return demo_l2_stent_print_all(cli_p_cl, stent_print_in_bd, true, demo_l2_bd_ld_get_vlan(p_bd));
 }
 
 /* ==== PUBLIC FUNCTIONS : BD ============================================== */
@@ -177,11 +187,11 @@ int cli_cmd_bd_print(const cli_cmdargs_t *p_cmdargs)
     /* empty */
     
     /* exec */
-    const fci_l2_bd_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (bd_print_verbose) : (bd_print));
+    const demo_l2_bd_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (bd_print_verbose) : (bd_print));
     if (p_cmdargs->vlan.is_valid)
     {
         /* print a single bridge domain */
-        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+        rtn = demo_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
         if (FPP_ERR_OK == rtn)
         {
             rtn = p_cb_print(&bd);
@@ -190,7 +200,7 @@ int cli_cmd_bd_print(const cli_cmdargs_t *p_cmdargs)
     else
     {
         /* print all bridge domains */
-        rtn = fci_l2_bd_print_all(cli_p_cl, p_cb_print);
+        rtn = demo_l2_bd_print_all(cli_p_cl, p_cb_print);
     }
 
     return (rtn);
@@ -206,40 +216,43 @@ int cli_cmd_bd_update(const cli_cmdargs_t *p_cmdargs)
     fpp_l2_bd_cmd_t bd = {0};
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+        rtn = demo_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
     }
     
     /* modify local data - hit/miss actions */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ucast_hit.is_valid))
+        if (p_cmdargs->ucast_hit.is_valid)
         {
-            rtn = fci_l2_bd_ld_set_ucast_hit(&bd, (p_cmdargs->ucast_hit.value));
+            demo_l2_bd_ld_set_ucast_hit(&bd, (p_cmdargs->ucast_hit.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ucast_miss.is_valid))
+        if (p_cmdargs->ucast_miss.is_valid)
         {
-            rtn = fci_l2_bd_ld_set_ucast_miss(&bd, (p_cmdargs->ucast_miss.value));
+            demo_l2_bd_ld_set_ucast_miss(&bd, (p_cmdargs->ucast_miss.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->mcast_hit.is_valid))
+        if (p_cmdargs->mcast_hit.is_valid)
         {
-            rtn = fci_l2_bd_ld_set_mcast_hit(&bd, (p_cmdargs->mcast_hit.value));
+            demo_l2_bd_ld_set_mcast_hit(&bd, (p_cmdargs->mcast_hit.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->mcast_miss.is_valid))
+        if (p_cmdargs->mcast_miss.is_valid)
         {
-            rtn = fci_l2_bd_ld_set_mcast_miss(&bd, (p_cmdargs->mcast_miss.value));
+            demo_l2_bd_ld_set_mcast_miss(&bd, (p_cmdargs->mcast_miss.value));
         }
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_update(cli_p_cl, &bd);
+        rtn = demo_l2_bd_update(cli_p_cl, &bd);
     }
     
     return (rtn);
@@ -254,13 +267,16 @@ int cli_cmd_bd_add(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_add(cli_p_cl, NULL, (p_cmdargs->vlan.value));
+        rtn = demo_l2_bd_add(cli_p_cl, NULL, (p_cmdargs->vlan.value));
     }
     
     return (rtn);
@@ -275,13 +291,16 @@ int cli_cmd_bd_del(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_VLAN, NULL, (p_cmdargs->vlan.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /*  exec  */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_del(cli_p_cl, (p_cmdargs->vlan.value));
+        rtn = demo_l2_bd_del(cli_p_cl, (p_cmdargs->vlan.value));
     }
     
     return (rtn);
@@ -319,20 +338,20 @@ int cli_cmd_bd_insif(const cli_cmdargs_t *p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+        rtn = demo_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
     }
     
     /* modify local data */
     if (FPP_ERR_OK == rtn)
     {
         const bool is_vlan_tag = ((p_cmdargs->tag.is_valid) ? (p_cmdargs->tag.is_on) : (false));
-        rtn = fci_l2_bd_ld_insert_phyif(&bd, phyif_id, is_vlan_tag);
+        demo_l2_bd_ld_insert_phyif(&bd, phyif_id, is_vlan_tag);
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_update(cli_p_cl, &bd);
+        rtn = demo_l2_bd_update(cli_p_cl, &bd);
     }
     
     return (rtn);
@@ -370,19 +389,19 @@ int cli_cmd_bd_remif(const cli_cmdargs_t *p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
+        rtn = demo_l2_bd_get_by_vlan(cli_p_cl, &bd, (p_cmdargs->vlan.value));
     }
     
     /* modify local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_ld_remove_phyif(&bd, phyif_id);
+        demo_l2_bd_ld_remove_phyif(&bd, phyif_id);
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_bd_update(cli_p_cl, &bd);
+        rtn = demo_l2_bd_update(cli_p_cl, &bd);
     }
     
     return (rtn);
@@ -405,12 +424,12 @@ int cli_cmd_bd_stent_print(const cli_cmdargs_t *p_cmdargs)
     if (p_cmdargs->vlan.is_valid)
     {
         /* print all static entries affiliated with given bridge domain */
-        rtn = fci_l2_stent_print_by_vlan(cli_p_cl, stent_print, (p_cmdargs->vlan.value));
+        rtn = demo_l2_stent_print_all(cli_p_cl, stent_print, true, (p_cmdargs->vlan.value));
     }
     else
     {
         /* print all static entries (regardless of bridge domain affiliation) */
-        rtn = fci_l2_stent_print_all(cli_p_cl, stent_print);
+        rtn = demo_l2_stent_print_all(cli_p_cl, stent_print, false, 0u);
     }
 
     return (rtn);
@@ -436,34 +455,34 @@ int cli_cmd_bd_stent_update(const cli_cmdargs_t *p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_stent_get_by_vlanmac(cli_p_cl, &stent, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
+        rtn = demo_l2_stent_get_by_vlanmac(cli_p_cl, &stent, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
     }
     
     /* modify local data */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->egress.is_valid))
+        if (p_cmdargs->egress.is_valid)
         {
-            rtn = fci_l2_stent_ld_set_fwlist(&stent, (p_cmdargs->egress.bitset));
+            demo_l2_stent_ld_set_fwlist(&stent, (p_cmdargs->egress.bitset));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->local.is_valid))
+        if (p_cmdargs->local.is_valid)
         {
-            rtn = fci_l2_stent_ld_set_local(&stent, (p_cmdargs->local.is_on));
+            demo_l2_stent_ld_set_local(&stent, (p_cmdargs->local.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->vlan_conf__x_src.is_valid))
+        if (p_cmdargs->vlan_conf__x_src.is_valid)
         {
-            rtn = fci_l2_stent_ld_set_src_discard(&stent, (p_cmdargs->vlan_conf__x_src.is_on));
+            demo_l2_stent_ld_set_src_discard(&stent, (p_cmdargs->vlan_conf__x_src.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ptp_conf__x_dst.is_valid))
+        if (p_cmdargs->ptp_conf__x_dst.is_valid)
         {
-            rtn = fci_l2_stent_ld_set_dst_discard(&stent, (p_cmdargs->ptp_conf__x_dst.is_on));
+            demo_l2_stent_ld_set_dst_discard(&stent, (p_cmdargs->ptp_conf__x_dst.is_on));
         }
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_stent_update(cli_p_cl, &stent);
+        rtn = demo_l2_stent_update(cli_p_cl, &stent);
     }
     
     return (rtn);
@@ -488,7 +507,7 @@ int cli_cmd_bd_stent_add(const cli_cmdargs_t *p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_stent_add(cli_p_cl, NULL, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
+        rtn = demo_l2_stent_add(cli_p_cl, NULL, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
     }
     
     return (rtn);
@@ -513,7 +532,7 @@ int cli_cmd_bd_stent_del(const cli_cmdargs_t *p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_l2_stent_del(cli_p_cl, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
+        rtn = demo_l2_stent_del(cli_p_cl, (p_cmdargs->vlan.value), (p_cmdargs->smac.arr));
     }
     
     return (rtn);
@@ -542,15 +561,15 @@ int cli_cmd_bd_flush(const cli_cmdargs_t *p_cmdargs)
     {
         if (p_cmdargs->all.is_valid)
         {
-            rtn = fci_l2_flush_all(cli_p_cl);
+            rtn = demo_l2_flush_all(cli_p_cl);
         }
         if (p_cmdargs->static0.is_valid)
         {
-            rtn = fci_l2_flush_static(cli_p_cl);
+            rtn = demo_l2_flush_static(cli_p_cl);
         }
         if (p_cmdargs->dynamic0.is_valid)
         {
-            rtn = fci_l2_flush_learned(cli_p_cl);
+            rtn = demo_l2_flush_learned(cli_p_cl);
         }
     }
     
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_demo_feature.c b/sw/libfci_cli/src/libfci_cli_cmds_demo_feature.c
new file mode 100644
index 0000000..92e9c79
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_cli_cmds_demo_feature.c
@@ -0,0 +1,160 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "libfci_cli_common.h"
+#include "libfci_cli_def_opts.h"
+#include "libfci_cli_print_helpers.h"
+#include "libfci_cli_def_optarg_keywords.h"
+#include "libfci_cli_cmds_fwfeat.h"
+
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_fwfeat.h"
+
+/* ==== TESTMODE vars ====================================================== */
+
+#if !defined(NDEBUG)
+/* empty */
+#endif
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+extern FCI_CLIENT* cli_p_cl;
+
+typedef struct demo_menu_item_tt {
+    int (*p_cb)(FCI_CLIENT* p_cl);
+    const char* p_txt_name;
+} demo_feature_t;
+
+extern int demo_feature_L2_bridge_simple(FCI_CLIENT* p_cl);
+extern int demo_feature_L2_bridge_vlan(FCI_CLIENT* p_cl);
+extern int demo_feature_router_simple(FCI_CLIENT* p_cl);
+extern int demo_feature_router_nat(FCI_CLIENT* p_cl);
+extern int demo_feature_L2L3_bridge_simple(FCI_CLIENT* p_cl);
+extern int demo_feature_L2L3_bridge_vlan(FCI_CLIENT* p_cl);
+extern int demo_feature_flexible_filter(FCI_CLIENT* p_cl);
+extern int demo_feature_flexible_router(FCI_CLIENT* p_cl);
+extern int demo_feature_spd(FCI_CLIENT* p_cl);
+extern int demo_feature_qos(FCI_CLIENT* p_cl);
+ 
+static const demo_feature_t demo_features[] = 
+{
+    { demo_feature_L2_bridge_simple,
+                  "L2_bridge_simple" },
+     
+    { demo_feature_L2_bridge_vlan,
+                  "L2_bridge_vlan" },
+     
+    { demo_feature_router_simple,
+                  "router_simple" },
+     
+    { demo_feature_router_nat,
+                  "router_nat" },
+     
+    { demo_feature_L2L3_bridge_simple,
+                  "L2L3_bridge_simple" },
+     
+    { demo_feature_L2L3_bridge_vlan,
+                  "L2L3_bridge_vlan" },
+    
+    { demo_feature_flexible_filter,
+                  "flexible_filter" },
+    
+    { demo_feature_flexible_router,
+                  "flexible_router" },
+    
+    { demo_feature_spd,
+                  "spd" },
+    
+    { demo_feature_qos,
+                  "qos" },
+}; 
+
+#define DEMO_FEATURES_LN (uint8_t)(sizeof(demo_features) / sizeof(demo_feature_t))
+
+/* ==== PUBLIC FUNCTIONS =================================================== */ 
+
+int cli_cmd_demo_feature_print(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    printf("Available demo feature scenarios:\n");
+    for (uint8_t i = 0u; (DEMO_FEATURES_LN > i); (++i))
+    {
+        printf("  %s\n", demo_features[i].p_txt_name);
+    }
+    
+    return (FPP_ERR_OK);
+}
+
+int cli_cmd_demo_feature_run(const cli_cmdargs_t *p_cmdargs)
+{
+    assert(NULL != cli_p_cl);
+    assert(NULL != p_cmdargs);
+    
+    int rtn = CLI_ERR;
+    
+    /* check for mandatory opts */
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_FEATURE, NULL, (p_cmdargs->feature_name.is_valid)},
+    };
+    rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
+    
+    /* find and execute the demo feature */
+    if (FPP_ERR_OK == rtn)
+    {
+        const char *const p_txt_name = (p_cmdargs->feature_name.txt);
+        uint8_t i = UINT8_MAX;  /* WARNING: intentional use of owf behavior */ 
+        while ((DEMO_FEATURES_LN > (++i)) && (0 != strcmp(demo_features[i].p_txt_name, p_txt_name))) { /* empty */ };
+        if (DEMO_FEATURES_LN <= i)
+        {
+            rtn = CLI_ERR_INV_DEMO_FEATURE;
+        }
+        else
+        {
+            rtn = demo_features[i].p_cb(cli_p_cl);
+        }
+    }
+    
+    return (rtn);
+}
+
+/* ========================================================================= */
diff --git a/sw/libfci_cli/src/libfci_interface/fci_ep.h b/sw/libfci_cli/src/libfci_cli_cmds_demo_feature.h
similarity index 88%
rename from sw/libfci_cli/src/libfci_interface/fci_ep.h
rename to sw/libfci_cli/src/libfci_cli_cmds_demo_feature.h
index 4139024..48af634 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_ep.h
+++ b/sw/libfci_cli/src/libfci_cli_cmds_demo_feature.h
@@ -28,16 +28,15 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * ========================================================================= */
 
-#ifndef FCI_EP_H_
-#define FCI_EP_H_
+#ifndef LIBFCI_CLI_CMDS_DEMO_FEATURE_H_
+#define LIBFCI_CLI_CMDS_DEMO_FEATURE_H_
 
-#include <stdint.h>
-#include "libfci.h"
+#include "libfci_cli_common.h"
 
 /* ==== PUBLIC FUNCTIONS =================================================== */
 
-int fci_ep_open_in_cmd_mode(FCI_CLIENT** pp_rtn_cl);
-int fci_ep_close(FCI_CLIENT* p_cl);
+int cli_cmd_demo_feature_print(const cli_cmdargs_t *p_cmdargs);
+int cli_cmd_demo_feature_run(const cli_cmdargs_t *p_cmdargs);
 
 /* ========================================================================= */
 
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fp.c b/sw/libfci_cli/src/libfci_cli_cmds_fp.c
index e4322f1..39d088b 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_fp.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fp.c
@@ -33,13 +33,19 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
 #include "libfci_cli_cmds_fp.h"
 
-#include "libfci_interface/fci_fp.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_fp.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -61,9 +67,9 @@ static void fprule_header_print(unsigned int indent)
            "%-*s|=======|=================|============|============|========|=============|========|===========================|\n", indent, "", indent, "");
 }
 
-static int fprule_print_aux(const fpp_fp_rule_props_t* p_rule_props, uint16_t position, unsigned int indent)
+static int fprule_print_aux(const fpp_fp_rule_cmd_t* p_rule, uint16_t position, unsigned int indent)
 {
-    assert(NULL != p_rule_props);
+    assert(NULL != p_rule);
     
     if (stt_do_header_print)
     {
@@ -72,22 +78,27 @@ static int fprule_print_aux(const fpp_fp_rule_props_t* p_rule_props, uint16_t po
     }
     
     printf("%-*s| %5"PRIu16" | %-15s | 0x%08"PRIX32" | 0x%08"PRIX32" |  %5"PRIu16" | %-11s | %-6s | %-9s %-15s |\n", indent, "",
-           position, (p_rule_props->rule_name), (p_rule_props->data), (p_rule_props->mask),
-           (p_rule_props->offset), cli_value2txt_offset_from(p_rule_props->offset_from),
-           cli_value2txt_on_off(p_rule_props->invert), cli_value2txt_match_action(p_rule_props->match_action),
-           (p_rule_props->next_rule_name));
+           position,
+           demo_fp_rule_ld_get_name(p_rule),
+           demo_fp_rule_ld_get_data(p_rule), 
+           demo_fp_rule_ld_get_mask(p_rule),
+           demo_fp_rule_ld_get_offset(p_rule),
+           cli_value2txt_offset_from(demo_fp_rule_ld_get_offset_from(p_rule)),
+           cli_value2txt_on_off(demo_fp_rule_ld_is_invert(p_rule)), 
+           cli_value2txt_match_action(demo_fp_rule_ld_get_match_action(p_rule)),
+           demo_fp_rule_ld_get_next_name(p_rule));
     
     return (FPP_ERR_OK);
 }
 
-static inline int fptable_rule_print(const fpp_fp_rule_props_t* p_rule_props, uint16_t position)
+static inline int fptable_rule_print(const fpp_fp_rule_cmd_t* p_rule, uint16_t position)
 {
-    return fprule_print_aux(p_rule_props, position, 2u);
+    return fprule_print_aux(p_rule, position, 2u);
 }
 
-static inline int fprule_print(const fpp_fp_rule_props_t* p_rule_props, uint16_t position)
+static inline int fprule_print(const fpp_fp_rule_cmd_t* p_rule, uint16_t position)
 {
-    return fprule_print_aux(p_rule_props, position, 0u);
+    return fprule_print_aux(p_rule, position, 0u);
 }
 
 /* ==== PUBLIC FUNCTIONS : fptable ========================================= */
@@ -101,7 +112,10 @@ int cli_cmd_fptable_print(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
@@ -110,7 +124,7 @@ int cli_cmd_fptable_print(const cli_cmdargs_t *p_cmdargs)
         const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (0u));
         const uint16_t cnt = ((p_cmdargs->count_ethtype.is_valid) ? (p_cmdargs->count_ethtype.value) : (0u));
         stt_do_header_print = true;
-        rtn = fci_fp_table_print(cli_p_cl, fptable_rule_print, (p_cmdargs->table0_name.txt), pos, cnt);
+        rtn = demo_fp_table_print(cli_p_cl, fptable_rule_print, (p_cmdargs->table0_name.txt), pos, cnt);
     }
     
     return (rtn);
@@ -125,13 +139,16 @@ int cli_cmd_fptable_add(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
-    /*  exec  */
+    /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_fp_table_add(cli_p_cl, (p_cmdargs->table0_name.txt));
+        rtn = demo_fp_table_add(cli_p_cl, (p_cmdargs->table0_name.txt));
     }
     
     return (rtn);
@@ -146,13 +163,16 @@ int cli_cmd_fptable_del(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_TABLE, NULL, (p_cmdargs->table0_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_fp_table_del(cli_p_cl, (p_cmdargs->table0_name.txt));
+        rtn = demo_fp_table_del(cli_p_cl, (p_cmdargs->table0_name.txt));
     }
     
     return (rtn);
@@ -178,7 +198,7 @@ int cli_cmd_fptable_insrule(const cli_cmdargs_t *p_cmdargs)
     if (FPP_ERR_OK == rtn)
     {
         const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (UINT16_MAX));
-        rtn = fci_fp_table_insert_rule(cli_p_cl, (p_cmdargs->table0_name.txt), (p_cmdargs->ruleA0_name.txt), pos);
+        rtn = demo_fp_table_insert_rule(cli_p_cl, (p_cmdargs->table0_name.txt), (p_cmdargs->ruleA0_name.txt), pos);
     }
     
     return (rtn);
@@ -203,7 +223,7 @@ int cli_cmd_fptable_remrule(const cli_cmdargs_t *p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_fp_table_remove_rule(cli_p_cl, (p_cmdargs->table0_name.txt), (p_cmdargs->ruleA0_name.txt));
+        rtn = demo_fp_table_remove_rule(cli_p_cl, (p_cmdargs->table0_name.txt), (p_cmdargs->ruleA0_name.txt));
     }
     
     return (rtn);
@@ -228,11 +248,11 @@ int cli_cmd_fprule_print(const cli_cmdargs_t *p_cmdargs)
     {
         /* print a single rule */
         uint16_t idx = 0u;
-        rtn = fci_fp_rule_get_by_name(cli_p_cl, &fprule, &idx, (p_cmdargs->ruleA0_name.txt));
+        rtn = demo_fp_rule_get_by_name(cli_p_cl, &fprule, &idx, (p_cmdargs->ruleA0_name.txt));
         if (FPP_ERR_OK == rtn)
         {
             stt_do_header_print = true;
-            rtn = fprule_print(&(fprule.r), idx);
+            rtn = fprule_print(&fprule, idx);
         }
     }
     else
@@ -241,7 +261,7 @@ int cli_cmd_fprule_print(const cli_cmdargs_t *p_cmdargs)
         const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (0u));
         const uint16_t cnt = ((p_cmdargs->count_ethtype.is_valid) ? (p_cmdargs->count_ethtype.value) : (0u));
         stt_do_header_print = true;
-        rtn = fci_fp_rule_print_all(cli_p_cl, fprule_print, pos, cnt);
+        rtn = demo_fp_rule_print_all(cli_p_cl, fprule_print, pos, cnt);
     }
 
     return (rtn);
@@ -275,37 +295,29 @@ int cli_cmd_fprule_add(const cli_cmdargs_t *p_cmdargs)
     /* modify local data */
     if (FPP_ERR_OK == rtn)
     {
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_fp_rule_ld_set_data(&fprule, (p_cmdargs->data_hifc_sad.value));
-        }
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_fp_rule_ld_set_mask(&fprule, (p_cmdargs->mask_spi.value));
-        }
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_fp_rule_ld_set_offset(&fprule, (p_cmdargs->offset.value), (p_cmdargs->layer.value));
-        }
-        if (FPP_ERR_OK == rtn)
+        demo_fp_rule_ld_set_data(&fprule, (p_cmdargs->data_hifc_sad.value));
+        demo_fp_rule_ld_set_mask(&fprule, (p_cmdargs->mask_spi.value));
+        demo_fp_rule_ld_set_offset(&fprule, (p_cmdargs->offset.value), (p_cmdargs->layer.value));
+        
         {
             fpp_fp_rule_match_action_t match_action = ((p_cmdargs->accept.is_valid) ? (FP_ACCEPT) :
                                                       ((p_cmdargs->ruleB0_name.is_valid) ? (FP_NEXT_RULE) : 
                                                        (FP_REJECT)));
             const char* p_txt = ((p_cmdargs->ruleB0_name.is_valid) ? (p_cmdargs->ruleB0_name.txt) : (NULL));
-            rtn = fci_fp_rule_ld_set_match_action(&fprule, match_action, p_txt);
+            demo_fp_rule_ld_set_match_action(&fprule, match_action, p_txt);
         }
         
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->invert.is_valid))  /* this one is optional, hence validity check */
+        /* this param is optional, hence the validity check */
+        if (p_cmdargs->invert.is_valid)  
         {
-            rtn = fci_fp_rule_ld_set_invert(&fprule, (p_cmdargs->invert.is_valid));
+            demo_fp_rule_ld_set_invert(&fprule, (p_cmdargs->invert.is_valid));
         }
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_fp_rule_add(cli_p_cl, (p_cmdargs->ruleA0_name.txt), &fprule);
+        rtn = demo_fp_rule_add(cli_p_cl, (p_cmdargs->ruleA0_name.txt), &fprule);
     }
     
     return (rtn);
@@ -320,13 +332,16 @@ int cli_cmd_fprule_del(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_RULE, NULL, (p_cmdargs->ruleA0_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_RULE, NULL, (p_cmdargs->ruleA0_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_fp_rule_del(cli_p_cl, (p_cmdargs->ruleA0_name.txt));
+        rtn = demo_fp_rule_del(cli_p_cl, (p_cmdargs->ruleA0_name.txt));
     }
     
     return (rtn);
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
index 2241027..8408373 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_fwfeat.c
@@ -33,13 +33,19 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
 #include "libfci_cli_cmds_fwfeat.h"
 
-#include "libfci_interface/fci_fwfeat.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_fwfeat.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -60,44 +66,45 @@ static int fwfeat_print(const fpp_fw_features_cmd_t* p_fwfeat)
     /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
     int indent = 0;
     
-    printf("%-*s%s\n", indent, "", (p_fwfeat->name));
+    printf("%-*s%s\n", indent, "", demo_fwfeat_ld_get_name(p_fwfeat));
     
     indent += 4;
     
     {
-        const char* p_txt_ignored = (2u != (p_fwfeat->variant)) ? (" (ignored)") : ("");
+        const char* p_txt_ignored = (2u != demo_fwfeat_ld_get_variant(p_fwfeat)) ? (" (ignored)") : ("");
         printf("%-*sstate%s: %s\n", indent, "", 
                p_txt_ignored,
-               cli_value2txt_en_dis(p_fwfeat->val));
+               cli_value2txt_en_dis(demo_fwfeat_ld_is_enabled(p_fwfeat)));
     }
     
     {
-        const char* p_txt_variant_descr = "__INVALID_ITEM__";
-        switch (p_fwfeat->variant)
+        const uint8_t variant = demo_fwfeat_ld_get_variant(p_fwfeat);
+        const char* p_txt_variant_desc = "__INVALID_ITEM__";
+        switch (variant)
         {
             case 0:
-                p_txt_variant_descr = "ignore state and always act as DISABLED";
+                p_txt_variant_desc = "ignore state and always act as DISABLED";
             break;
             
             case 1:
-                p_txt_variant_descr = "ignore state and always act as ENABLED";
+                p_txt_variant_desc = "ignore state and always act as ENABLED";
             break;
             
             case 2:
-                p_txt_variant_descr = "feature is runtime-configurable";
+                p_txt_variant_desc = "feature is runtime-configurable";
             break;
             
             default:
-                p_txt_variant_descr = "__INVALID_ITEM__";
+                p_txt_variant_desc = "__INVALID_ITEM__";
             break;
         }
         printf("%-*svariant: %"PRIu8" (%s)\n", indent, "", 
-               (p_fwfeat->variant),
-               (p_txt_variant_descr));
+               (variant),
+               (p_txt_variant_desc));
     }
     
     {
-        printf("%-*s%s\n", indent, "", (p_fwfeat->desc));
+        printf("%-*s%s\n", indent, "", demo_fwfeat_ld_get_desc(p_fwfeat));
     }
     
     return (FPP_ERR_OK); 
@@ -121,7 +128,7 @@ int cli_cmd_fwfeat_print(const cli_cmdargs_t *p_cmdargs)
     if (p_cmdargs->feature_name.is_valid)
     {
         /* print a single feature */
-        rtn = fci_fwfeat_get_by_name(cli_p_cl, &fwfeat, (p_cmdargs->feature_name.txt));
+        rtn = demo_fwfeat_get_by_name(cli_p_cl, &fwfeat, (p_cmdargs->feature_name.txt));
         if (FPP_ERR_OK == rtn)
         {
             rtn = fwfeat_print(&fwfeat);
@@ -130,7 +137,7 @@ int cli_cmd_fwfeat_print(const cli_cmdargs_t *p_cmdargs)
     else
     {
         /* print all FW features */
-        rtn = fci_fwfeat_print_all(cli_p_cl, fwfeat_print);
+        rtn = demo_fwfeat_print_all(cli_p_cl, fwfeat_print);
     }
     
     return (rtn);
@@ -157,7 +164,7 @@ int cli_cmd_fwfeat_set(const cli_cmdargs_t *p_cmdargs)
     if (FPP_ERR_OK == rtn)
     {
         /* NOTE: enable and disable opts are mutually exclusive */
-        rtn = fci_fwfeat_set(cli_p_cl, (p_cmdargs->feature_name.txt), (p_cmdargs->enable_noreply.is_valid));
+        rtn = demo_fwfeat_set(cli_p_cl, (p_cmdargs->feature_name.txt), (p_cmdargs->enable_noreply.is_valid));
     }
     
     return (rtn);
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_if.c b/sw/libfci_cli/src/libfci_cli_cmds_if.c
index b341cff..5023dd8 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_if.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_if.c
@@ -33,15 +33,21 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
 #include "libfci_cli_cmds_if.h"
 
-#include "libfci_interface/fci_common.h"
-#include "libfci_interface/fci_phy_if.h"
-#include "libfci_interface/fci_log_if.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_common.h"
+#include "libfci_demo/demo_phy_if.h"
+#include "libfci_demo/demo_log_if.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -65,34 +71,38 @@ static int logif_print_aux(const fpp_log_if_cmd_t* p_logif, bool is_verbose, boo
     /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
     int indent = ((is_nested_in_phyif) ? (6) : (0));
     
-    printf("%-*s%2"PRIu32": %s: %s\n", indent, "",
-           (p_logif->id),
-           (p_logif->name),
-           cli_value2txt_en_dis(fci_log_if_ld_is_enabled(p_logif)));
+    printf("%-*s%2"PRIu32": %s\n", indent, "",
+           demo_log_if_ld_get_id(p_logif),
+           demo_log_if_ld_get_name(p_logif));
     
     indent += 6;  /* detailed interface info is indented deeper */
     
+    printf("%-*s<%s>\n", indent, "", cli_value2txt_en_dis(demo_log_if_ld_is_enabled(p_logif)));
+    
     printf("%-*s<promisc:%s, match-mode:%s, discard-on-match:%s, loopback:%s>\n", indent, "",
-           cli_value2txt_on_off(fci_log_if_ld_is_promisc(p_logif)),
-           cli_value2txt_or_and(fci_log_if_ld_is_match_mode_or(p_logif)),
-           cli_value2txt_on_off(fci_log_if_ld_is_discard_on_m(p_logif)),
-           cli_value2txt_on_off(fci_log_if_ld_is_loopback(p_logif)));
+           cli_value2txt_on_off(demo_log_if_ld_is_promisc(p_logif)),
+           cli_value2txt_or_and(demo_log_if_ld_is_match_mode_or(p_logif)),
+           cli_value2txt_on_off(demo_log_if_ld_is_discard_on_m(p_logif)),
+           cli_value2txt_on_off(demo_log_if_ld_is_loopback(p_logif)));
     
     printf("%-*saccepted: %"PRIu32" rejected: %"PRIu32" discarded: %"PRIu32" processed: %"PRIu32"\n", indent, "",
-           (p_logif->stats.accepted), (p_logif->stats.rejected), (p_logif->stats.discarded), (p_logif->stats.processed));
+           demo_log_if_ld_get_stt_accepted(p_logif), 
+           demo_log_if_ld_get_stt_rejected(p_logif), 
+           demo_log_if_ld_get_stt_discarded(p_logif), 
+           demo_log_if_ld_get_stt_processed(p_logif));
     
     if (!is_nested_in_phyif)
     {
         printf("%-*sparent: %s\n", indent, "",
-               (p_logif->parent_name));
+               demo_log_if_ld_get_parent_name(p_logif));
     }
     
     printf("%-*segress: ", indent, "");
-    cli_print_bitset32((p_logif->egress), ",", cli_value2txt_phyif, "---");
+    cli_print_bitset32(demo_log_if_ld_get_egress(p_logif), ",", cli_value2txt_phyif, "---");
     printf("\n");
     
     printf("%-*smatch-rules: ", indent, "");
-    cli_print_bitset32((p_logif->match), ",", cli_value2txt_match_rule, "---");
+    cli_print_bitset32(demo_log_if_ld_get_mr_bitset(p_logif), ",", cli_value2txt_match_rule, "---");
     printf("\n");
     
     /* verbose info - match rule arguments (only if corresponding match rule active) */
@@ -100,105 +110,110 @@ static int logif_print_aux(const fpp_log_if_cmd_t* p_logif, bool is_verbose, boo
     {
         indent += 2u;  /* verbose info is indented even deeper */
         
-        if (FPP_IF_MATCH_VLAN & (p_logif->match))
+        const fpp_if_m_rules_t match_rules = demo_log_if_ld_get_mr_bitset(p_logif);
+        
+        if (FPP_IF_MATCH_VLAN & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__VLAN": %"PRIu16"\n", indent, "",
-                   (p_logif->arguments.vlan));
+                   demo_log_if_ld_get_mr_arg_vlan(p_logif));
         }
-        if (FPP_IF_MATCH_PROTO & (p_logif->match))
+        if (FPP_IF_MATCH_PROTO & match_rules)
         {
+            const uint8_t proto = demo_log_if_ld_get_mr_arg_proto(p_logif);
             printf("%-*s"TXT_MATCH_RULE__PROTOCOL": %"PRIu8" (%s)\n", indent, "",
-                   (p_logif->arguments.proto), cli_value2txt_protocol(p_logif->arguments.proto));
+                   (proto), cli_value2txt_protocol(proto));
         }
-        if (FPP_IF_MATCH_SPORT & (p_logif->match))
+        if (FPP_IF_MATCH_SPORT & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__SPORT": %"PRIu16"\n", indent, "",
-                   (p_logif->arguments.sport));
+                   demo_log_if_ld_get_mr_arg_sport(p_logif));
         }
-        if (FPP_IF_MATCH_DPORT & (p_logif->match))
+        if (FPP_IF_MATCH_DPORT & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__DPORT": %"PRIu16"\n", indent, "",
-                   (p_logif->arguments.dport));
+                   demo_log_if_ld_get_mr_arg_dport(p_logif));
         }
-        if (FPP_IF_MATCH_SIP6 & (p_logif->match))
+        if (FPP_IF_MATCH_SIP6 & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__SIP6": ", indent, "");
-            cli_print_ip6(p_logif->arguments.ipv.v6.sip);
+            cli_print_ip6(demo_log_if_ld_get_mr_arg_sip6(p_logif));
             printf("\n");
         }
-        if (FPP_IF_MATCH_DIP6 & (p_logif->match))
+        if (FPP_IF_MATCH_DIP6 & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__DIP6": ", indent, "");
-            cli_print_ip6(p_logif->arguments.ipv.v6.dip);
+            cli_print_ip6(demo_log_if_ld_get_mr_arg_dip6(p_logif));
             printf("\n");
         }
-        if (FPP_IF_MATCH_SIP & (p_logif->match))
+        if (FPP_IF_MATCH_SIP & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__SIP": ", indent, "");
-            cli_print_ip4(p_logif->arguments.ipv.v4.sip, false);
+            cli_print_ip4(demo_log_if_ld_get_mr_arg_sip(p_logif), false);
             printf("\n");
         }
-        if (FPP_IF_MATCH_DIP & (p_logif->match))
+        if (FPP_IF_MATCH_DIP & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__DIP": ", indent, "");
-            cli_print_ip4(p_logif->arguments.ipv.v4.dip, false);
+            cli_print_ip4(demo_log_if_ld_get_mr_arg_dip(p_logif), false);
             printf("\n");
         }
-        if (FPP_IF_MATCH_ETHTYPE & (p_logif->match))
+        if (FPP_IF_MATCH_ETHTYPE & match_rules)
         {
+            const uint16_t ethtype = demo_log_if_ld_get_mr_arg_ethtype(p_logif);
             printf("%-*s"TXT_MATCH_RULE__ETHER_TYPE": %"PRIu16" (0x%04"PRIx16")\n", indent, "", 
-                   (p_logif->arguments.ethtype), (p_logif->arguments.ethtype));
+                   (ethtype), (ethtype));
         }
-        if (FPP_IF_MATCH_FP0 & (p_logif->match))
+        if (FPP_IF_MATCH_FP0 & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__FP_TABLE0": %s\n", indent, "",
-                   (p_logif->arguments.fp_table0));
+                   demo_log_if_ld_get_mr_arg_fp0(p_logif));
         }
-        if (FPP_IF_MATCH_FP1 & (p_logif->match))
+        if (FPP_IF_MATCH_FP1 & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__FP_TABLE1": %s\n", indent, "",
-                   (p_logif->arguments.fp_table1));
+                   demo_log_if_ld_get_mr_arg_fp1(p_logif));
         }
-        if (FPP_IF_MATCH_SMAC & (p_logif->match))
+        if (FPP_IF_MATCH_SMAC & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__SMAC": ", indent, "");
-            cli_print_mac(p_logif->arguments.smac);
+            cli_print_mac(demo_log_if_ld_get_mr_arg_smac(p_logif));
             printf("\n");
         }
-        if (FPP_IF_MATCH_DMAC & (p_logif->match))
+        if (FPP_IF_MATCH_DMAC & match_rules)
         {
             printf("%-*s"TXT_MATCH_RULE__DMAC": ", indent, "");
-            cli_print_mac(p_logif->arguments.dmac);
+            cli_print_mac(demo_log_if_ld_get_mr_arg_dmac(p_logif));
             printf("\n");
         }
-        if (FPP_IF_MATCH_HIF_COOKIE & (p_logif->match))
+        if (FPP_IF_MATCH_HIF_COOKIE & match_rules)
         {
+            const uint32_t hif_cookie = demo_log_if_ld_get_mr_arg_hif_cookie(p_logif);
             printf("%-*s"TXT_MATCH_RULE__HIF_COOKIE": %"PRIu32" (0x%04"PRIx32")\n", indent, "",
-                   (p_logif->arguments.hif_cookie), (p_logif->arguments.hif_cookie));
+                   (hif_cookie), (hif_cookie));
         }
     }
     
     return (FPP_ERR_OK);
 }
 
-static inline int logif_print(const fpp_log_if_cmd_t* p_if)
+static inline int logif_print(const fpp_log_if_cmd_t* p_logif)
 {
-    return logif_print_aux(p_if, false, false);
+    return logif_print_aux(p_logif, false, false);
 }
 
-static inline int logif_print_verbose(const fpp_log_if_cmd_t* p_if)
+static inline int logif_print_verbose(const fpp_log_if_cmd_t* p_logif)
 {
-    return logif_print_aux(p_if, true, false);
+    return logif_print_aux(p_logif, true, false);
 }
 
-static inline int logif_print_in_phyif(const fpp_log_if_cmd_t* p_if)
+static inline int logif_print_in_phyif(const fpp_log_if_cmd_t* p_logif)
 {
-    return logif_print_aux(p_if, false, true);
+    return logif_print_aux(p_logif, false, true);
 }
 
-static inline int logif_print_in_phyif_verbose(const fpp_log_if_cmd_t* p_if)
+static inline int logif_print_in_phyif_verbose(const fpp_log_if_cmd_t* p_logif)
 {
-    return logif_print_aux(p_if, true, true);
+    return logif_print_aux(p_logif, true, true);
 }
 
 /* ==== PRIVATE FUNCTIONS : prints for PHYIF =============================== */
@@ -211,37 +226,38 @@ static int phyif_print_aux(const fpp_phy_if_cmd_t* p_phyif, bool is_verbose)
     /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
     int indent = 0;
     
-    printf("%-*s%2"PRIu32": %s: %s\n", indent, "",
-           (p_phyif->id),
-           (p_phyif->name),
-           cli_value2txt_en_dis(fci_phy_if_ld_is_enabled(p_phyif)));
+    printf("%-*s%2"PRIu32": %s\n", indent, "",
+           demo_phy_if_ld_get_id(p_phyif),
+           demo_phy_if_ld_get_name(p_phyif));
            
     indent += 6u;  /* detailed info is indented deeper */
     
+    printf("%-*s<%s>\n", indent, "", cli_value2txt_en_dis(demo_phy_if_ld_is_enabled(p_phyif)));
+    
     printf("%-*s<promisc:%s, mode:%s, block-state:%s, loadbalance:%s>\n", indent, "",
-           cli_value2txt_on_off(fci_phy_if_ld_is_promisc(p_phyif)),
-           cli_value2txt_if_mode(p_phyif->mode),
-           cli_value2txt_if_block_state(p_phyif->block_state), 
-           cli_value2txt_on_off(fci_phy_if_ld_is_loadbalance(p_phyif)));
+           cli_value2txt_on_off(demo_phy_if_ld_is_promisc(p_phyif)),
+           cli_value2txt_if_mode(demo_phy_if_ld_get_mode(p_phyif)),
+           cli_value2txt_if_block_state(demo_phy_if_ld_get_block_state(p_phyif)), 
+           cli_value2txt_on_off(demo_phy_if_ld_is_loadbalance(p_phyif)));
     
     printf("%-*s<vlan-conf:%s, ptp-conf:%s, ptp-promisc:%s, q-in-q:%s>\n", indent, "", 
-           cli_value2txt_on_off(fci_phy_if_ld_is_vlan_conf(p_phyif)),
-           cli_value2txt_on_off(fci_phy_if_ld_is_ptp_conf(p_phyif)),
-           cli_value2txt_on_off(fci_phy_if_ld_is_ptp_promisc(p_phyif)),
-           cli_value2txt_on_off(fci_phy_if_ld_is_qinq(p_phyif)));
-    
-    printf("%-*s<discard-if-ttl-below-2:%s>\n", indent, "", 
-           cli_value2txt_on_off(fci_phy_if_ld_is_discard_ttl(p_phyif)));
+           cli_value2txt_on_off(demo_phy_if_ld_is_vlan_conf(p_phyif)),
+           cli_value2txt_on_off(demo_phy_if_ld_is_ptp_conf(p_phyif)),
+           cli_value2txt_on_off(demo_phy_if_ld_is_ptp_promisc(p_phyif)),
+           cli_value2txt_on_off(demo_phy_if_ld_is_qinq(p_phyif)));
     
     printf("%-*singress: %"PRIu32" egress: %"PRIu32" discarded: %"PRIu32" malformed: %"PRIu32"\n", indent, "",
-           (p_phyif->stats.ingress), (p_phyif->stats.egress), (p_phyif->stats.discarded), (p_phyif->stats.malformed));
+           demo_phy_if_ld_get_stt_ingress(p_phyif), 
+           demo_phy_if_ld_get_stt_egress(p_phyif),
+           demo_phy_if_ld_get_stt_discarded(p_phyif), 
+           demo_phy_if_ld_get_stt_malformed(p_phyif));
     
     printf("%-*sMAC: ", indent, "");
-    cli_print_mac(p_phyif->mac_addr);
+    cli_print_mac(demo_phy_if_ld_get_mac(p_phyif));
     printf("\n");
     
     printf("%-*smirror: (%s) ", indent, "",
-           cli_value2txt_on_off(fci_phy_if_ld_is_mirror(p_phyif)));
+           cli_value2txt_on_off(demo_phy_if_ld_is_mirror(p_phyif)));
     cli_print_tablenames(&(p_phyif->mirror), 1u, "", "---");
     printf("\n");
     
@@ -252,16 +268,16 @@ static int phyif_print_aux(const fpp_phy_if_cmd_t* p_phyif, bool is_verbose)
     return (FPP_ERR_OK);
 }
 
-static inline int phyif_print(const fpp_phy_if_cmd_t* p_if)
+static inline int phyif_print(const fpp_phy_if_cmd_t* p_phyif)
 {   
-    phyif_print_aux(p_if, false);
-    return fci_log_if_print_by_parent(cli_p_cl, logif_print_in_phyif, (p_if->name));
+    phyif_print_aux(p_phyif, false);
+    return demo_log_if_print_all(cli_p_cl, logif_print_in_phyif, demo_phy_if_ld_get_name(p_phyif));
 }
 
-static inline int phyif_print_verbose(const fpp_phy_if_cmd_t* p_if)
+static inline int phyif_print_verbose(const fpp_phy_if_cmd_t* p_phyif)
 {   
-    phyif_print_aux(p_if, true);
-    return fci_log_if_print_by_parent(cli_p_cl, logif_print_in_phyif_verbose, (p_if->name));
+    phyif_print_aux(p_phyif, true);
+    return demo_log_if_print_all(cli_p_cl, logif_print_in_phyif_verbose, demo_phy_if_ld_get_name(p_phyif));
 }
 
 /* ==== PRIVATE FUNCTIONS : cmds =========================================== */
@@ -274,12 +290,12 @@ static int exec_inside_locked_session(cb_cmdexec_t p_cb_cmdexec, const cli_cmdar
     
     
     int rtn = CLI_ERR;
-    rtn = fci_if_session_lock(cli_p_cl);
+    rtn = demo_if_session_lock(cli_p_cl);
     if (FPP_ERR_OK == rtn)
     {
         rtn = p_cb_cmdexec(p_cmdargs);
     }
-    rtn = fci_if_session_unlock(cli_p_cl, rtn);
+    rtn = demo_if_session_unlock(cli_p_cl, rtn);
     
     return (rtn);
 }
@@ -297,11 +313,11 @@ static int stt_cmd_phyif_print(const cli_cmdargs_t* p_cmdargs)
     /* empty */
     
     /* exec */
-    const fci_phy_if_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (phyif_print_verbose) : (phyif_print));
+    const demo_phy_if_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (phyif_print_verbose) : (phyif_print));
     if (p_cmdargs->if_name.is_valid)
     {
-        /* print single interface */
-        rtn = fci_phy_if_get_by_name(cli_p_cl, &phyif, (p_cmdargs->if_name.txt));    
+        /* print a single interface */
+        rtn = demo_phy_if_get_by_name(cli_p_cl, &phyif, (p_cmdargs->if_name.txt));    
         if (FPP_ERR_OK == rtn)
         {
             rtn = p_cb_print(&phyif);
@@ -310,7 +326,7 @@ static int stt_cmd_phyif_print(const cli_cmdargs_t* p_cmdargs)
     else
     {
         /* print all interfaces */
-        rtn = fci_phy_if_print_all(cli_p_cl, p_cb_print);
+        rtn = demo_phy_if_print_all(cli_p_cl, p_cb_print);
     }
     
     return (rtn);
@@ -326,81 +342,80 @@ static int stt_cmd_phyif_update(const cli_cmdargs_t* p_cmdargs)
     fpp_phy_if_cmd_t phyif = {0};
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_phy_if_get_by_name(cli_p_cl, &phyif, (p_cmdargs->if_name.txt));
+        rtn = demo_phy_if_get_by_name(cli_p_cl, &phyif, (p_cmdargs->if_name.txt));
     }
     
     /* modify local data - bitflags */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->enable_noreply.is_valid))
-        {
-            rtn = fci_phy_if_ld_enable(&phyif);
-        }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->disable_noorig.is_valid))
+        if (p_cmdargs->enable_noreply.is_valid)
         {
-            rtn = fci_phy_if_ld_disable(&phyif);
+            demo_phy_if_ld_enable(&phyif);
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->promisc.is_valid))
+        if (p_cmdargs->disable_noorig.is_valid)
         {
-            rtn = fci_phy_if_ld_set_promisc(&phyif, (p_cmdargs->promisc.is_on));
+            demo_phy_if_ld_disable(&phyif);
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+        if (p_cmdargs->promisc.is_valid)
         {
-            rtn = fci_phy_if_ld_set_loadbalance(&phyif, (p_cmdargs->loadbalance__ttl_decr.is_on));
+            demo_phy_if_ld_set_promisc(&phyif, (p_cmdargs->promisc.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->vlan_conf__x_src.is_valid))
+        if (p_cmdargs->loadbalance__ttl_decr.is_valid)
         {
-            rtn = fci_phy_if_ld_set_vlan_conf(&phyif, (p_cmdargs->vlan_conf__x_src.is_on));
+            demo_phy_if_ld_set_loadbalance(&phyif, (p_cmdargs->loadbalance__ttl_decr.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ptp_conf__x_dst.is_valid))
+        if (p_cmdargs->vlan_conf__x_src.is_valid)
         {
-            rtn = fci_phy_if_ld_set_ptp_conf(&phyif, (p_cmdargs->ptp_conf__x_dst.is_on));
+            demo_phy_if_ld_set_vlan_conf(&phyif, (p_cmdargs->vlan_conf__x_src.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->ptp_promisc.is_valid))
+        if (p_cmdargs->ptp_conf__x_dst.is_valid)
         {
-            rtn = fci_phy_if_ld_set_ptp_promisc(&phyif, (p_cmdargs->ptp_promisc.is_on));
+            demo_phy_if_ld_set_ptp_conf(&phyif, (p_cmdargs->ptp_conf__x_dst.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->qinq.is_valid))
+        if (p_cmdargs->ptp_promisc.is_valid)
         {
-            rtn = fci_phy_if_ld_set_qinq(&phyif, (p_cmdargs->qinq.is_on));
+            demo_phy_if_ld_set_ptp_promisc(&phyif, (p_cmdargs->ptp_promisc.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->discard_if_ttl_below_2.is_valid))
+        if (p_cmdargs->qinq.is_valid)
         {
-            rtn = fci_phy_if_ld_set_discard_ttl(&phyif, (p_cmdargs->discard_if_ttl_below_2.is_on));
+            demo_phy_if_ld_set_qinq(&phyif, (p_cmdargs->qinq.is_on));
         }
     }
     
     /* modify local data - misc configuration */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->if_mode.is_valid))
+        if (p_cmdargs->if_mode.is_valid)
         {
-            rtn = fci_phy_if_ld_set_mode(&phyif, (p_cmdargs->if_mode.value));
+            demo_phy_if_ld_set_mode(&phyif, (p_cmdargs->if_mode.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->if_block_state.is_valid))
+        if (p_cmdargs->if_block_state.is_valid)
         {
-            rtn = fci_phy_if_ld_set_block_state(&phyif, (p_cmdargs->if_block_state.value));
+            demo_phy_if_ld_set_block_state(&phyif, (p_cmdargs->if_block_state.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->if_name_mirror.is_valid))
+        if (p_cmdargs->if_name_mirror.is_valid)
         {
-            rtn = fci_phy_if_ld_set_mirror(&phyif, (p_cmdargs->if_name_mirror.txt));
+            demo_phy_if_ld_set_mirror(&phyif, (p_cmdargs->if_name_mirror.txt));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->table0_name.is_valid))
+        if (p_cmdargs->table0_name.is_valid)
         {
-            rtn = fci_phy_if_ld_set_flexifilter(&phyif, (p_cmdargs->table0_name.txt));
+            demo_phy_if_ld_set_flexifilter(&phyif, (p_cmdargs->table0_name.txt));
         }
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_phy_if_update(cli_p_cl, &phyif);
+        rtn = demo_phy_if_update(cli_p_cl, &phyif);
     }
     
     return (rtn);
@@ -419,11 +434,11 @@ static int stt_cmd_logif_print(const cli_cmdargs_t* p_cmdargs)
     /* empty */
     
     /* exec */
-    const fci_log_if_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (logif_print_verbose) : (logif_print));
+    const demo_log_if_cb_print_t p_cb_print = ((p_cmdargs->verbose.is_valid) ? (logif_print_verbose) : (logif_print));
     if (p_cmdargs->if_name.is_valid)
     {
-        /*  print single interface  */
-        rtn = fci_log_if_get_by_name(cli_p_cl, &logif, (p_cmdargs->if_name.txt));
+        /*  print a single interface  */
+        rtn = demo_log_if_get_by_name(cli_p_cl, &logif, (p_cmdargs->if_name.txt));
         if (FPP_ERR_OK == rtn)
         {
             rtn = p_cb_print(&logif);
@@ -432,7 +447,7 @@ static int stt_cmd_logif_print(const cli_cmdargs_t* p_cmdargs)
     else
     {
         /* print all interfaces */
-        rtn = fci_log_if_print_all(cli_p_cl, p_cb_print);
+        rtn = demo_log_if_print_all(cli_p_cl, p_cb_print, NULL);
     }
 
     return (rtn);
@@ -486,111 +501,165 @@ static int stt_cmd_logif_update(const cli_cmdargs_t* p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_log_if_get_by_name(cli_p_cl, &logif, (p_cmdargs->if_name.txt));
+        rtn = demo_log_if_get_by_name(cli_p_cl, &logif, (p_cmdargs->if_name.txt));
     }
     
     /* modify local data - match rules */
     if ((FPP_ERR_OK == rtn) && (p_cmdargs->match_rules.is_valid))
     {
-        /* shortcut - set all requested match rules at once (even those which require args) */
-        fci_log_if_ld_clear_all_mr(&logif);
-        logif.match = match_rules;
+        /* clear any previous rules */
+        demo_log_if_ld_clear_all_mr(&logif);
+        
+        /* set non-argument rules */
+        if (FPP_IF_MATCH_TYPE_ETH & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_eth(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_VLAN & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_vlan(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_PPPOE & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_pppoe(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_ARP & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_arp(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_MCAST & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_mcast(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_IPV4 & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_ip4(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_IPV6 & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_ip6(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_IPX & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_ipx(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_BCAST & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_bcast(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_UDP & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_udp(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_TCP & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_tcp(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_ICMP & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_icmp(&logif, true);
+        }
+        if (FPP_IF_MATCH_TYPE_IGMP & match_rules)
+        {
+            demo_log_if_ld_set_mr_type_igmp(&logif, true);
+        }
         
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_VLAN & match_rules))
+        /* set argument rules */
+        if (FPP_IF_MATCH_VLAN & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_vlan(&logif, true, (p_cmdargs->vlan.value));
+            demo_log_if_ld_set_mr_vlan(&logif, true, (p_cmdargs->vlan.value));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_PROTO & match_rules))
+        if (FPP_IF_MATCH_PROTO & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_proto(&logif, true, (p_cmdargs->protocol.value));
+            demo_log_if_ld_set_mr_proto(&logif, true, (p_cmdargs->protocol.value));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SPORT & match_rules))
+        if (FPP_IF_MATCH_SPORT & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_sport(&logif, true, (p_cmdargs->sport.value));
+            demo_log_if_ld_set_mr_sport(&logif, true, (p_cmdargs->sport.value));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DPORT & match_rules))
+        if (FPP_IF_MATCH_DPORT & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_dport(&logif, true, (p_cmdargs->dport.value));
+            demo_log_if_ld_set_mr_dport(&logif, true, (p_cmdargs->dport.value));
         } 
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SIP6 & match_rules))
+        if (FPP_IF_MATCH_SIP6 & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_sip6(&logif, true, (p_cmdargs->sip2.arr));
+            demo_log_if_ld_set_mr_sip6(&logif, true, (p_cmdargs->sip2.arr));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DIP6 & match_rules))
+        if (FPP_IF_MATCH_DIP6 & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_dip6(&logif, true, (p_cmdargs->dip2.arr));
+            demo_log_if_ld_set_mr_dip6(&logif, true, (p_cmdargs->dip2.arr));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SIP & match_rules))
+        if (FPP_IF_MATCH_SIP & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_sip(&logif, true, (p_cmdargs->sip.arr[0]));
+            demo_log_if_ld_set_mr_sip(&logif, true, (p_cmdargs->sip.arr[0]));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DIP & match_rules))
+        if (FPP_IF_MATCH_DIP & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_dip(&logif, true, (p_cmdargs->dip.arr[0]));
+            demo_log_if_ld_set_mr_dip(&logif, true, (p_cmdargs->dip.arr[0]));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_ETHTYPE & match_rules))
+        if (FPP_IF_MATCH_ETHTYPE & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_ethtype(&logif, true, (p_cmdargs->count_ethtype.value));
+            demo_log_if_ld_set_mr_ethtype(&logif, true, (p_cmdargs->count_ethtype.value));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_FP0 & match_rules))
+        if (FPP_IF_MATCH_FP0 & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_fp0(&logif, true, (p_cmdargs->table0_name.txt));
+            demo_log_if_ld_set_mr_fp0(&logif, true, (p_cmdargs->table0_name.txt));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_FP1 & match_rules))
+        if (FPP_IF_MATCH_FP1 & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_fp1(&logif, true, (p_cmdargs->table1_name.txt));
+            demo_log_if_ld_set_mr_fp1(&logif, true, (p_cmdargs->table1_name.txt));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_SMAC & match_rules))
+        if (FPP_IF_MATCH_SMAC & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_smac(&logif, true, (p_cmdargs->smac.arr));
+            demo_log_if_ld_set_mr_smac(&logif, true, (p_cmdargs->smac.arr));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_DMAC & match_rules))
+        if (FPP_IF_MATCH_DMAC & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_dmac(&logif, true, (p_cmdargs->dmac.arr));
+            demo_log_if_ld_set_mr_dmac(&logif, true, (p_cmdargs->dmac.arr));
         }
-        if ((FPP_ERR_OK == rtn) && (FPP_IF_MATCH_HIF_COOKIE & match_rules))
+        if (FPP_IF_MATCH_HIF_COOKIE & match_rules)
         {
-            rtn = fci_log_if_ld_set_mr_hif_cookie(&logif, true, (p_cmdargs->data_hifc_sad.value));
+            demo_log_if_ld_set_mr_hif_cookie(&logif, true, (p_cmdargs->data_hifc_sad.value));
         }
     }
     
     /* modify local data - bitflags + egress */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->enable_noreply.is_valid))
+        if (p_cmdargs->enable_noreply.is_valid)
         {
-            rtn = fci_log_if_ld_enable(&logif);
+            demo_log_if_ld_enable(&logif);
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->disable_noorig.is_valid))
+        if (p_cmdargs->disable_noorig.is_valid)
         {
-            rtn = fci_log_if_ld_disable(&logif);
+            demo_log_if_ld_disable(&logif);
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->promisc.is_valid))
+        if (p_cmdargs->promisc.is_valid)
         {
-            rtn = fci_log_if_ld_set_promisc(&logif, (p_cmdargs->promisc.is_on));
+            demo_log_if_ld_set_promisc(&logif, (p_cmdargs->promisc.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->loopback.is_valid))
+        if (p_cmdargs->loopback.is_valid)
         {
-            rtn = fci_log_if_ld_set_loopback(&logif, (p_cmdargs->loopback.is_on));
+            demo_log_if_ld_set_loopback(&logif, (p_cmdargs->loopback.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->match_mode.is_valid))
+        if (p_cmdargs->match_mode.is_valid)
         {
-            rtn = fci_log_if_ld_set_match_mode_or(&logif, (p_cmdargs->match_mode.is_or));
+            demo_log_if_ld_set_match_mode_or(&logif, (p_cmdargs->match_mode.is_or));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->discard_on_match.is_valid))
+        if (p_cmdargs->discard_on_match.is_valid)
         {
-            rtn = fci_log_if_ld_set_discard_on_m(&logif, (p_cmdargs->discard_on_match.is_on));
+            demo_log_if_ld_set_discard_on_m(&logif, (p_cmdargs->discard_on_match.is_on));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->egress.is_valid))
+        if (p_cmdargs->egress.is_valid)
         {
-            rtn = fci_log_if_ld_set_egress_phyifs(&logif, (p_cmdargs->egress.bitset));
+            demo_log_if_ld_set_egress_phyifs(&logif, (p_cmdargs->egress.bitset));
         }
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_log_if_update(cli_p_cl, &logif);
+        rtn = demo_log_if_update(cli_p_cl, &logif);
     }
     
     return (rtn);
@@ -615,7 +684,7 @@ static int stt_cmd_logif_add(const cli_cmdargs_t* p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_log_if_add(cli_p_cl, 0, (p_cmdargs->if_name.txt), (p_cmdargs->if_name_parent.txt));
+        rtn = demo_log_if_add(cli_p_cl, 0, (p_cmdargs->if_name.txt), (p_cmdargs->if_name_parent.txt));
     }
     
     return (rtn);
@@ -630,13 +699,16 @@ static int stt_cmd_logif_del(const cli_cmdargs_t* p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_log_if_del(cli_p_cl, (p_cmdargs->if_name.txt));
+        rtn = demo_log_if_del(cli_p_cl, (p_cmdargs->if_name.txt));
     }
     
     return (rtn);
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_qos.c b/sw/libfci_cli/src/libfci_cli_cmds_qos.c
index 91dd465..b80a602 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_qos.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_qos.c
@@ -33,13 +33,19 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
 #include "libfci_cli_cmds_qos.h"
 
-#include "libfci_interface/fci_qos.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_qos.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -61,7 +67,7 @@ static int qos_que_print(const fpp_qos_queue_cmd_t* p_que)
     /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
     int indent = 0;
     
-    printf("%-*squeue %"PRIu8":\n", indent, "", (p_que->id));
+    printf("%-*squeue %"PRIu8":\n", indent, "", demo_qos_que_ld_get_id(p_que));
     
     indent += 4;
     
@@ -69,17 +75,17 @@ static int qos_que_print(const fpp_qos_queue_cmd_t* p_que)
            "%-*sque-mode:  %"PRIu8" (%s)\n"
            "%-*sthld-min:  %"PRIu32"\n"
            "%-*sthld-max:  %"PRIu32"\n",
-           indent, "", (p_que->if_name),
-           indent, "", (p_que->mode), cli_value2txt_que_mode(p_que->mode),
-           indent, "", (p_que->min),
-           indent, "", (p_que->max));
+           indent, "", demo_qos_que_ld_get_if_name(p_que),
+           indent, "", demo_qos_que_ld_get_mode(p_que), cli_value2txt_que_mode(demo_qos_que_ld_get_mode(p_que)),
+           indent, "", demo_qos_que_ld_get_min(p_que),
+           indent, "", demo_qos_que_ld_get_max(p_que));
     
     {
         printf("%-*szprob:     ", indent, "");
         const char* p_txt_delim = "";  /* no delim in front of the first item */
         for (uint8_t i = 0u; (ZPROBS_LN > i); (++i))
         {
-            printf("%s[%"PRIu8"]<%"PRIu8">", p_txt_delim, i, p_que->zprob[i]);
+            printf("%s[%"PRIu8"]<%"PRIu8">", p_txt_delim, i, demo_qos_que_ld_get_zprob_by_id(p_que, i));
             p_txt_delim = ",";
         }
         printf("\n");
@@ -96,26 +102,28 @@ static int qos_sch_print(const fpp_qos_scheduler_cmd_t* p_sch)
     /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
     int indent = 0;
     
-    printf("%-*sscheduler %"PRIu8":\n", indent, "", (p_sch->id));
+    printf("%-*sscheduler %"PRIu8":\n", indent, "", demo_qos_sch_ld_get_id(p_sch));
     
     indent += 4;
     
+    const uint8_t sch_mode = demo_qos_sch_ld_get_mode(p_sch);
+    const uint8_t sch_algo = demo_qos_sch_ld_get_algo(p_sch);
     printf("%-*sinterface: %s\n"
            "%-*ssch-mode:  %"PRIu8" (%s)\n"
            "%-*ssch-algo:  %"PRIu8" (%s)\n",
-           indent, "", (p_sch->if_name),
-           indent, "", (p_sch->mode), cli_value2txt_sch_mode(p_sch->mode),
-           indent, "", (p_sch->algo), cli_value2txt_sch_algo(p_sch->algo));
+           indent, "", demo_qos_sch_ld_get_if_name(p_sch),
+           indent, "", (sch_mode), cli_value2txt_sch_mode(sch_mode),
+           indent, "", (sch_algo), cli_value2txt_sch_algo(sch_algo));
     
     {
         printf("%-*ssch-in:    ", indent, "");
         const char* p_txt_delim = "";  /* no delim in front of the first item */
         for (uint8_t i = 0u; (SCH_INS_LN > i); (++i))
         {
-            const char* p_txt = cli_value2txt_sch_in(p_sch->input_src[i]);
-            if (fci_qos_sch_ld_is_input_enabled(p_sch, i))
+            const char* p_txt = cli_value2txt_sch_in(demo_qos_sch_ld_get_input_src(p_sch, i));
+            if (demo_qos_sch_ld_is_input_enabled(p_sch, i))
             {
-                printf("%s[%"PRIu8"]<%s:%"PRIu32">", p_txt_delim, i, p_txt, (p_sch->input_w[i]));
+                printf("%s[%"PRIu8"]<%s:%"PRIu32">", p_txt_delim, i, p_txt, demo_qos_sch_ld_get_input_weight(p_sch, i));
             }
             else
             {
@@ -137,7 +145,7 @@ static int qos_shp_print(const fpp_qos_shaper_cmd_t* p_shp)
     /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
     int indent = 0;
     
-    printf("%-*sshaper %"PRIu8":\n", indent, "", (p_shp->id));
+    printf("%-*sshaper %"PRIu8":\n", indent, "", demo_qos_shp_ld_get_id(p_shp));
     
     indent += 4;
     
@@ -147,12 +155,12 @@ static int qos_shp_print(const fpp_qos_shaper_cmd_t* p_shp)
            "%-*sisl:        %"PRIu32"\n"
            "%-*scredit-min: %"PRId32"\n"
            "%-*scredit-max: %"PRId32"\n",
-           indent, "", (p_shp->if_name),
-           indent, "", (p_shp->mode), cli_value2txt_shp_mode(p_shp->mode),
-           indent, "", (p_shp->position), cli_value2txt_shp_pos(p_shp->position),
-           indent, "", (p_shp->isl),
-           indent, "", (p_shp->min_credit),
-           indent, "", (p_shp->max_credit));
+           indent, "", demo_qos_shp_ld_get_if_name(p_shp),
+           indent, "", demo_qos_shp_ld_get_mode(p_shp), cli_value2txt_shp_mode(demo_qos_shp_ld_get_mode(p_shp)),
+           indent, "", demo_qos_shp_ld_get_position(p_shp), cli_value2txt_shp_pos(demo_qos_shp_ld_get_position(p_shp)),
+           indent, "", demo_qos_shp_ld_get_isl(p_shp),
+           indent, "", demo_qos_shp_ld_get_min_credit(p_shp),
+           indent, "", demo_qos_shp_ld_get_max_credit(p_shp));
     
     return (FPP_ERR_OK); 
 }
@@ -169,7 +177,10 @@ int cli_cmd_qos_que_print(const cli_cmdargs_t *p_cmdargs)
     fpp_qos_queue_cmd_t que = {0};
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)}};
+    const mandopt_t mandopts[] =
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
@@ -177,8 +188,8 @@ int cli_cmd_qos_que_print(const cli_cmdargs_t *p_cmdargs)
     {
         if (p_cmdargs->que_sch_shp.is_valid)
         {
-            /* print single QoS queue */
-            rtn = fci_qos_que_get_by_id(cli_p_cl, &que, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+            /* print a single QoS queue */
+            rtn = demo_qos_que_get_by_id(cli_p_cl, &que, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
             if (FPP_ERR_OK == rtn)
             {
                 rtn = qos_que_print(&que);
@@ -187,7 +198,7 @@ int cli_cmd_qos_que_print(const cli_cmdargs_t *p_cmdargs)
         else
         {
             /* print all QoS queues of the given interface */
-            rtn = fci_qos_que_print_by_phyif(cli_p_cl, qos_que_print, (p_cmdargs->if_name.txt));
+            rtn = demo_qos_que_print_by_phyif(cli_p_cl, qos_que_print, (p_cmdargs->if_name.txt));
         }
     }
     
@@ -214,35 +225,35 @@ int cli_cmd_qos_que_update(const cli_cmdargs_t* p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_qos_que_get_by_id(cli_p_cl, &que, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+        rtn = demo_qos_que_get_by_id(cli_p_cl, &que, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
     }
     
     /* modify local data - misc */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->que_sch_shp_mode.is_valid))
+        if (p_cmdargs->que_sch_shp_mode.is_valid)
         {
-            rtn = fci_qos_que_ld_set_mode(&que, (p_cmdargs->que_sch_shp_mode.value));
+            demo_qos_que_ld_set_mode(&que, (p_cmdargs->que_sch_shp_mode.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->thmin.is_valid))
+        if (p_cmdargs->thmin.is_valid)
         {
-            rtn = fci_qos_que_ld_set_min(&que, (p_cmdargs->thmin.value));
+            demo_qos_que_ld_set_min(&que, (p_cmdargs->thmin.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->thmax.is_valid))
+        if (p_cmdargs->thmax.is_valid)
         {
-            rtn = fci_qos_que_ld_set_max(&que, (p_cmdargs->thmax.value));
+            demo_qos_que_ld_set_max(&que, (p_cmdargs->thmax.value));
         }
     }
     
     /* modify local data - zprob elements */
-    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->zprob.is_valid)))
+    if ((FPP_ERR_OK == rtn) && (p_cmdargs->zprob.is_valid))
     {
         for (uint8_t i = 0u; (ZPROBS_LN > i); (++i))
         {
             const uint8_t cmdarg_value = (p_cmdargs->zprob.arr[i]);
             if (cli_que_zprob_is_not_keep(cmdarg_value))
             {
-                fci_qos_que_ld_set_zprob(&que, i, cmdarg_value);
+                demo_qos_que_ld_set_zprob(&que, i, cmdarg_value);
             }
         }
     }
@@ -250,7 +261,7 @@ int cli_cmd_qos_que_update(const cli_cmdargs_t* p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_qos_que_update(cli_p_cl, &que);
+        rtn = demo_qos_que_update(cli_p_cl, &que);
     }
     
     return (rtn);
@@ -268,7 +279,10 @@ int cli_cmd_qos_sch_print(const cli_cmdargs_t *p_cmdargs)
     fpp_qos_scheduler_cmd_t sch = {0};
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
@@ -276,8 +290,8 @@ int cli_cmd_qos_sch_print(const cli_cmdargs_t *p_cmdargs)
     {
         if (p_cmdargs->que_sch_shp.is_valid)
         {
-            /* print single QoS scheduler */
-            rtn = fci_qos_sch_get_by_id(cli_p_cl, &sch, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+            /* print a single QoS scheduler */
+            rtn = demo_qos_sch_get_by_id(cli_p_cl, &sch, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
             if (FPP_ERR_OK == rtn)
             {
                 rtn = qos_sch_print(&sch);
@@ -286,7 +300,7 @@ int cli_cmd_qos_sch_print(const cli_cmdargs_t *p_cmdargs)
         else
         {
             /* print all QoS schedulers of the given interface */
-            rtn = fci_qos_sch_print_by_phyif(cli_p_cl, qos_sch_print, (p_cmdargs->if_name.txt));
+            rtn = demo_qos_sch_print_by_phyif(cli_p_cl, qos_sch_print, (p_cmdargs->if_name.txt));
         }
     }
     
@@ -313,24 +327,24 @@ int cli_cmd_qos_sch_update(const cli_cmdargs_t* p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_qos_sch_get_by_id(cli_p_cl, &sch, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+        rtn = demo_qos_sch_get_by_id(cli_p_cl, &sch, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
     }
     
     /* modify local data - misc */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->que_sch_shp_mode.is_valid))
+        if (p_cmdargs->que_sch_shp_mode.is_valid)
         {
-            rtn = fci_qos_sch_ld_set_mode(&sch, (p_cmdargs->que_sch_shp_mode.value));
+            demo_qos_sch_ld_set_mode(&sch, (p_cmdargs->que_sch_shp_mode.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->sch_algo.is_valid))
+        if (p_cmdargs->sch_algo.is_valid)
         {
-            rtn = fci_qos_sch_ld_set_algo(&sch, (p_cmdargs->sch_algo.value));
+            demo_qos_sch_ld_set_algo(&sch, (p_cmdargs->sch_algo.value));
         }
     }
     
     /* modify local data - scheduler inputs */
-    if ((FPP_ERR_OK == rtn) && ((p_cmdargs->sch_in.is_valid)))
+    if ((FPP_ERR_OK == rtn) && (p_cmdargs->sch_in.is_valid))
     {
         for (uint8_t i = 0u; (SCH_INS_LN > i); (++i))
         {
@@ -339,7 +353,7 @@ int cli_cmd_qos_sch_update(const cli_cmdargs_t* p_cmdargs)
             if (cli_que_zprob_is_not_keep(cmdarg_src))
             {
                 const bool enable = cli_sch_in_is_not_dis(cmdarg_src);
-                fci_qos_sch_ld_set_input(&sch, i, enable, cmdarg_src, cmdarg_w);
+                demo_qos_sch_ld_set_input(&sch, i, enable, cmdarg_src, cmdarg_w);
             }
         }
     }
@@ -347,7 +361,7 @@ int cli_cmd_qos_sch_update(const cli_cmdargs_t* p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_qos_sch_update(cli_p_cl, &sch);
+        rtn = demo_qos_sch_update(cli_p_cl, &sch);
     }
     
     return (rtn);
@@ -365,7 +379,10 @@ int cli_cmd_qos_shp_print(const cli_cmdargs_t *p_cmdargs)
     fpp_qos_shaper_cmd_t shp = {0};
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_INTERFACE,  NULL,  (p_cmdargs->if_name.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_INTERFACE, NULL, (p_cmdargs->if_name.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
@@ -373,8 +390,8 @@ int cli_cmd_qos_shp_print(const cli_cmdargs_t *p_cmdargs)
     {
         if (p_cmdargs->que_sch_shp.is_valid)
         {
-            /* print single QoS shaper */
-            rtn = fci_qos_shp_get_by_id(cli_p_cl, &shp, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+            /* print a single QoS shaper */
+            rtn = demo_qos_shp_get_by_id(cli_p_cl, &shp, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
             if (FPP_ERR_OK == rtn)
             {
                 rtn = qos_shp_print(&shp);
@@ -383,7 +400,7 @@ int cli_cmd_qos_shp_print(const cli_cmdargs_t *p_cmdargs)
         else
         {
             /* print all QoS schedulers of the given interface */
-            rtn = fci_qos_shp_print_by_phyif(cli_p_cl, qos_shp_print, (p_cmdargs->if_name.txt));
+            rtn = demo_qos_shp_print_by_phyif(cli_p_cl, qos_shp_print, (p_cmdargs->if_name.txt));
         }
     }
     
@@ -410,38 +427,38 @@ int cli_cmd_qos_shp_update(const cli_cmdargs_t* p_cmdargs)
     /* get init local data */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_qos_shp_get_by_id(cli_p_cl, &shp, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
+        rtn = demo_qos_shp_get_by_id(cli_p_cl, &shp, (p_cmdargs->if_name.txt), (p_cmdargs->que_sch_shp.value));
     }
     
     /* modify local data - misc */
     if (FPP_ERR_OK == rtn)
     {
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->que_sch_shp_mode.is_valid))
+        if (p_cmdargs->que_sch_shp_mode.is_valid)
         {
-            rtn = fci_qos_shp_ld_set_mode(&shp, (p_cmdargs->que_sch_shp_mode.value));
+            demo_qos_shp_ld_set_mode(&shp, (p_cmdargs->que_sch_shp_mode.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->shp_pos.is_valid))
+        if (p_cmdargs->shp_pos.is_valid)
         {
-            rtn = fci_qos_shp_ld_set_position(&shp, (p_cmdargs->shp_pos.value));
+            demo_qos_shp_ld_set_position(&shp, (p_cmdargs->shp_pos.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->isl.is_valid))
+        if (p_cmdargs->isl.is_valid)
         {
-            rtn = fci_qos_shp_ld_set_isl(&shp, (p_cmdargs->isl.value));
+            demo_qos_shp_ld_set_isl(&shp, (p_cmdargs->isl.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->crmin.is_valid))
+        if (p_cmdargs->crmin.is_valid)
         {
-            rtn = fci_qos_shp_ld_set_min_credit(&shp, (p_cmdargs->crmin.value));
+            demo_qos_shp_ld_set_min_credit(&shp, (p_cmdargs->crmin.value));
         }
-        if ((FPP_ERR_OK == rtn) && (p_cmdargs->crmax.is_valid))
+        if (p_cmdargs->crmax.is_valid)
         {
-            rtn = fci_qos_shp_ld_set_max_credit(&shp, (p_cmdargs->crmax.value));
+            demo_qos_shp_ld_set_max_credit(&shp, (p_cmdargs->crmax.value));
         }
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_qos_shp_update(cli_p_cl, &shp);
+        rtn = demo_qos_shp_update(cli_p_cl, &shp);
     }
     
     return (rtn);
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
index 837047b..26f4909 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_route_and_cntk.c
@@ -33,13 +33,19 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
 #include "libfci_cli_cmds_route_and_cntk.h"
 
-#include "libfci_interface/fci_rt_ct.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_rt_ct.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -72,21 +78,21 @@ static int rt_print(const fpp_rt_cmd_t* p_rt)
     }
     
     {
-        printf("| %10"PRIu32, (p_rt->id));
+        printf("| %10"PRIu32, demo_rt_ld_get_route_id(p_rt));
     }
     {
-        const char* p_txt = ((fci_rt_ld_is_ip4(p_rt)) ? (TXT_PROTOCOL__IPv4) :
-                            ((fci_rt_ld_is_ip6(p_rt)) ? (TXT_PROTOCOL__IPv6) : "???"));
+        const char* p_txt = ((demo_rt_ld_is_ip4(p_rt)) ? (TXT_PROTOCOL__IPv4) :
+                            ((demo_rt_ld_is_ip6(p_rt)) ? (TXT_PROTOCOL__IPv6) : "???"));
         printf(" | %4s", p_txt);
     }
     {
         printf(" | ");
-        cli_print_mac(p_rt->src_mac);
+        cli_print_mac(demo_rt_ld_get_src_mac(p_rt));
         printf(" | ");
-        cli_print_mac(p_rt->dst_mac);
+        cli_print_mac(demo_rt_ld_get_dst_mac(p_rt));
     }
     {
-        printf(" | %-15s ", (p_rt->output_device));
+        printf(" | %-15s ", demo_rt_ld_get_egress_phyif(p_rt));
     }
     
     printf(" |\n");
@@ -129,20 +135,21 @@ static int ct_print(const fpp_ct_cmd_t* p_ct)
     indent += 4;
     
     {
+        const uint16_t protocol = demo_ct_ld_get_protocol(p_ct);
         printf("%-*sproto:   %"PRIu16" (%s)\n", indent, "",
-               (p_ct->protocol), cli_value2txt_protocol(p_ct->protocol));
+               protocol, cli_value2txt_protocol(protocol));
     }
     
     {
         printf("%-*sflags:   ", indent, "");
         
-        ct_print_aux_flags(fci_ct_ld_is_ttl_decr(p_ct),   "TTL_DECR ",
-                           fci_ct_ld_is_reply_only(p_ct), "NO_ORIG ",    /* NOTE: negative logic */
-                           fci_ct_ld_is_orig_only(p_ct),  "NO_REPLY ");  /* NOTE: negative logic */
+        ct_print_aux_flags(demo_ct_ld_is_ttl_decr(p_ct),   "TTL_DECR ",
+                           demo_ct_ld_is_reply_only(p_ct), "NO_ORIG ",    /* NOTE: negative logic */
+                           demo_ct_ld_is_orig_only(p_ct),  "NO_REPLY ");  /* NOTE: negative logic */
         printf(" ; ");
-        ct_print_aux_flags(fci_ct_ld_is_nat(p_ct), "NAT ",
-                           fci_ct_ld_is_pat(p_ct), "PAT ",
-                           fci_ct_ld_is_vlan_tagging(p_ct), "VLAN_TAGGING ");
+        ct_print_aux_flags(demo_ct_ld_is_nat(p_ct), "NAT ",
+                           demo_ct_ld_is_pat(p_ct), "PAT ",
+                           demo_ct_ld_is_vlan_tagging(p_ct), "VLAN_TAGGING ");
         printf("\n");
     }
     
@@ -151,15 +158,15 @@ static int ct_print(const fpp_ct_cmd_t* p_ct)
         printf("%-*sorig:    ", indent, "");
         
         printf("src=");
-        cli_print_ip4((p_ct->saddr), true);
+        cli_print_ip4(demo_ct_ld_get_saddr(p_ct), true);
         
         printf("    dst=");
-        cli_print_ip4((p_ct->daddr), true);
+        cli_print_ip4(demo_ct_ld_get_daddr(p_ct), true);
         
-        printf("    sport=%-5"PRIu16, (p_ct->sport));
-        printf("    dport=%-5"PRIu16, (p_ct->dport));
-        printf("    vlan=%-5"PRIu16, (p_ct->vlan));
-        printf("    route=%-10"PRIu32, (p_ct->route_id));
+        printf("    sport=%-5"PRIu16,  demo_ct_ld_get_sport(p_ct));
+        printf("    dport=%-5"PRIu16,  demo_ct_ld_get_dport(p_ct));
+        printf("    vlan=%-5"PRIu16,   demo_ct_ld_get_vlan(p_ct));
+        printf("    route=%-10"PRIu32, demo_ct_ld_get_route_id(p_ct));
         
         printf("\n");
     }
@@ -169,15 +176,15 @@ static int ct_print(const fpp_ct_cmd_t* p_ct)
         printf("%-*sreply: ", indent, "");
         
         printf("r-src=");
-        cli_print_ip4((p_ct->saddr_reply), true);
+        cli_print_ip4(demo_ct_ld_get_saddr_reply(p_ct), true);
         
         printf("  r-dst=");
-        cli_print_ip4((p_ct->daddr_reply), true);
+        cli_print_ip4(demo_ct_ld_get_daddr_reply(p_ct), true);
         
-        printf("  r-sport=%-5"PRIu16, (p_ct->sport_reply));
-        printf("  r-dport=%-5"PRIu16, (p_ct->dport_reply));
-        printf("  r-vlan=%-5"PRIu16, (p_ct->vlan_reply));
-        printf("  r-route=%-10"PRIu32, (p_ct->route_id_reply));
+        printf("  r-sport=%-5"PRIu16,  demo_ct_ld_get_sport_reply(p_ct));
+        printf("  r-dport=%-5"PRIu16,  demo_ct_ld_get_dport_reply(p_ct));
+        printf("  r-vlan=%-5"PRIu16,   demo_ct_ld_get_vlan_reply(p_ct));
+        printf("  r-route=%-10"PRIu32, demo_ct_ld_get_route_id_reply(p_ct));
         
         printf("\n");
     }
@@ -198,20 +205,21 @@ static int ct6_print(const fpp_ct6_cmd_t* p_ct6)
     indent += 4;
     
     {
+        const uint16_t protocol = demo_ct6_ld_get_protocol(p_ct6);
         printf("%-*sproto:   %"PRIu16" (%s)\n", indent, "",
-               (p_ct6->protocol), cli_value2txt_protocol(p_ct6->protocol));
+               (protocol), cli_value2txt_protocol(protocol));
     }
     
     {
         printf("%-*sflags:   ", indent, "");
         
-        ct_print_aux_flags(fci_ct6_ld_is_ttl_decr(p_ct6),   "TTL_DECR ",
-                           fci_ct6_ld_is_reply_only(p_ct6), "NO_ORIG ",    /* NOTE: negative logic */
-                           fci_ct6_ld_is_orig_only(p_ct6),  "NO_REPLY ");  /* NOTE: negative logic */
+        ct_print_aux_flags(demo_ct6_ld_is_ttl_decr(p_ct6),   "TTL_DECR ",
+                           demo_ct6_ld_is_reply_only(p_ct6), "NO_ORIG ",    /* NOTE: negative logic */
+                           demo_ct6_ld_is_orig_only(p_ct6),  "NO_REPLY ");  /* NOTE: negative logic */
         printf(" ; ");
-        ct_print_aux_flags(fci_ct6_ld_is_nat(p_ct6), "NAT ",
-                           fci_ct6_ld_is_pat(p_ct6), "PAT ",
-                           fci_ct6_ld_is_vlan_tagging(p_ct6), "VLAN_TAGGING ");
+        ct_print_aux_flags(demo_ct6_ld_is_nat(p_ct6), "NAT ",
+                           demo_ct6_ld_is_pat(p_ct6), "PAT ",
+                           demo_ct6_ld_is_vlan_tagging(p_ct6), "VLAN_TAGGING ");
         printf("\n");
     }
     
@@ -220,15 +228,15 @@ static int ct6_print(const fpp_ct6_cmd_t* p_ct6)
         printf("%-*sorig:    ", indent, "");
         
         printf("src=");
-        cli_print_ip6(p_ct6->saddr);
+        cli_print_ip6(demo_ct6_ld_get_saddr(p_ct6));
         
         printf("    dst=");
-        cli_print_ip6(p_ct6->daddr);
+        cli_print_ip6(demo_ct6_ld_get_daddr(p_ct6));
         
-        printf("    sport=%-5"PRIu16, (p_ct6->sport));
-        printf("    dport=%-5"PRIu16, (p_ct6->dport));
-        printf("    vlan=%-5"PRIu16, (p_ct6->vlan));
-        printf("    route=%-10"PRIu32, (p_ct6->route_id));
+        printf("    sport=%-5"PRIu16,  demo_ct6_ld_get_sport(p_ct6));
+        printf("    dport=%-5"PRIu16,  demo_ct6_ld_get_dport(p_ct6));
+        printf("    vlan=%-5"PRIu16,   demo_ct6_ld_get_vlan(p_ct6));
+        printf("    route=%-10"PRIu32, demo_ct6_ld_get_route_id(p_ct6));
         
         printf("\n");
     }
@@ -238,15 +246,15 @@ static int ct6_print(const fpp_ct6_cmd_t* p_ct6)
         printf("%-*sreply: ", indent, "");
         
         printf("r-src=");
-        cli_print_ip6(p_ct6->saddr_reply);
+        cli_print_ip6(demo_ct6_ld_get_saddr_reply(p_ct6));
         
         printf("  r-dst=");
-        cli_print_ip6(p_ct6->daddr_reply);
+        cli_print_ip6(demo_ct6_ld_get_daddr_reply(p_ct6));
         
-        printf("  r-sport=%-5"PRIu16, (p_ct6->sport_reply));
-        printf("  r-dport=%-5"PRIu16, (p_ct6->dport_reply));
-        printf("  r-vlan=%-5"PRIu16, (p_ct6->vlan_reply));
-        printf("  r-route=%-10"PRIu32, (p_ct6->route_id_reply));
+        printf("  r-sport=%-5"PRIu16,  demo_ct6_ld_get_sport_reply(p_ct6));
+        printf("  r-dport=%-5"PRIu16,  demo_ct6_ld_get_dport_reply(p_ct6));
+        printf("  r-vlan=%-5"PRIu16,   demo_ct6_ld_get_vlan_reply(p_ct6));
+        printf("  r-route=%-10"PRIu32, demo_ct6_ld_get_route_id_reply(p_ct6));
         
         printf("\n");
     }
@@ -273,7 +281,7 @@ int cli_cmd_route_print(const cli_cmdargs_t *p_cmdargs)
     if (p_cmdargs->route.is_valid)
     {
         /* print single route */
-        rtn = fci_rt_get_by_id(cli_p_cl, &rt, (p_cmdargs->route.value));
+        rtn = demo_rt_get_by_id(cli_p_cl, &rt, (p_cmdargs->route.value));
         if (FPP_ERR_OK == rtn)
         {
             rtn = rt_print(&rt);
@@ -282,17 +290,17 @@ int cli_cmd_route_print(const cli_cmdargs_t *p_cmdargs)
     else if (p_cmdargs->ip4.is_valid)
     {
         /* print all IPv4 routes */
-        rtn = fci_rt_print_all(cli_p_cl, rt_print, true, false);
+        rtn = demo_rt_print_all(cli_p_cl, rt_print, true, false);
     }
     else if (p_cmdargs->ip6.is_valid)
     {
         /* print all IPv6 routes */
-        rtn = fci_rt_print_all(cli_p_cl, rt_print, false, true);
+        rtn = demo_rt_print_all(cli_p_cl, rt_print, false, true);
     }
     else
     {
         /* print all routes */
-        rtn = fci_rt_print_all(cli_p_cl, rt_print, true, true);
+        rtn = demo_rt_print_all(cli_p_cl, rt_print, true, true);
     }
     
     return (rtn);
@@ -319,18 +327,18 @@ int cli_cmd_route_add(const cli_cmdargs_t *p_cmdargs)
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* get init local data */
-    /* empty (no 'init data' from the PFE) */
+    /* empty (no 'init data' from PFE) */
     
     /* modify local data - set IP type */
     if (FPP_ERR_OK == rtn)
     {
         if (p_cmdargs->ip4.is_valid)
         {
-            rtn = fci_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_as_ip4(&rt);
         }
         else if (p_cmdargs->ip6.is_valid)
         {
-            rtn = fci_rt_ld_set_as_ip6(&rt);
+            demo_rt_ld_set_as_ip6(&rt);
         }
         else
         {
@@ -341,25 +349,20 @@ int cli_cmd_route_add(const cli_cmdargs_t *p_cmdargs)
     /* modify local data - smac (optional) */
     if ((FPP_ERR_OK == rtn) && (p_cmdargs->smac.is_valid))
     {
-        rtn = fci_rt_ld_set_src_mac(&rt, (p_cmdargs->smac.arr));
+        demo_rt_ld_set_src_mac(&rt, (p_cmdargs->smac.arr));
     }
     
     /* modify local data - dmac */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_rt_ld_set_dst_mac(&rt, (p_cmdargs->dmac.arr));
-    }
-    
-    /* modify local data - phyif */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_rt_ld_set_egress_phyif(&rt, (p_cmdargs->if_name.txt));
+        demo_rt_ld_set_dst_mac(&rt, (p_cmdargs->dmac.arr));
+        demo_rt_ld_set_egress_phyif(&rt, (p_cmdargs->if_name.txt));
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_rt_add(cli_p_cl, (p_cmdargs->route.value), &rt);
+        rtn = demo_rt_add(cli_p_cl, (p_cmdargs->route.value), &rt);
     }
     
     return (rtn);
@@ -374,13 +377,16 @@ int cli_cmd_route_del(const cli_cmdargs_t *p_cmdargs)
     int rtn = CLI_ERR;
     
     /* check for mandatory opts */
-    const mandopt_t mandopts[] = {{OPT_ROUTE, NULL,  (p_cmdargs->route.is_valid)}};
+    const mandopt_t mandopts[] = 
+    {
+        {OPT_ROUTE, NULL,  (p_cmdargs->route.is_valid)}
+    };
     rtn = cli_mandopt_check(mandopts, MANDOPTS_CALC_LN(mandopts));
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_rt_del(cli_p_cl, (p_cmdargs->route.value));
+        rtn = demo_rt_del(cli_p_cl, (p_cmdargs->route.value));
     }
     
     return (rtn);
@@ -403,11 +409,11 @@ int cli_cmd_cntk_print(const cli_cmdargs_t *p_cmdargs)
     const bool print_all = (!(p_cmdargs->ip4.is_valid) && !(p_cmdargs->ip6.is_valid));
     if ((FPP_ERR_OK == rtn) && ((p_cmdargs->ip4.is_valid) || print_all))
     {
-        rtn = fci_ct_print_all(cli_p_cl, ct_print);
+        rtn = demo_ct_print_all(cli_p_cl, ct_print);
     }
     if ((FPP_ERR_OK == rtn) && ((p_cmdargs->ip6.is_valid) || print_all))
     {
-        rtn = fci_ct6_print_all(cli_p_cl, ct6_print);
+        rtn = demo_ct6_print_all(cli_p_cl, ct6_print);
     }
     
     return (rtn);
@@ -446,7 +452,7 @@ int cli_cmd_cntk_update(const cli_cmdargs_t *p_cmdargs)
     }
     
     /* get init local data */
-    /* empty (no universal 'init data' from the PFE) */
+    /* empty (each conntrack type has its own init data routine) */
     
     /* modify local data */
     if (FPP_ERR_OK == rtn)
@@ -454,49 +460,57 @@ int cli_cmd_cntk_update(const cli_cmdargs_t *p_cmdargs)
         if (p_cmdargs->sip.is6)
         {
             fpp_ct6_cmd_t ct6 = {0};
-            ct6.protocol = (p_cmdargs->protocol.value);
-            ct6.sport = (p_cmdargs->sport.value);
-            ct6.sport = (p_cmdargs->dport.value);
-            memcpy(ct6.saddr, p_cmdargs->sip.arr, (IP6_U32S_LN * sizeof(uint32_t)));
-            memcpy(ct6.daddr, p_cmdargs->dip.arr, (IP6_U32S_LN * sizeof(uint32_t)));
+            
+            /* fill in the 5-tuple data */
+            demo_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
+            demo_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
+                                           (p_cmdargs->sport.value), (p_cmdargs->dport.value), 
+                                            0u, 0uL, false);
             
             /* get init local data */
-            rtn = fci_ct6_get_by_tuple(cli_p_cl, &ct6, &ct6);
+            rtn = demo_ct6_get_by_tuple(cli_p_cl, &ct6, &ct6);
             
             /* modify local data */
-            if ((CLI_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+            if (CLI_OK == rtn)
             {
-                rtn = fci_ct6_ld_set_ttl_decr(&ct6, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                if (p_cmdargs->loadbalance__ttl_decr.is_valid)
+                {
+                    demo_ct6_ld_set_ttl_decr(&ct6, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                }
             }
             
             /* exec */
             if (FPP_ERR_OK == rtn)
             {
-                rtn = fci_ct6_update(cli_p_cl, &ct6);
+                rtn = demo_ct6_update(cli_p_cl, &ct6);
             }
         }
         else
         {
             fpp_ct_cmd_t ct = {0};
-            ct.protocol = (p_cmdargs->protocol.value);
-            ct.sport = (p_cmdargs->sport.value);
-            ct.sport = (p_cmdargs->dport.value);
-            ct.saddr = (p_cmdargs->sip.arr[0]);
-            ct.daddr = (p_cmdargs->dip.arr[0]);
+            
+            /* fill in the 5-tuple data */
+            demo_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
+            demo_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]), (p_cmdargs->dip.arr[0]),
+                                         (p_cmdargs->sport.value), (p_cmdargs->dport.value), 
+                                          0u, 0uL, false);
             
             /* get init local data */
-            rtn = fci_ct_get_by_tuple(cli_p_cl, &ct, &ct);
+            rtn = demo_ct_get_by_tuple(cli_p_cl, &ct, &ct);
             
             /* modify local data */
-            if ((CLI_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
+            if (CLI_OK == rtn)
             {
-                rtn = fci_ct_ld_set_ttl_decr(&ct, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                if (p_cmdargs->loadbalance__ttl_decr.is_valid)
+                {
+                    demo_ct_ld_set_ttl_decr(&ct, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                }
             }
             
             /* exec */
             if (FPP_ERR_OK == rtn)
             {
-                rtn = fci_ct_update(cli_p_cl, &ct);
+                rtn = demo_ct_update(cli_p_cl, &ct);
             }
         }
     }
@@ -538,7 +552,7 @@ int cli_cmd_cntk_add(const cli_cmdargs_t *p_cmdargs)
     }
     
     /* get init local data */
-    /* empty (no 'init data' from the PFE) */
+    /* empty (no 'init data' from PFE) */
     
     /* modify local data */
     if (FPP_ERR_OK == rtn)
@@ -559,39 +573,37 @@ int cli_cmd_cntk_add(const cli_cmdargs_t *p_cmdargs)
         {
             fpp_ct6_cmd_t ct6 = {0};
             
-            /* prepare data for IPv6 conntrack */
-            rtn = fci_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = fci_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
-                                                    (p_cmdargs->sport.value), (p_cmdargs->dport.value),
-                                                    (p_cmdargs->route.value), (p_cmdargs->vlan.value),
-                                                    (p_cmdargs->enable_noreply.is_valid));
-            }
-            if (FPP_ERR_OK == rtn)
+            /* prepare data for an IPv6 conntrack */
             {
-                rtn = fci_ct6_ld_set_reply_dir(&ct6, p_saddr_reply, p_daddr_reply,
-                                                     sport_reply, dport_reply,
-                                                     route_id_reply, vlan_reply,
-                                                    (p_cmdargs->disable_noorig.is_valid));
+                demo_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
+                
+                demo_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
+                                               (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                               (p_cmdargs->vlan.value), (p_cmdargs->route.value),
+                                               (p_cmdargs->enable_noreply.is_valid));
+                                               
+                demo_ct6_ld_set_reply_dir(&ct6, p_saddr_reply, p_daddr_reply,
+                                                sport_reply, dport_reply,
+                                                vlan_reply, route_id_reply,
+                                                (p_cmdargs->disable_noorig.is_valid));
             }
             
             /* exec - create IPv6 conntrack */
             if (FPP_ERR_OK == rtn)
             {
-                rtn = fci_ct6_add(cli_p_cl, &ct6);
+                rtn = demo_ct6_add(cli_p_cl, &ct6);
             }
             
-            /* WORKAROUND - ttl decrement is accessible only via update command */
+            /* WORKAROUND - ttl decrement is accessible only via the update command */
             if ((FPP_ERR_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
             {
                 /* modify local data */
-                rtn = fci_ct6_ld_set_ttl_decr(&ct6, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                demo_ct6_ld_set_ttl_decr(&ct6, (p_cmdargs->loadbalance__ttl_decr.is_on));
                 
                 /* exec */
                 if (FPP_ERR_OK == rtn)
                 {
-                    rtn = fci_ct6_update(cli_p_cl, &ct6);
+                    rtn = demo_ct6_update(cli_p_cl, &ct6);
                 }
             }
         }
@@ -599,39 +611,37 @@ int cli_cmd_cntk_add(const cli_cmdargs_t *p_cmdargs)
         {
             fpp_ct_cmd_t ct = {0};
                         
-            /* prepare data for IPv4 conntrack */
-            rtn = fci_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = fci_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]),  (p_cmdargs->dip.arr[0]),
-                                                  (p_cmdargs->sport.value), (p_cmdargs->dport.value),
-                                                  (p_cmdargs->route.value), (p_cmdargs->vlan.value),
-                                                  (p_cmdargs->enable_noreply.is_valid));
-            }
-            if (FPP_ERR_OK == rtn)
+            /* prepare data for an IPv4 conntrack */
             {
-                rtn = fci_ct_ld_set_reply_dir(&ct, p_saddr_reply[0], p_daddr_reply[0],
-                                                   sport_reply, dport_reply,
-                                                   route_id_reply, vlan_reply,
-                                                  (p_cmdargs->disable_noorig.is_valid));
+                demo_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
+                
+                demo_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]),  (p_cmdargs->dip.arr[0]),
+                                             (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                             (p_cmdargs->vlan.value),  (p_cmdargs->route.value), 
+                                             (p_cmdargs->enable_noreply.is_valid));
+            
+                demo_ct_ld_set_reply_dir(&ct, p_saddr_reply[0], p_daddr_reply[0],
+                                              sport_reply, dport_reply,
+                                              vlan_reply, route_id_reply, 
+                                              (p_cmdargs->disable_noorig.is_valid));
             }
             
             /* exec - create IPv4 conntrack */
             if (FPP_ERR_OK == rtn)
             {
-                rtn = fci_ct_add(cli_p_cl, &ct);
+                rtn = demo_ct_add(cli_p_cl, &ct);
             }
             
             /* WORKAROUND - ttl decrement is accessible only via update command */
             if ((FPP_ERR_OK == rtn) && (p_cmdargs->loadbalance__ttl_decr.is_valid))
             {
                 /* modify local data */
-                rtn = fci_ct_ld_set_ttl_decr(&ct, (p_cmdargs->loadbalance__ttl_decr.is_on));
+                demo_ct_ld_set_ttl_decr(&ct, (p_cmdargs->loadbalance__ttl_decr.is_on));
                 
                 /* exec */
                 if (FPP_ERR_OK == rtn)
                 {
-                    rtn = fci_ct_update(cli_p_cl, &ct);
+                    rtn = demo_ct_update(cli_p_cl, &ct);
                 }
             }
         }
@@ -672,38 +682,32 @@ int cli_cmd_cntk_del(const cli_cmdargs_t *p_cmdargs)
         {
             fpp_ct6_cmd_t ct6 = {0};
             
-            /* prepare data for IPv6 conntrack */
-            rtn = fci_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = fci_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
-                                                    (p_cmdargs->sport.value), (p_cmdargs->dport.value),
-                                                     0uL, 0u, false);
-            }
+            /* prepare data for IPv6 conntrack destruction */
+            demo_ct6_ld_set_protocol(&ct6, (p_cmdargs->protocol.value));
+            demo_ct6_ld_set_orig_dir(&ct6, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr),
+                                           (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                            0u, 0uL, false);
             
             /* exec - destroy IPv6 conntrack */
             if (FPP_ERR_OK == rtn)
             {
-                rtn = fci_ct6_del(cli_p_cl, &ct6);
+                rtn = demo_ct6_del(cli_p_cl, &ct6);
             }
         }
         else
         {
             fpp_ct_cmd_t ct = {0};
             
-            /* prepare data for IPv4 conntrack */
-            rtn = fci_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = fci_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]), (p_cmdargs->dip.arr[0]),
-                                                  (p_cmdargs->sport.value), (p_cmdargs->dport.value),
-                                                   0uL, 0u, false);
-            }
+            /* prepare data for IPv4 conntrack destruction */
+            demo_ct_ld_set_protocol(&ct, (p_cmdargs->protocol.value));
+            demo_ct_ld_set_orig_dir(&ct, (p_cmdargs->sip.arr[0]), (p_cmdargs->dip.arr[0]),
+                                         (p_cmdargs->sport.value), (p_cmdargs->dport.value),
+                                          0u, 0uL, false);
             
             /*  exec - destroy IPv4 conntrack  */
             if (FPP_ERR_OK == rtn)
             {
-                rtn = fci_ct_del(cli_p_cl, &ct);
+                rtn = demo_ct_del(cli_p_cl, &ct);
             }
         }
     }
@@ -730,18 +734,17 @@ int cli_cmd_cntk_timeout(const cli_cmdargs_t *p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        if (6u == (p_cmdargs->protocol.value))  /* 6u is protocol ID of TCP */
+        if (6u == (p_cmdargs->protocol.value))  /* 6u == TCP protocol ID */
         {
-            fci_ct_timeout_tcp(cli_p_cl, (p_cmdargs->timeout.value), (p_cmdargs->fallback_4o6.is_valid));
+            rtn = demo_ct_timeout_tcp(cli_p_cl, (p_cmdargs->timeout.value));
         }
-        else if (17u == (p_cmdargs->protocol.value))  /* 17u is protocol ID of UDP */
+        else if (17u == (p_cmdargs->protocol.value))  /* 17u == UDP protocol ID */
         {
-            const uint32_t timeout2 = ((p_cmdargs->timeout2.is_valid) ? (p_cmdargs->timeout2.value) : (0uL));
-            fci_ct_timeout_udp(cli_p_cl, (p_cmdargs->timeout.value), timeout2, (p_cmdargs->fallback_4o6.is_valid));
+            rtn = demo_ct_timeout_udp(cli_p_cl, (p_cmdargs->timeout.value));
         }
         else
         {
-            fci_ct_timeout_others(cli_p_cl, (p_cmdargs->timeout.value), (p_cmdargs->fallback_4o6.is_valid));
+            rtn = demo_ct_timeout_others(cli_p_cl, (p_cmdargs->timeout.value));
         }
     }
     
@@ -769,13 +772,13 @@ int cli_cmd_route_and_cntk_reset(const cli_cmdargs_t *p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        if ((p_cmdargs->ip4.is_valid) || (p_cmdargs->all.is_valid))
+        if ((FPP_ERR_OK == rtn) && ((p_cmdargs->ip4.is_valid) || (p_cmdargs->all.is_valid)))
         {
-            fci_rtct_reset_ip4(cli_p_cl);
+            rtn = demo_rtct_reset_ip4(cli_p_cl);
         }
-        if ((p_cmdargs->ip6.is_valid) || (p_cmdargs->all.is_valid))
+        if ((FPP_ERR_OK == rtn) && ((p_cmdargs->ip6.is_valid) || (p_cmdargs->all.is_valid)))
         {
-            fci_rtct_reset_ip6(cli_p_cl);
+            rtn = demo_rtct_reset_ip6(cli_p_cl);
         }
     }
     
diff --git a/sw/libfci_cli/src/libfci_cli_cmds_spd.c b/sw/libfci_cli/src/libfci_cli_cmds_spd.c
index 3e5eea8..2029eb8 100644
--- a/sw/libfci_cli/src/libfci_cli_cmds_spd.c
+++ b/sw/libfci_cli/src/libfci_cli_cmds_spd.c
@@ -33,13 +33,19 @@
 #include <stdbool.h>
 #include <stdio.h>
 #include <string.h>
+
 #include "libfci_cli_common.h"
 #include "libfci_cli_def_opts.h"
 #include "libfci_cli_print_helpers.h"
 #include "libfci_cli_def_optarg_keywords.h"
-#include "libfci_cli_cmds_spd.h"
+#include "libfci_cli_cmds_route_and_cntk.h"
 
-#include "libfci_interface/fci_spd.h"
+/*
+    NOTE:
+    The "demo_" functions are libFCI abstractions.
+    The "demo_" prefix was chosen because these functions are used as demos in FCI API Reference. 
+*/
+#include "libfci_demo/demo_spd.h"
 
 /* ==== TESTMODE vars ====================================================== */
 
@@ -58,92 +64,98 @@ static int spd_print(const fpp_spd_cmd_t* p_spd)
     assert(NULL != p_spd);
     
     
+    /* NOTE: native data type to comply with 'printf()' conventions (asterisk specifier) */ 
+    int indent = 0;
+    
     {
-        printf("[%5"PRIu16"]", (p_spd->position));
+        printf("%-*sentry %"PRIu16":\n", indent, "", demo_spd_ld_get_position(p_spd));
     }
+    
+    indent += 4;
+    
     {
-        unsigned int padding = 0u;
-        
-        const char* p_txt = cli_value2txt_spd_action(p_spd->spd_action);
-        padding += strlen(p_txt);
-        printf("  ;  [ %s", p_txt);
+        const uint8_t protocol = demo_spd_ld_get_protocol(p_spd);
+        printf("%-*sproto:  %"PRIu8" (%s)\n", indent, "",
+               protocol, cli_value2txt_protocol(protocol));
+    }
+    
+    {
+        const char* p_txt = cli_value2txt_spd_action(demo_spd_ld_get_action(p_spd));
+        printf("%-*saction: %s ", indent, "", p_txt);
         
-        switch (p_spd->spd_action)
+        /* extra info for some actions */
+        switch (demo_spd_ld_get_action(p_spd))
         {
             case FPP_SPD_ACTION_PROCESS_ENCODE:
-                p_txt = " sad=";
-                padding += strlen(p_txt) + 10u;  /* counting in fixed 10 characters of the associated numeric value */
-                printf("%s%-10"PRIu32, p_txt, (p_spd->sa_id));
+                printf("(sad=%"PRIu32")", demo_spd_ld_get_sa_id(p_spd));
             break;
             
             case FPP_SPD_ACTION_PROCESS_DECODE:
-                p_txt = " spi=0x";
-                padding += strlen(p_txt) + 8u;  /* counting in fixed 8 characters of the associated numeric value */
-                printf("%s%08"PRIx32, p_txt, (p_spd->spi));
+                printf("(spi=0x%08"PRIx32")", demo_spd_ld_get_spi(p_spd));
             break;
             
             default:
-                p_txt = NULL;
-                padding += 0uL;
+                /* empty */
             break;
         }
         
-        padding = ((21u >= padding) ? (21u - padding) : (0u));  /* 21 chars is maximal expected length of this section */
-        printf("%-*s ]", padding, "");
-    }
-    {
-        /* protocol */
-        const char* p_txt = cli_value2txt_protocol(p_spd->protocol);
-        printf("  ;  %-10s %3"PRIu16, p_txt, (p_spd->protocol));
+        printf("\n");
     }
+    
     {
-        /* IP */
-        uint32_t tmpbuf_ipaddr[4] = {0u};  /* use tmp buf to enforce correct alignment */
+        printf("%-*smatch:", indent, "");
         
-        printf("  ;  src=");
-        memcpy(tmpbuf_ipaddr, (p_spd->saddr), sizeof(uint32_t)*4);
-        if (fci_spd_ld_is_ip6(p_spd))
-        {
-            cli_print_ip6(tmpbuf_ipaddr);
-        }
-        else
         {
-            cli_print_ip4(tmpbuf_ipaddr[0], true);
+            const uint32_t* p_saddr = demo_spd_ld_get_saddr(p_spd);
+            printf("  src=");
+            if (demo_spd_ld_is_ip6(p_spd))
+            {
+                cli_print_ip6(p_saddr);
+            }
+            else
+            {
+                cli_print_ip4(p_saddr[0], true);
+            }
         }
         
-        printf("  dst=");
-        memcpy(tmpbuf_ipaddr, (p_spd->daddr), sizeof(uint32_t)*4);
-        if (fci_spd_ld_is_ip6(p_spd))
         {
-            cli_print_ip6(tmpbuf_ipaddr);
-        }
-        else
-        {
-            cli_print_ip4(tmpbuf_ipaddr[0], true);
-        }
-    }
-    {
-        /* port */
-        if (fci_spd_ld_is_used_sport(p_spd))
-        {
-            printf("  sport=%-5"PRIu16, (p_spd->sport));
-        }
-        else
-        {
-            printf("  sport= --- ");
+            const uint32_t* p_daddr = demo_spd_ld_get_daddr(p_spd);
+            printf("  dst=");
+            if (demo_spd_ld_is_ip6(p_spd))
+            {
+                cli_print_ip6(p_daddr);
+            }
+            else
+            {
+                cli_print_ip4(p_daddr[0], true);
+            }
         }
         
-        if (fci_spd_ld_is_used_dport(p_spd))
         {
-            printf("  dport=%-5"PRIu16, (p_spd->dport));
+            if (demo_spd_ld_is_used_sport(p_spd))
+            {
+                printf("  sport=%-5"PRIu16, demo_spd_ld_get_sport(p_spd));
+            }
+            else
+            {
+                printf("  sport=---  ");
+            }
         }
-        else
+        
         {
-            printf("  dport= --- ");
+            if (demo_spd_ld_is_used_dport(p_spd))
+            {
+                printf("  dport=%-5"PRIu16, demo_spd_ld_get_dport(p_spd));
+            }
+            else
+            {
+                printf("  dport=---   ");
+            }
         }
+        
+        printf("\n");
     }
     
-    printf("\n");
     return (FPP_ERR_OK); 
 }
 
@@ -166,7 +178,7 @@ int cli_cmd_spd_print(const cli_cmdargs_t *p_cmdargs)
     {
         const uint16_t pos = (p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (0u);
         const uint16_t cnt = (p_cmdargs->count_ethtype.is_valid) ? (p_cmdargs->count_ethtype.value) : (0u);
-        rtn = fci_spd_print_by_phyif(cli_p_cl, spd_print, (p_cmdargs->if_name.txt), pos, cnt);
+        rtn = demo_spd_print_by_phyif(cli_p_cl, spd_print, (p_cmdargs->if_name.txt), pos, cnt);
     }
     
     return (rtn);
@@ -206,31 +218,21 @@ int cli_cmd_spd_add(const cli_cmdargs_t *p_cmdargs)
     /* modify local data */
     if (FPP_ERR_OK == rtn)
     {
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_spd_ld_set_protocol(&spd, (p_cmdargs->protocol.value));
-        }
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_spd_ld_set_ip(&spd, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr), (p_cmdargs->sip.is6));
-        }
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_spd_ld_set_port(&spd, (p_cmdargs->sport.is_valid), (p_cmdargs->sport.value), 
-                                            (p_cmdargs->dport.is_valid), (p_cmdargs->dport.value));
-        }
-        if (FPP_ERR_OK == rtn)
-        {
-            rtn = fci_spd_ld_set_action(&spd, (p_cmdargs->spd_action.value), 
-                                              (p_cmdargs->data_hifc_sad.value), (p_cmdargs->mask_spi.value));
-        }
+        demo_spd_ld_set_protocol(&spd, (p_cmdargs->protocol.value));
+        demo_spd_ld_set_ip(&spd, (p_cmdargs->sip.arr), (p_cmdargs->dip.arr), (p_cmdargs->sip.is6));
+        
+        demo_spd_ld_set_port(&spd, (p_cmdargs->sport.is_valid), (p_cmdargs->sport.value), 
+                                   (p_cmdargs->dport.is_valid), (p_cmdargs->dport.value));
+        
+        demo_spd_ld_set_action(&spd, (p_cmdargs->spd_action.value), 
+                                     (p_cmdargs->data_hifc_sad.value), (p_cmdargs->mask_spi.value));
     }
     
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
         const uint16_t pos = ((p_cmdargs->offset.is_valid) ? (p_cmdargs->offset.value) : (UINT16_MAX));
-        rtn = fci_spd_add(cli_p_cl, (p_cmdargs->if_name.txt), pos, &spd);
+        rtn = demo_spd_add(cli_p_cl, (p_cmdargs->if_name.txt), pos, &spd);
     }
     
     return (rtn);
@@ -255,7 +257,7 @@ int cli_cmd_spd_del(const cli_cmdargs_t *p_cmdargs)
     /* exec */
     if (FPP_ERR_OK == rtn)
     {
-        rtn = fci_spd_del(cli_p_cl, (p_cmdargs->if_name.txt), (p_cmdargs->offset.value));
+        rtn = demo_spd_del(cli_p_cl, (p_cmdargs->if_name.txt), (p_cmdargs->offset.value));
     }
     
     return (rtn);
diff --git a/sw/libfci_cli/src/libfci_cli_common.h b/sw/libfci_cli/src/libfci_cli_common.h
index 1617061..5a48642 100644
--- a/sw/libfci_cli/src/libfci_cli_common.h
+++ b/sw/libfci_cli/src/libfci_cli_common.h
@@ -40,19 +40,24 @@
 
 #define NDEBUG
 
-/* app version (default values for non-makefile compilation) */
-#ifndef LIBFCI_CLI_TARGET_OS
-#define LIBFCI_CLI_TARGET_OS  "UNKNOWN_OS"
+
+/* app version */
+#define CLI_VERSION_MAJOR  "1"
+#define CLI_VERSION_MINOR  "1"
+#define CLI_VERSION_PATCH  "0"
+
+
+/* drv version (default values for non-makefile compilation) */
+#ifndef CLI_TARGET_OS
+#define CLI_TARGET_OS  "UNK"
 #endif
-#ifndef LIBFCI_CLI_VERSION
-#define LIBFCI_CLI_VERSION  "?.?.?"
+#ifndef CLI_DRV_VERSION
+#define CLI_DRV_VERSION  "?.?.?"
 #endif
 #ifndef PFE_CT_H_MD5
 #define PFE_CT_H_MD5  "????????????????????????????????"
 #endif
-#ifndef GLOBAL_VERSION_CONTROL_ID
-#define GLOBAL_VERSION_CONTROL_ID  "???????"
-#endif
+
 
 /* return codes */
 #define CLI_OK                     (FPP_ERR_OK)  /* Bound to LibFCI OK code for compatibility reasons */
@@ -66,6 +71,7 @@
 #define CLI_ERR_MISSING_MANDOPT    (-118)
 #define CLI_ERR_INCOMPATIBLE_IPS   (-119)
 #define CLI_ERR_WRONG_IP_TYPE      (-120)
+#define CLI_ERR_INV_DEMO_FEATURE   (-121)
 
 
 /* misc macros */
diff --git a/sw/libfci_cli/src/libfci_cli_def_cmds.h b/sw/libfci_cli/src/libfci_cli_def_cmds.h
index 80b3bca..07c1446 100644
--- a/sw/libfci_cli/src/libfci_cli_def_cmds.h
+++ b/sw/libfci_cli/src/libfci_cli_def_cmds.h
@@ -327,6 +327,15 @@
 /*      CMD_78_ENUM_NAME    reserved for future QOS cmds */
 /*      CMD_79_ENUM_NAME    reserved for future QOS cmds */
 
+#define CMD_80_ENUM_NAME    CMD_DEMO_FEATURE_PRINT
+#define CMD_80_CLI_TXT      "demo-feature-print"
+#define CMD_80_CMDEXEC      cli_cmd_demo_feature_print
+#define CMD_80_HELP         txt_help_demo_feature_print
+
+#define CMD_81_ENUM_NAME    CMD_DEMO_FEATURE_RUN
+#define CMD_81_CLI_TXT      "demo-feature-run"
+#define CMD_81_CMDEXEC      cli_cmd_demo_feature_run
+#define CMD_81_HELP         txt_help_demo_feature_run
 
 
 /* CMD_LAST (keep this at the bottom of the cli command definition list) */
diff --git a/sw/libfci_cli/src/libfci_cli_def_help.c b/sw/libfci_cli/src/libfci_cli_def_help.c
index 23dccb2..dc9c7f7 100644
--- a/sw/libfci_cli/src/libfci_cli_def_help.c
+++ b/sw/libfci_cli/src/libfci_cli_def_help.c
@@ -345,12 +345,7 @@
 
 #define TXT_OPT__TIMEOUT_CNTKTMO        TXT_HELP__TIMEOUT  "=<seconds>"
 #define TXT_OPTDESCR__TIMEOUT_CNTKTMO   TXT_HELP__TIMEOUT  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
-                                        "  For TCP and 'others': Timeout in seconds.\n"  \
-                                        "  For UDP:\n"                                   \
-                                        "    --> If ["  TXT_HELP__TIMEOUT2  "] is NOT utilized, then\n"  \
-                                        "        this value is applied on all kinds of UDP conntracks.\n"     \
-                                        "    --> If ["  TXT_HELP__TIMEOUT2  "] IS utilized, then \n"     \
-                                        "        this value is applied only on bidirectional UDP conntracks.\n"
+                                        "  Timeout in seconds.\n"
 
 #define TXT_OPT__TIMEOUT2_CNTKTMO       TXT_HELP__TIMEOUT2  "=<seconds>"
 #define TXT_OPTDESCR__TIMEOUT2_CNTKTMO  TXT_HELP__TIMEOUT2  "=<"  TXT_OPTARGS__U32_DEC  ">"  "\n"  \
@@ -586,6 +581,10 @@
 #define TXT_OPTDESCR__FEATURE_FW        TXT_HELP__FEATURE  "=<ingress_vlan>"  "\n"  \
                                         "  Name of a FW feature.\n"
 
+#define TXT_OPT__FEATURE_DEMO           TXT_HELP__FEATURE  "=<feature_name>"
+#define TXT_OPTDESCR__FEATURE_DEMO      TXT_HELP__FEATURE  "=<L2_bridge_simple>"  "\n"  \
+                                        "  Name of a demo scenario for a PFE feature.\n"
+
 #define TXT_OPT__STATIC                 TXT_HELP__STATIC
 #define TXT_OPTDESCR__STATIC            TXT_HELP__STATIC  "\n"  \
                                         "  Apply only on static entries.\n"
@@ -1513,17 +1512,13 @@ static const char* txt_help_cntk_timeout[] =
     ""    "cntk-timeout"             "   ",
     "<"   TXT_OPT__PROTOCOL_CNTKTMO  ">  ",
     "<"   TXT_OPT__TIMEOUT_CNTKTMO   ">  ",
-    "["   TXT_OPT__TIMEOUT2_CNTKTMO  "]  ",
-    "["   TXT_OPT__4o6               "]  ",
     "\n",
     TXT_DECOR_DESCR,
-    "Set timeout of IPv4 conntracks.",
+    "Set timeout of conntracks.",
     "\n",
     TXT_DECOR_OPT,
     TXT_OPTDESCR__PROTOCOL_CNTKTMO,
     TXT_OPTDESCR__TIMEOUT_CNTKTMO,
-    TXT_OPTDESCR__TIMEOUT2_CNTKTMO,
-    TXT_OPTDESCR__4o6,
     "\n",
     
     NULL
@@ -1814,6 +1809,37 @@ static const char* txt_help_qos_shp_update[] =
     NULL
 };
 
+static const char* txt_help_demo_feature_print[] =
+{
+    TXT_DECOR_CMD,
+    ""    "demo-feature-print"  "   ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Print all available demo scenarios for PFE feature configuration.",
+    "\n",
+    TXT_DECOR_OPT,
+    "no options\n",
+    "\n",
+    
+    NULL
+};
+
+static const char* txt_help_demo_feature_run[] =
+{
+    TXT_DECOR_CMD,
+    ""    "demo-feature-run"     "   ",
+    "<"   TXT_OPT__FEATURE_DEMO  ">  ",
+    "\n",
+    TXT_DECOR_DESCR,
+    ""    "Run the requested demo scenario. Demo scenarios show how to configure PFE features.",
+    "\n",
+    TXT_DECOR_OPT,
+    TXT_OPTDESCR__FEATURE_DEMO,
+    "\n",
+    
+    NULL
+};
+
 
 
 
diff --git a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
index 8486132..9e9b307 100644
--- a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
+++ b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.c
@@ -49,6 +49,7 @@
 /* indexed by elements of 'fpp_phy_if_op_mode_t' */
 static const char *const txt_if_modes[] = 
 {
+    TXT_IF_MODE__DISABLED,
     TXT_IF_MODE__DEFAULT,
     TXT_IF_MODE__BRIDGE,
     TXT_IF_MODE__ROUTER,
diff --git a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
index f712e89..4afb0d7 100644
--- a/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
+++ b/sw/libfci_cli/src/libfci_cli_def_optarg_keywords.h
@@ -40,6 +40,7 @@
 */
 
 /* indexed by elements of 'fpp_phy_if_op_mode_t' */
+#define TXT_IF_MODE__DISABLED          "DISABLED"
 #define TXT_IF_MODE__DEFAULT           "DEFAULT"
 #define TXT_IF_MODE__BRIDGE            "BRIDGE"
 #define TXT_IF_MODE__ROUTER            "ROUTER"
diff --git a/sw/libfci_cli/src/libfci_cli_parser.c b/sw/libfci_cli/src/libfci_cli_parser.c
index d53aeaa..b8c24cd 100644
--- a/sw/libfci_cli/src/libfci_cli_parser.c
+++ b/sw/libfci_cli/src/libfci_cli_parser.c
@@ -3654,6 +3654,11 @@ static int cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs)
                 do_mandopt_print = true;
             break;
             
+            case CLI_ERR_INCOMPATIBLE_IPS:
+                p_txt_err = "Incompatible IP addresses.\n"
+                            "All IP addresses must be of a same type - either all IPv4, or all IPv6.";
+            break;
+            
             case CLI_ERR_WRONG_IP_TYPE:
                 if (CMD_LOGIF_UPDATE == cmd)
                 {
@@ -3667,9 +3672,10 @@ static int cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs)
                 }
             break;
             
-            case CLI_ERR_INCOMPATIBLE_IPS:
-                p_txt_err = "Incompatible IP addresses.\n"
-                            "All IP addresses must be of a same type - either all IPv4, or all IPv6.";
+            case CLI_ERR_INV_DEMO_FEATURE:
+                p_txt_err = "Requested demo feature not found.\n"
+                            "Is the feature name correct?\n"
+                            "Does the feature exist?";
             break;
             
             /* errors of the libFCI library */
@@ -3765,9 +3771,10 @@ static int cmd_execute(cli_cmd_t cmd, const cli_cmdargs_t* p_cmdargs)
 
 void cli_print_app_version(void)
 {
-    printf("app version: "  LIBFCI_CLI_VERSION
-           " ("  PFE_CT_H_MD5  " ; "  GLOBAL_VERSION_CONTROL_ID  " ; "  __DATE__ " "  __TIME__  ")"
-           " ["  LIBFCI_CLI_TARGET_OS  "]\n");
+    /* the following printf() is a one long string, spanning over multiple lines */
+    printf("app version: "  CLI_VERSION_MAJOR  "."  CLI_VERSION_MINOR  "."  CLI_VERSION_PATCH
+           " ("  __DATE__  " "  __TIME__  ") "
+           " ("  CLI_TARGET_OS  " ; "  CLI_DRV_VERSION  " ; "  PFE_CT_H_MD5  ")\n");
 }
 
 /* NOTE: argument 'p_txt_vec' is expected to follow the argv convention (element [0] exists, but fnc ignores it) */
diff --git a/sw/libfci_cli/src/libfci_interface/fci_common.c b/sw/libfci_cli/src/libfci_demo/demo_common.c
similarity index 61%
rename from sw/libfci_cli/src/libfci_interface/fci_common.c
rename to sw/libfci_cli/src/libfci_demo/demo_common.c
index bc82a18..d30a73f 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_common.c
+++ b/sw/libfci_cli/src/libfci_demo/demo_common.c
@@ -30,24 +30,42 @@
  
  
 #include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
 #include <string.h>
-#include <stddef.h>
 #include <arpa/inet.h>
+#include <stdio.h>
+ 
+#include <stdint.h>
+#include <stddef.h>
 #include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
-#include "fci_common.h"
+ 
+#include "demo_common.h"
  
  
 /* ==== PUBLIC FUNCTIONS =================================================== */
  
  
+/*
+ * @brief      Check rtn value and print error text if (FPP_ERR_OK != rtn).
+ * @param[in]  rtn          Current return value of a caller function.
+ * @param[in]  p_txt_error  Text to be printed if (FPP_ERR_OK != rtn).
+ */
+void print_if_error(int rtn, const char* p_txt_error)
+{
+    assert(NULL != p_txt_error);
+    
+    if (FPP_ERR_OK != rtn)
+    {
+        printf("ERROR (%d): %s\n", rtn, p_txt_error);
+    }
+}
+ 
+ 
 /*
  * @brief          Network-to-host (ntoh) function for enum datatypes.
- * @param[in,out]  p_rtn  The value which is to be converted to the host byte order.
- * @param[in]      size   Size of the value datatype (in bytes).
+ * @param[in,out]  p_rtn  Value which is to be converted to a host byte order.
+ * @param[in]      size   Byte size of the value.
  */
 void ntoh_enum(void* p_rtn, size_t size)
 {
@@ -72,8 +90,8 @@ void ntoh_enum(void* p_rtn, size_t size)
  
 /*
  * @brief          Host-to-network (hton) function for enum datatypes.
- * @param[in,out]  p_rtn  The value which is to be converted to the network byte order.
- * @param[in]      size   Size of the value datatype (in bytes).
+ * @param[in,out]  p_rtn  Value which is to be converted to a network byte order.
+ * @param[in]      size   Byte size of the value.
  */
 void hton_enum(void* p_rtn, size_t size)
 {
@@ -97,7 +115,7 @@ void hton_enum(void* p_rtn, size_t size)
  
  
 /*
- * @brief       Check and set text
+ * @brief       Check and set text.
  * @param[out]  p_dst   Destination text array (to be modified).
  * @param[in]   p_src   Source text array.
  *                      Can be NULL or empty (""). If NULL or empty, then
@@ -106,14 +124,13 @@ void hton_enum(void* p_rtn, size_t size)
  * @return      FPP_ERR_OK : Function executed successfully.
  *              other      : Some error occured (represented by the respective error code).
  */
-int set_text(char* p_dst, const char* p_src, const uint_fast16_t dst_ln)
+int set_text(char* p_dst, const char* p_src, const uint16_t dst_ln)
 {
     assert(NULL != p_dst);
     assert(0u != dst_ln);
     /* 'p_src' is allowed to be NULL */
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     if ((NULL == p_src) || ('\0' == p_src[0]))
     {
@@ -123,7 +140,7 @@ int set_text(char* p_dst, const char* p_src, const uint_fast16_t dst_ln)
     }
     else if ((strlen(p_src) + 1u) > dst_ln)
     {
-        rtn = FPP_ERR_FCI_INVTXTLN;
+        rtn = FPP_ERR_INTERNAL_FAILURE;  /* src is too long */
     }
     else
     {
@@ -137,14 +154,13 @@ int set_text(char* p_dst, const char* p_src, const uint_fast16_t dst_ln)
  
  
 /*
- * @brief      Lock the interface database for exclusive access by this FCI client.
- * @details    The interface database is stored in the PFE.
- *             For details, see FCI API Reference, description of FPP_CMD_IF_LOCK_SESSION.
- * @param[in]  p_cl  FCI client instance
+ * @brief      Lock the interface database of PFE for exclusive access by this FCI client.
+ * @details    The interface database is stored in PFE.
+ * @param[in]  p_cl  FCI client
  * @return     FPP_ERR_OK : Lock successful
  *             other      : Lock not successful
  */
-int fci_if_session_lock(FCI_CLIENT* p_cl)
+int demo_if_session_lock(FCI_CLIENT* p_cl)
 {
     assert(NULL != p_cl);
     return fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0u, NULL);
@@ -152,26 +168,64 @@ int fci_if_session_lock(FCI_CLIENT* p_cl)
  
  
 /*
- * @brief      Unlock the interface database's exclusive access lock.
- * @param[in]  p_cl  FCI client instance
- * @param[in]  rtn   Caller's current return value
- * @return     If caller provides NON-ZERO rtn, then 
- *             this function returns the provided rtn value.
- *             If caller provides ZERO rtn, then return values are:
+ * @brief      Unlock exclusive access lock of the PFE's interface database.
+ * @details    The exclusive access lock can be unlocked only by a FCI client which 
+ *             currently holds exclusive access to the interface database.
+ * @param[in]  p_cl  FCI client
+ * @param[in]  rtn   Current return value of a caller function.
+ * @return     If a caller function provides NON-ZERO rtn, then that rtn value is returned.
+ *             If a caller function provides ZERO rtn, then return values are:
  *             FPP_ERR_OK : Unlock successful
  *             other      : Unlock not successful
  */
-int fci_if_session_unlock(FCI_CLIENT* p_cl, int rtn)
+int demo_if_session_unlock(FCI_CLIENT* p_cl, int rtn)
 {
     assert(NULL != p_cl);
     
-    
-    int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0u, NULL);    
+    int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0u, NULL);
     rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
     
     return (rtn);
 }
  
  
+/*
+ * @brief       Open connection to an FCI endpoint as a command-mode FCI client.
+ * @details     Command-mode client can configure PFE via the FCI endpoint by 
+ *              issuing FCI commands.
+ * @param[out]  pp_rtn_cl  Pointer to a newly created FCI client.
+ * @return      FPP_ERR_OK : New FCI client was successfully created.
+ *              other      : Failed to create a FCI client.
+ */
+int demo_client_open_in_cmd_mode(FCI_CLIENT** pp_rtn_cl)
+{  
+    assert(NULL != pp_rtn_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    FCI_CLIENT* p_cl = fci_open(FCI_CLIENT_DEFAULT, FCI_GROUP_NONE);
+    if (NULL != p_cl)
+    {
+        *pp_rtn_cl = p_cl;
+        rtn = FPP_ERR_OK;
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Close connection to a FCI endpoint and destroy the associated FCI client.
+ * @param[in]  p_cl  The FCI client to be destroyed.
+ * @return     FPP_ERR_OK : The FCI client was successfully destroyed.
+ *             other      : Failed to destroy the FCI client instance.
+ */
+int demo_client_close(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    return fci_close(p_cl);
+}
+ 
+ 
 /* ========================================================================= */
  
diff --git a/sw/libfci_cli/src/libfci_interface/fci_common.h b/sw/libfci_cli/src/libfci_demo/demo_common.h
similarity index 80%
rename from sw/libfci_cli/src/libfci_interface/fci_common.h
rename to sw/libfci_cli/src/libfci_demo/demo_common.h
index d34aff3..d3761e8 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_common.h
+++ b/sw/libfci_cli/src/libfci_demo/demo_common.h
@@ -27,30 +27,32 @@
  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * ========================================================================= */
-
-#ifndef FCI_COMMON_H_
-#define FCI_COMMON_H_
-
+ 
+#ifndef DEMO_COMMON_H_
+#define DEMO_COMMON_H_
+ 
 #include <stdint.h>
+#include <stddef.h>
+#include "fpp.h"
+#include "fpp_ext.h"
 #include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-/* return codes (extends libfci 'FPP_ERR_' return code family) */
-#define FPP_ERR_FCI           (-1101)
-#define FPP_ERR_FCI_INVPTR    (-1102)
-#define FPP_ERR_FCI_INVTXTLN  (-1103)
-
+ 
 /* ==== PUBLIC FUNCTIONS =================================================== */
-
+ 
+void print_if_error(int rtn, const char* p_txt_error);
+ 
 void ntoh_enum(void* p_rtn, size_t size);
 void hton_enum(void* p_rtn, size_t size);
-
-int set_text(char* p_dst, const char* p_src, const uint_fast16_t dst_ln);
-
-int fci_if_session_lock(FCI_CLIENT* p_cl);
-int fci_if_session_unlock(FCI_CLIENT* p_cl, int rtn);
-
+ 
+int set_text(char* p_dst, const char* p_src, const uint16_t dst_ln);
+ 
+int demo_if_session_lock(FCI_CLIENT* p_cl);
+int demo_if_session_unlock(FCI_CLIENT* p_cl, int rtn);
+ 
+int demo_client_open_in_cmd_mode(FCI_CLIENT** pp_rtn_cl);
+int demo_client_close(FCI_CLIENT* p_cl);
+ 
 /* ========================================================================= */
-
+ 
 #endif
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_simple.c b/sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_simple.c
new file mode 100644
index 0000000..10750b2
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_simple.c
@@ -0,0 +1,337 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_l2_bd.h"
+#include "demo_rt_ct.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as simple (non-VLAN aware) L2L3 bridge.
+ * @details    Scenario description:
+ *               [*] Let there be four computers (PCs):
+ *                     --> Two PCs (PC0_3 and PC0_7) are accessible via 
+ *                         PFE's emac0 physical interface.
+ *                     --> Two PCs (PC1_3 and PC1_11) are accessible via 
+ *                         PFE's emac1 physical interface.
+ *               [*] Use libFCI to configure PFE as simple (non-VLAN aware) L2L3 bridge,
+ *                   allowing communication between the PCs as follows:
+ *                     --> PC0_3 and PC1_3 are both in the same network subnet.
+ *                         PFE shall operate as a simple (non-VLAN aware) L2 bridge, allowing
+ *                         communication between these two PCs.
+ *                     --> PC0_7 and PC1_11 are in different network subnets. 
+ *                         PFE shall operate as a router, allowing ICMP (ping) communication 
+ *                         between these two PCs.
+ *             PFE emac description:
+ *               emac0:
+ *                 --> MAC address: 00:01:BE:BE:EF:11
+ *               emac1:
+ *                 --> MAC address: 00:01:BE:BE:EF:22
+ *             PC description:
+ *               PC0_3:
+ *                 --> IP  address: 10.3.0.2/24
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *               PC1_3:
+ *                 --> IP  address: 10.3.0.5/24
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *               PC0_7:
+ *                 --> IP  address: 10.7.0.2/24
+ *                 --> MAC address: 0A:01:23:45:67:89
+ *                     (this is just a demo MAC; real MAC of the real PC0 should be used)
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Configured to send 10.11.0.0 traffic to PFE's emac0.
+ *               PC1_11:
+ *                 --> IP  address: 10.11.0.5/24
+ *                 --> MAC address: 0A:FE:DC:BA:98:76
+ *                     (this is just a demo MAC; real MAC of the real PC1 should be used)
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Configured to send 10.7.0.0 traffic to PFE's emac1.
+ *             Additional info:
+ *               For simple (non-VLAN aware) bridge, the "default BD" (default bridge domain)
+ *               must always be used. This is hardcoded behavior of PFE.
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          L2L3 bridge should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_L2L3_bridge_simple(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /*
+        configure simple (non-VLAN aware) L2 bridge
+    */
+    
+    
+    /* clear L2 bridge MAC table (not required; done for demo purposes) */
+    /* ================================================================ */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_flush_all(p_cl);
+    }
+    
+    
+    /* configure the "default BD" */
+    /* ========================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_bd_cmd_t bd = {0};
+        
+        /* get data from PFE and store them in the local variable "bd" */
+        /* 1u == vlan ID of the "default BD" */
+        rtn = demo_l2_bd_get_by_vlan(p_cl, &bd, 1u);
+        if (FPP_ERR_OK == rtn)
+        {
+            /* modify locally stored data */
+            demo_l2_bd_ld_insert_phyif(&bd, 0u, false);  /* 0u == ID of emac0 */
+            demo_l2_bd_ld_insert_phyif(&bd, 1u, false);  /* 1u == ID of emac1 */
+            demo_l2_bd_ld_set_ucast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+            demo_l2_bd_ld_set_ucast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+            demo_l2_bd_ld_set_mcast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+            demo_l2_bd_ld_set_mcast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+        
+            /* update data in PFE */
+            rtn = demo_l2_bd_update(p_cl, &bd);
+        }
+    }
+    
+    
+    /* create special 'local' static MAC table entries (required for L2L3 bridge) */
+    /* ========================================================================== */
+    /* 'local' static MAC table entries are used to select the traffic which should be
+       classified by the Router. The rest of the traffic is classified by the L2 bridge.
+       For simple (non-VLAN aware) L2 bridge, 'local' static entries must be added to 
+       the default bridge domain (VLAN == 1) */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_static_ent_cmd_t stent = {0};
+        
+        /* if traffic destination MAC == MAC of emac0, then pass the traffic to the Router */
+        /* ------------------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 1u, 
+                                    (uint8_t[6]){0x00,0x01,0xBE,0xBE,0xEF,0x11});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                demo_l2_stent_ld_set_local(&stent, true);
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* if traffic destination MAC == MAC of emac1, then pass the traffic to the Router */
+        /* ------------------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 1u, 
+                                    (uint8_t[6]){0x00,0x01,0xBE,0xBE,0xEF,0x22});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                demo_l2_stent_ld_set_local(&stent, true);
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+    }
+    
+    
+    /*
+        configure router
+    */
+    
+    
+    /* clear all IPv4 routes and conntracks in PFE (not necessary, done for demo purposes) */
+    /* =================================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_rtct_reset_ip4(p_cl);
+    }
+    
+    
+    /* create routes */
+    /* ============= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_rt_cmd_t rt = {0};
+        
+        /* route 7 (route to PC0_7) */
+        /* ------------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0x01,0x23,0x45,0x67,0x89});
+            demo_rt_ld_set_egress_phyif(&rt, "emac0");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 7uL, &rt);
+        }
+        
+        /* route 11 (route to PC1_11) */
+        /* -------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0xFE,0xDC,0xBA,0x98,0x76});
+            demo_rt_ld_set_egress_phyif(&rt, "emac1");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 11uL, &rt);
+        }
+    }
+    
+    
+    /* set timeout for conntracks (not necessary; done for demo purposes) */
+    /* ================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        demo_ct_timeout_others(p_cl, 0xFFFFFFFFuL);  /* ping is ICMP, that is 'others' */
+    }
+    
+    
+    /* create conntracks */
+    /* ================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_ct_cmd_t ct = {0};
+        
+        /* conntrack from PC0_7 to PC1_11 (and back) */
+        /* ----------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            /*  This conntrack is configured as a bi-directional conntrack.
+                FCI command to create this conntrack results in two connections being 
+                created in PFE:
+                    --> one for the "orig" direction
+                    --> one for the "reply" direction
+            */
+            demo_ct_ld_set_protocol(&ct, 1u);  /* 1 == ICMP */
+            demo_ct_ld_set_orig_dir(&ct,  0x0A070002u,0x0A0B0005u,0u,0u, 0u,11uL, false);
+            demo_ct_ld_set_reply_dir(&ct, 0x0A0B0005u,0x0A070002u,0u,0u, 0u, 7uL, false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+    }
+    
+    
+    /*
+        configure physical interfaces
+    */
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_L2L3_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_NORMAL);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_L2L3_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_NORMAL);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_vlan.c b/sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_vlan.c
new file mode 100644
index 0000000..3b29ab5
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_L2L3_bridge_vlan.c
@@ -0,0 +1,505 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_l2_bd.h"
+#include "demo_rt_ct.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as VLAN-aware L2L3 bridge.
+ * @details    Scenario description:
+ *               [*] Let there be four computers (PCs):
+ *                     --> Two PCs (PC0_100 and PC0_200) are accessible via
+ *                         PFE's emac0 physical interface.
+ *                     --> Two PCs (PC1_100 and PC1_200) are accessible via
+ *                         PFE's emac1 physical interface.
+ *               [*] Use libFCI to configure PFE as VLAN-aware L2L3 bridge, allowing 
+ *                   communication between the PCs as follows:
+ *                     --> PC0_100 and PC1_100 are both in the VLAN domain 100.
+ *                         PFE shall operate as a VLAN-aware L2 bridge, allowing communication 
+ *                         between these two PCs.
+ *                     --> PC0_200 and PC1_200 are both in the VLAN domain 200.
+ *                         PFE shall operate as a VLAN-aware L2 bridge, allowing communication 
+ *                         between these two PCs.
+ *                     --> PC0_100 and PC1_200 are in different VLAN domains.
+ *                         PFE shall operate as a router, allowing ICMP (ping) and 
+ *                         TCP (port 4000) communication between these two PCs.
+ *               [*] Additional requirements:
+ *                     --> Dynamic learning of MAC addresses shall be disabled on 
+ *                         emac0 and emac1 interfaces.
+ *             PFE emac description:
+ *               emac0:
+ *                 --> MAC address: 00:01:BE:BE:EF:11
+ *               emac1:
+ *                 --> MAC address: 00:01:BE:BE:EF:22
+ *             PC description:
+ *               PC0_100:
+ *                 --> IP  address: 10.100.0.2/24
+ *                 --> MAC address: 02:11:22:33:44:55
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Configured to send 10.200.0.0 traffic to PFE's emac0.
+ *                 --> Belongs to VLAN 100 domain.
+ *               PC1_100:
+ *                 --> IP  address: 10.100.0.5/24
+ *                 --> MAC address: 02:66:77:88:99:AA
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Belongs to VLAN 100 domain.
+ *               PC0_200:
+ *                 --> IP  address: 10.200.0.2/24
+ *                 --> MAC address: 06:CC:BB:AA:99:88
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Belongs to VLAN 200 domain.
+ *               PC1_200:
+ *                 --> IP  address: 10.200.0.5/24
+ *                 --> MAC address: 06:77:66:55:44:33
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Configured to send 10.100.0.0 traffic to PFE's emac1.
+ *                 --> Belongs to VLAN 200 domain.
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          L2L3 bridge should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_L2L3_bridge_vlan(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /*
+        configure VLAN-aware L2 bridge
+    */
+    
+    
+    /* clear L2 bridge MAC table (not required; done for demo purposes) */
+    /* ================================================================ */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_flush_all(p_cl);
+    }
+    
+    
+    /* create and configure bridge domains */
+    /* =================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_bd_cmd_t bd = {0};
+        
+        /* bridge domain 100 */
+        /* ----------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new bridge domain in PFE */
+            rtn = demo_l2_bd_add(p_cl, &bd, 100u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new domain */
+                demo_l2_bd_ld_insert_phyif(&bd, 0u, true);  /* 0u == ID of emac0 */
+                demo_l2_bd_ld_insert_phyif(&bd, 1u, true);  /* 1u == ID of emac1 */
+                demo_l2_bd_ld_set_ucast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_ucast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                demo_l2_bd_ld_set_mcast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_mcast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                
+                /* update the new bridge domain in PFE */
+                rtn = demo_l2_bd_update(p_cl, &bd);
+            }
+        }
+        
+        /* bridge domain 200 */
+        /* ----------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new bridge domain in PFE */
+            rtn = demo_l2_bd_add(p_cl, &bd, 200u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new domain */
+                demo_l2_bd_ld_insert_phyif(&bd, 0u, true);  /* 0u == ID of emac0 */
+                demo_l2_bd_ld_insert_phyif(&bd, 1u, true);  /* 1u == ID of emac1 */
+                demo_l2_bd_ld_set_ucast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_ucast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                demo_l2_bd_ld_set_mcast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_mcast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                
+                /* update the new bridge domain in PFE */
+                rtn = demo_l2_bd_update(p_cl, &bd);
+            }
+        }
+    }
+    
+    
+    /* create and configure static MAC table entries */
+    /* ============================================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_static_ent_cmd_t stent = {0};
+        
+        /* static entry for bridge domain 100 (MAC of PC0_100) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 100u, 
+                                    (uint8_t[6]){0x02,0x11,0x22,0x33,0x44,0x55});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 0u == ID of emac0 */
+                demo_l2_stent_ld_set_fwlist(&stent, (1uL << 0u));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* static entry for bridge domain 100 (MAC of PC1_100) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 100u, 
+                                    (uint8_t[6]){0x02,0x66,0x77,0x88,0x99,0xAA});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 1u == ID of emac1 */
+                demo_l2_stent_ld_set_fwlist(&stent, (1uL << 1u));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* static entry for bridge domain 200 (MAC of PC0_200) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 200u, 
+                                    (uint8_t[6]){0x06,0xCC,0xBB,0xAA,0x99,0x88});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 0u == ID of emac0 */
+                demo_l2_stent_ld_set_fwlist(&stent, (1uL << 0u));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* static entry for bridge domain 200 (MAC of PC1_200) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 200u, 
+                                    (uint8_t[6]){0x06,0x77,0x66,0x55,0x44,0x33});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 1u == ID of emac1 */
+                demo_l2_stent_ld_set_fwlist(&stent, (1uL << 1u));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+    }
+    
+    
+    /* create special 'local' static MAC table entries (required for L2L3 bridge) */
+    /* ========================================================================== */
+    /* 'local' static MAC table entries are used to select the traffic which should be
+       classified by the Router. The rest of the traffic is classified by the L2 bridge. */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_static_ent_cmd_t stent = {0};
+        
+        /* [vlan 100] ; if traffic destination MAC == MAC of emac0, then pass it to Router */
+        /* ------------------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 100u, 
+                                    (uint8_t[6]){0x00,0x01,0xBE,0xBE,0xEF,0x11});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                demo_l2_stent_ld_set_local(&stent, true);
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* [vlan 100] ; if traffic destination MAC == MAC of emac1, then pass it to Router */
+        /* ------------------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 100u, 
+                                    (uint8_t[6]){0x00,0x01,0xBE,0xBE,0xEF,0x22});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                demo_l2_stent_ld_set_local(&stent, true);
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* [vlan 200] ; if traffic destination MAC == MAC of emac0, then pass it to Router */
+        /* ------------------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 200u, 
+                                    (uint8_t[6]){0x00,0x01,0xBE,0xBE,0xEF,0x11});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                demo_l2_stent_ld_set_local(&stent, true);
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* [vlan 200] ; if traffic destination MAC == MAC of emac1, then pass it to Router */
+        /* ------------------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 200u, 
+                                    (uint8_t[6]){0x00,0x01,0xBE,0xBE,0xEF,0x22});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                demo_l2_stent_ld_set_local(&stent, true);
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+    }
+    
+    
+    /*
+        configure router
+    */
+    
+    
+    /* clear all IPv4 routes and conntracks in PFE (not necessary, done for demo purposes) */
+    /* =================================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_rtct_reset_ip4(p_cl);
+    }
+    
+    
+    /* create routes */
+    /* ============= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_rt_cmd_t rt = {0};
+        
+        /* route 10 (route to PC0_100) */
+        /* --------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x02,0x11,0x22,0x33,0x44,0x55});
+            demo_rt_ld_set_egress_phyif(&rt, "emac0");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 10uL, &rt);
+        }
+        
+        /* route 20 (route to PC1_200) */
+        /* --------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x06,0x77,0x66,0x55,0x44,0x33});
+            demo_rt_ld_set_egress_phyif(&rt, "emac1");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 20uL, &rt);
+        }
+    }
+    
+    
+    /* set timeout for conntracks (not necessary; done for demo purposes) */
+    /* ================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        demo_ct_timeout_others(p_cl, 0xFFFFFFFFuL);  /* ping is ICMP, that is 'others' */
+        demo_ct_timeout_tcp(p_cl, 0xFFFFFFFFuL);  
+    }
+    
+    
+    /* create conntracks */
+    /* ================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_ct_cmd_t ct = {0};
+        
+        /* ICMP conntrack from PC0_100 to PC1_200 (and back) */
+        /* ------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            /*      This conntrack is configured as a bi-directional conntrack.
+                    One FCI command results in two connections being created in PFE -
+                    one for the "orig" direction and one for the "reply" direction. 
+                    This conntrack also modifies VLAN tag of the routed packet.
+            */
+            demo_ct_ld_set_protocol(&ct, 1u);  /* 1 == ICMP */
+            demo_ct_ld_set_orig_dir(&ct, 0x0A640002u,0x0AC80005u,0u,0u,200u,20uL,false);
+            demo_ct_ld_set_reply_dir(&ct,0x0AC80005u,0x0A640002u,0u,0u,100u,10uL,false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+        
+        /* TCP conntrack from PC0_100 to PC1_200 (and back) */
+        /* ------------------------------------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            /*      This conntrack is configured as a bi-directional conntrack.
+                    One FCI command results in two connections being created in PFE -
+                    one for the "orig" direction and one for the "reply" direction. 
+                    This conntrack also modifies VLAN tag of the routed packet.
+            */
+            demo_ct_ld_set_protocol(&ct, 6u);  /* 6 == TCP */
+            demo_ct_ld_set_orig_dir(&ct, 0x0A640002u,0x0AC80005u,4000u,4000u,200u,20uL,false);
+            demo_ct_ld_set_reply_dir(&ct,0x0AC80005u,0x0A640002u,4000u,4000u,100u,10uL,false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+    }
+    
+    
+    /*
+        configure physical interfaces
+    */
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_L2L3_VLAN_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_FORWARD_ONLY);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_L2L3_VLAN_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_FORWARD_ONLY);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_simple.c b/sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_simple.c
new file mode 100644
index 0000000..403fa16
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_simple.c
@@ -0,0 +1,170 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_l2_bd.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as a simple (non-VLAN aware) L2 bridge.
+ * @details    Scenario description:
+ *              [*] Let there be two computers (PCs).
+ *                  Both PCs are in the same network subnet.
+ *              [*] Use libFCI to configure PFE as a simple (non-VLAN aware) L2 bridge, 
+ *                  allowing the PCs to communicate with each other.
+ *             PC description:
+ *               PC0:
+ *                 --> IP address: 10.3.0.2/24
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *               PC1:
+ *                 --> IP address: 10.3.0.5/24
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *             Additional info:
+ *               For simple (non-VLAN aware) bridge, the "default BD" (default bridge domain)
+ *               must always be used. This is hardcoded behavior of PFE.
+ *               
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          Simple (non-VLAN aware) L2 bridge should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_L2_bridge_simple(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* clear L2 bridge MAC table (not required; done for demo purposes) */
+    /* ================================================================ */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_flush_all(p_cl);
+    }
+    
+    
+    /* configure the "default BD" */
+    /* ========================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_bd_cmd_t bd = {0};
+        
+        /* get data from PFE and store them in the local variable "bd" */
+        /* 1u == vlan ID of the "default BD" */
+        rtn = demo_l2_bd_get_by_vlan(p_cl, &bd, 1u);
+        if (FPP_ERR_OK == rtn)
+        {
+            /* modify locally stored data */
+            demo_l2_bd_ld_insert_phyif(&bd, 0u, false);  /* 0u == ID of emac0 */
+            demo_l2_bd_ld_insert_phyif(&bd, 1u, false);  /* 1u == ID of emac1 */
+            demo_l2_bd_ld_set_ucast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+            demo_l2_bd_ld_set_ucast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+            demo_l2_bd_ld_set_mcast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+            demo_l2_bd_ld_set_mcast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+        
+            /* update data in PFE */
+            rtn = demo_l2_bd_update(p_cl, &bd);
+        }
+    }
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_NORMAL);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_NORMAL);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_vlan.c b/sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_vlan.c
new file mode 100644
index 0000000..1181863
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_L2_bridge_vlan.c
@@ -0,0 +1,308 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_l2_bd.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as a VLAN-aware L2 bridge.
+ * @details    Scenario description:
+ *               [*] Let there be four computers (PCs):
+ *                     --> Two PCs (PC0_100 and PC0_200) are accessible via
+ *                         PFE's emac0 physical interface.
+ *                     --> Two PCs (PC1_100 and PC1_200) are accessible via
+ *                         PFE's emac1 physical interface.
+ *               [*] Use libFCI to configure PFE as a VLAN-aware L2 bridge, allowing the PCs 
+ *                   in respective VLAN domains to communicate with each other.
+ *                     --> PC0_100 and PC1_100 are both in the VLAN domain 100.
+ *                     --> PC0_200 and PC1_200 are both in the VLAN domain 200.
+ *               [*] Additional requirements:
+ *                     --> Dynamic learning of MAC addresses shall be disabled on 
+ *                         emac0 and emac1 interfaces.
+ *                     --> In VLAN 200 domain, a replica of all passing traffic shall be sent 
+ *                         to a host.
+ *             PC description:
+ *               PC0_100:
+ *                 --> IP  address: 10.100.0.2/24
+ *                 --> MAC address: 02:11:22:33:44:55
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Belongs to VLAN 100 domain.
+ *               PC1_100:
+ *                 --> IP  address: 10.100.0.5/24
+ *                 --> MAC address: 02:66:77:88:99:AA
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Belongs to VLAN 100 domain.
+ *               PC0_200:
+ *                 --> IP  address: 10.200.0.2/24
+ *                 --> MAC address: 06:CC:BB:AA:99:88
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Belongs to VLAN 200 domain.
+ *               PC1_200:
+ *                 --> IP  address: 10.200.0.5/24
+ *                 --> MAC address: 06:77:66:55:44:33
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Belongs to VLAN 200 domain.
+ *                 
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *             
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          VLAN-aware L2 bridge should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_L2_bridge_vlan(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* clear L2 bridge MAC table (not required; done for demo purposes) */
+    /* ================================================================ */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_flush_all(p_cl);
+    }
+    
+    
+    /* create and configure bridge domains */
+    /* =================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_bd_cmd_t bd = {0};
+        
+        /* bridge domain 100 */
+        /* ----------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new bridge domain in PFE */
+            rtn = demo_l2_bd_add(p_cl, &bd, 100u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new domain */
+                demo_l2_bd_ld_insert_phyif(&bd, 0u, true);  /* 0u == ID of emac0 */
+                demo_l2_bd_ld_insert_phyif(&bd, 1u, true);  /* 1u == ID of emac1 */
+                demo_l2_bd_ld_set_ucast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_ucast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                demo_l2_bd_ld_set_mcast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_mcast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                
+                /* update the new bridge domain in PFE */
+                rtn = demo_l2_bd_update(p_cl, &bd);
+            }
+        }
+        
+        /* bridge domain 200 */
+        /* ----------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new bridge domain in PFE */
+            rtn = demo_l2_bd_add(p_cl, &bd, 200u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new domain */
+                demo_l2_bd_ld_insert_phyif(&bd, 0u, true);  /* 0u == ID of emac0 */
+                demo_l2_bd_ld_insert_phyif(&bd, 1u, true);  /* 1u == ID of emac1 */
+                demo_l2_bd_ld_set_ucast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_ucast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                demo_l2_bd_ld_set_mcast_hit(&bd, 0u);   /* 0u == bridge action "FORWARD" */
+                demo_l2_bd_ld_set_mcast_miss(&bd, 1u);  /* 1u == bridge action "FLOOD" */
+                
+                /* update the new bridge domain in PFE */
+                rtn = demo_l2_bd_update(p_cl, &bd);
+            }
+        }
+    }
+    
+    
+    /* create and configure static MAC table entries */
+    /* ============================================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_l2_static_ent_cmd_t stent = {0};
+        
+        /* static entry for bridge domain 100 (MAC of PC0_100) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 100u, 
+                                    (uint8_t[6]){0x02,0x11,0x22,0x33,0x44,0x55});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 0u == ID of emac0 */
+                demo_l2_stent_ld_set_fwlist(&stent, (1uL << 0u));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* static entry for bridge domain 100 (MAC of PC1_100) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 100u, 
+                                    (uint8_t[6]){0x02,0x66,0x77,0x88,0x99,0xAA});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 1u == ID of emac1 */
+                demo_l2_stent_ld_set_fwlist(&stent, (1uL << 1u));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* static entry for bridge domain 200 (MAC of PC0_200) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 200u, 
+                                    (uint8_t[6]){0x06,0xCC,0xBB,0xAA,0x99,0x88});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 0u == ID of emac0 ; 7u == hif1 */
+                demo_l2_stent_ld_set_fwlist(&stent, ((1uL << 0u) | (1uL << 7u)));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+        
+        /* static entry for bridge domain 200 (MAC of PC1_200) */
+        /* --------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create a new static entry in PFE */
+            rtn = demo_l2_stent_add(p_cl, &stent, 200u, 
+                                    (uint8_t[6]){0x06,0x77,0x66,0x55,0x44,0x33});
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data of the new static entry */
+                /* 1u == ID of emac1 ; 7u == hif1 */
+                demo_l2_stent_ld_set_fwlist(&stent, ((1uL << 1u) | (1uL << 7u)));
+            
+                /* update the new static entry in PFE */
+                rtn = demo_l2_stent_update(p_cl, &stent);
+            }
+        }
+    }
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_VLAN_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_FORWARD_ONLY);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, true);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_VLAN_BRIDGE);
+                    demo_phy_if_ld_set_block_state(&phyif, BS_FORWARD_ONLY);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    /* clear dynamic (learned) entries from L2 bridge MAC table */
+    /* ========================================================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_flush_learned(p_cl);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_flexible_filter.c b/sw/libfci_cli/src/libfci_demo/demo_feature_flexible_filter.c
new file mode 100644
index 0000000..47c6659
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_flexible_filter.c
@@ -0,0 +1,313 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_fp.h"
+ 
+ 
+extern int demo_feature_L2_bridge_simple(FCI_CLIENT* p_cl);
+ 
+ 
+/*
+ * @brief      Use libFCI to configure a Flexible Filter in PFE.
+ * @details    Scenario description:
+ *               [*] Let there be two computers (PCs), both in the same network subnet.
+ *                   Both PCs are connected through PFE. PFE acts as a simple bridge.
+ *               [*] Use libFCI to configure a Flexible Filter on PFE's emac0 physical
+ *                   interface, allowing only a specific type of ingress traffic to pass
+ *                   for further classification. Non-compliant traffic is discarded.
+ *               [*] Criteria for the allowed ingress traffic on PFE's emac0:
+ *                     --> Type of the traffic is either ARP or ICMP.
+ *                     --> Source IP address is always the IP address of the PC0.
+ *                     --> Destination IP address is always the IP address of the PC1.
+ *             PC description:
+ *               PC0:
+ *                 --> IP address: 10.3.0.2/24
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Has static ARP entry for PC1.
+ *               PC1:
+ *                 --> IP address: 10.3.0.5/24
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Has static ARP entry for PC0.
+ *             Additional info:
+ *               Pseudocode of the comparison process done by this demo's FP table:
+ *               [0] r_arp_ethtype : (ethtype != ARP)  ? (GOTO r_icmp_ethtype) : (next_line)
+ *               [1] r_arp_sip     : (sip != 10.3.0.2) ? (REJECT)              : (next_line)
+ *               [2] r_arp_dip     : (dip == 10.3.0.5) ? (ACCEPT)              : (next_line)
+ *               [3] r_arp_discard : (true)            ? (REJECT)              : (REJECT)
+ *               [4] r_icmp_ethtype: (ethtype != IPv4) ? (REJECT)              : (next_line)
+ *               [5] r_icmp_proto  : (proto != ICMP)   ? (REJECT)              : (next_line)
+ *               [6] r_icmp_sip    : (sip != 10.3.0.2) ? (REJECT)              : (next_line)
+ *               [7] r_icmp_dip    : (sip == 10.3.0.5) ? (ACCEPT)              : (next_line)
+ *               [8] r_icmp_discard: (true)            ? (REJECT)              : (REJECT)
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          Flexible Parser table should be set in PFE.
+ *                          Flexible Filter on PFE's emac0 should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_flexible_filter(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* setup PFE to classify traffic (not needed by Flexible Filter, done for demo purposes)*/
+    /* ==================================================================================== */
+    rtn = demo_feature_L2_bridge_simple(p_cl);
+    
+    
+    /* create FP rules */
+    /* =============== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_fp_rule_cmd_t rule = {0};
+        
+        /* rule [0] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new rule */
+            demo_fp_rule_ld_set_data(&rule, 0x08060000);  /* 0x0806 == EtherType for ARP */
+            demo_fp_rule_ld_set_mask(&rule, 0xFFFF0000);
+            demo_fp_rule_ld_set_offset(&rule, 12u, FP_OFFSET_FROM_L2_HEADER);
+            demo_fp_rule_ld_set_invert(&rule, true);
+            demo_fp_rule_ld_set_match_action(&rule, FP_NEXT_RULE, "r_icmp_ethtype");
+            
+            /* create a new rule in PFE */
+            rtn = demo_fp_rule_add(p_cl, "r_arp_ethtype", &rule);
+        }
+        
+        /* rule [1] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x0A030002);  /* ARP protocol: sender IP */
+            demo_fp_rule_ld_set_mask(&rule, 0xFFFFFFFF);
+            demo_fp_rule_ld_set_offset(&rule, 28u, FP_OFFSET_FROM_L2_HEADER);
+            demo_fp_rule_ld_set_invert(&rule, true);
+            demo_fp_rule_ld_set_match_action(&rule, FP_REJECT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_arp_sip", &rule);
+        }
+        
+        /* rule [2] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x0A030005);  /* ARP protocol: target IP */
+            demo_fp_rule_ld_set_mask(&rule, 0xFFFFFFFF);
+            demo_fp_rule_ld_set_offset(&rule, 38u, FP_OFFSET_FROM_L2_HEADER);
+            demo_fp_rule_ld_set_invert(&rule, false);
+            demo_fp_rule_ld_set_match_action(&rule, FP_ACCEPT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_arp_dip", &rule);
+        }
+        
+        /* rule [3] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x00);
+            demo_fp_rule_ld_set_mask(&rule, 0x00);
+            demo_fp_rule_ld_set_offset(&rule, 0u, FP_OFFSET_FROM_L2_HEADER);
+            demo_fp_rule_ld_set_invert(&rule, false);
+            demo_fp_rule_ld_set_match_action(&rule, FP_REJECT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_arp_discard", &rule);
+        }
+        
+        /* rule [4] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x08000000);  /* 0x0800 == EtherType for IPv4 */
+            demo_fp_rule_ld_set_mask(&rule, 0xFFFF0000);
+            demo_fp_rule_ld_set_offset(&rule, 12u, FP_OFFSET_FROM_L2_HEADER);
+            demo_fp_rule_ld_set_invert(&rule, true);
+            demo_fp_rule_ld_set_match_action(&rule, FP_REJECT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_icmp_ethtype", &rule);
+        }
+        
+        /* rule [5] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x01000000);  /* 0x01 == ICMP protocol type */
+            demo_fp_rule_ld_set_mask(&rule, 0xFF000000);
+            demo_fp_rule_ld_set_offset(&rule, 9u, FP_OFFSET_FROM_L3_HEADER);  /* from L3 */
+            demo_fp_rule_ld_set_invert(&rule, true);
+            demo_fp_rule_ld_set_match_action(&rule, FP_REJECT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_icmp_proto", &rule);
+        }
+        
+        /* rule [6] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x0A030002);  /* IP protocol: source IP */
+            demo_fp_rule_ld_set_mask(&rule, 0xFFFFFFFF);
+            demo_fp_rule_ld_set_offset(&rule, 12u, FP_OFFSET_FROM_L3_HEADER);  /* from L3 */
+            demo_fp_rule_ld_set_invert(&rule, true);
+            demo_fp_rule_ld_set_match_action(&rule, FP_REJECT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_icmp_sip", &rule);
+        }
+        
+        /* rule [7] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x0A030005);  /* IP protocol: destination IP */
+            demo_fp_rule_ld_set_mask(&rule, 0xFFFFFFFF);
+            demo_fp_rule_ld_set_offset(&rule, 16u, FP_OFFSET_FROM_L3_HEADER);  /* from L3 */
+            demo_fp_rule_ld_set_invert(&rule, false);
+            demo_fp_rule_ld_set_match_action(&rule, FP_ACCEPT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_icmp_dip", &rule);
+        }
+        
+        /* rule [8] */
+        /* -------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            demo_fp_rule_ld_set_data(&rule, 0x00);
+            demo_fp_rule_ld_set_mask(&rule, 0x00);
+            demo_fp_rule_ld_set_offset(&rule, 0u, FP_OFFSET_FROM_L3_HEADER);
+            demo_fp_rule_ld_set_invert(&rule, false);
+            demo_fp_rule_ld_set_match_action(&rule, FP_REJECT, NULL);
+            
+            rtn = demo_fp_rule_add(p_cl, "r_icmp_discard", &rule);
+        }
+    }
+    
+    
+    /* create (and fill) FP table */
+    /* ========================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* create FP table */
+        /* --------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_add(p_cl, "my_filter_table");
+        }
+        
+        /* fill the table with rules */
+        /* ------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_arp_ethtype",  0u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_arp_sip", 1u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_arp_dip", 2u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_arp_discard", 3u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_icmp_ethtype", 4u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_icmp_proto", 5u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_icmp_sip", 6u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_icmp_dip", 7u);
+        }
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_fp_table_insert_rule(p_cl, "my_filter_table", "r_icmp_discard", 8u);
+        }
+    }
+    
+    
+    /* assign the created FP table as a Flexible Filter for emac0 */
+    /* ========================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* get data from PFE and store them in the local variable "phyif" */
+            rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_phy_if_ld_set_flexifilter(&phyif, "my_filter_table");
+            
+                /* update data in PFE */
+                rtn = demo_phy_if_update(p_cl, &phyif);
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_flexible_router.c b/sw/libfci_cli/src/libfci_demo/demo_feature_flexible_router.c
new file mode 100644
index 0000000..db8ec7f
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_flexible_router.c
@@ -0,0 +1,283 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_log_if.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as a Flexible Router.
+ * @details    Scenario description:
+ *               [*] Let there be two computers (PCs).
+ *                   Each PC is in a different network subnet.
+ *               [*] Use libFCI to configure PFE as a Flexible Router, allowing the PCs 
+ *                   to communicate with each other.
+ *               [*] Only a specific traffic is allowed through PFE (the rest is discarded).
+ *                   Criteria for the allowed traffic:
+ *                     --> Only ARP and ICMP traffic is allowed through PFE.
+ *                     --> No further limitations for ARP traffic.
+ *                     --> For ICMP traffic, only IPs of PC0 and PC1 are allowed 
+ *                         to communicate with each other. ICMP traffic from 
+ *                         any other IP must be blocked.
+ *                     --> EXTRA: All traffic which passes through PFE must also be mirrored
+ *                                to the emac2 physical interface.
+ *               [*] NOTE:
+ *                   Flexible Router is best used for special, non-standard requirements.
+ *                   Scanning of traffic data and chaining of logical interfaces presents 
+ *                   an additional overhead.
+ *                   PFE features such as L2 bridge or L3 router offer a better performance
+ *                   and are recommended over the Flexible Router in all cases where
+ *                   they can be used to satisfy the given requirements.
+ *             PC description:
+ *               PC0:
+ *                 --> IP address: 10.7.0.2/24
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Configured to send 10.11.0.0 traffic to PFE's emac0.
+ *               PC1:
+ *                 --> IP address: 10.11.0.5/24
+ *                 --> Accessible via PFE's emac1 physical interface.
+  *                 --> Configured to send 10.7.0.0 traffic to PFE's emac1.
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          Flexible Router should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_flexible_router(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* lock the interface database of PFE */
+    rtn = demo_if_session_lock(p_cl);
+    
+    
+    /* create and configure logical interfaces on emac0 */
+    /* ================================================ */
+    /* NOTE: creation order of logical interfaces is IMPORTANT */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_log_if_cmd_t logif = {0};
+        
+        /* create a "sinkhole" logical interface for unsuitable ingress traffic */
+        /* -------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create new logical interface in PFE and store a copy of its data in "logif" */
+            rtn = demo_log_if_add(p_cl, &logif, "MyLogif0_sink", "emac0");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_log_if_ld_set_promisc(&logif, true);  /* promisc == accept everything */
+                demo_log_if_ld_set_discard_on_m(&logif, true);
+                demo_log_if_ld_enable(&logif);
+                
+                /* update data in PFE */
+                rtn = demo_log_if_update(p_cl, &logif);
+            }
+        }
+        
+        /* create and configure a logical interface for ARP ingress traffic */
+        /* ---------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_log_if_add(p_cl, &logif, "MyLogif0_arp", "emac0");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* NOTE: 1u == ID of emac1 ; 2u == ID of emac2 */
+                demo_log_if_ld_set_promisc(&logif, false);
+                demo_log_if_ld_set_egress_phyifs(&logif, ((1uL << 1u) | (1uL << 2u)));
+                demo_log_if_ld_set_match_mode_or(&logif, false);
+                demo_log_if_ld_clear_all_mr(&logif);
+                demo_log_if_ld_set_mr_type_arp(&logif, true);
+                demo_log_if_ld_enable(&logif);
+            
+                rtn = demo_log_if_update(p_cl, &logif);
+            }
+        }
+        
+        /* create and configure a logical interface for ICMP ingress traffic */
+        /* ----------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_log_if_add(p_cl, &logif, "MyLogif0_icmp", "emac0");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* NOTE: 1u == ID of emac1 ; 2u == ID of emac2 */
+                demo_log_if_ld_set_promisc(&logif, false);
+                demo_log_if_ld_set_egress_phyifs(&logif, ((1uL << 1u) | (1uL << 2u)));
+                demo_log_if_ld_set_match_mode_or(&logif, false);
+                demo_log_if_ld_clear_all_mr(&logif);
+                demo_log_if_ld_set_mr_type_icmp(&logif, true);
+                demo_log_if_ld_set_mr_sip(&logif, true, 0x0A070002);
+                demo_log_if_ld_set_mr_dip(&logif, true, 0x0A0B0005);
+                demo_log_if_ld_enable(&logif);
+                
+                rtn = demo_log_if_update(p_cl, &logif);
+            }
+        }
+    }
+    
+    
+    /* create and configure logical interfaces on emac1 */
+    /* ================================================ */
+    /* NOTE: creation order of logical interfaces is IMPORTANT */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_log_if_cmd_t logif = {0};
+        
+        /* create a "sinkhole" logical interface for unsuitable ingress traffic */
+        /* -------------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* create new logical interface in PFE and store a copy of its data in "logif" */
+            rtn = demo_log_if_add(p_cl, &logif, "MyLogif1_sink", "emac1");
+            if (FPP_ERR_OK == rtn)
+            {
+                demo_log_if_ld_set_promisc(&logif, true);  /* promisc == accept everything */
+                demo_log_if_ld_set_discard_on_m(&logif, true);
+                demo_log_if_ld_enable(&logif);
+            
+                rtn = demo_log_if_update(p_cl, &logif);
+            }
+        }
+        
+        
+        /* create and configure a logical interface for ARP ingress traffic */
+        /* ---------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_log_if_add(p_cl, &logif, "MyLogif1_arp", "emac1");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* NOTE: 0u == ID of emac0 ; 2u == ID of emac2 */
+                demo_log_if_ld_set_promisc(&logif, false);
+                demo_log_if_ld_set_egress_phyifs(&logif, ((1uL << 0u) | (1uL << 2u)));
+                demo_log_if_ld_set_match_mode_or(&logif, false);
+                demo_log_if_ld_clear_all_mr(&logif);
+                demo_log_if_ld_set_mr_type_arp(&logif, true);
+                demo_log_if_ld_enable(&logif);
+                
+                rtn = demo_log_if_update(p_cl, &logif);
+            }
+        }
+        
+        /* create and configure a logical interface for ICMP ingress traffic */
+        /* ----------------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            rtn = demo_log_if_add(p_cl, &logif, "MyLogif1_icmp", "emac1");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* NOTE: 0u == ID of emac0 ; 2u == ID of emac2 */
+                demo_log_if_ld_set_promisc(&logif, false);
+                demo_log_if_ld_set_egress_phyifs(&logif, ((1uL << 0u) | (1uL << 2u)));
+                demo_log_if_ld_set_match_mode_or(&logif, false);
+                demo_log_if_ld_clear_all_mr(&logif);
+                demo_log_if_ld_set_mr_type_icmp(&logif, true);
+                demo_log_if_ld_set_mr_sip(&logif, true, 0x0A0B0005);
+                demo_log_if_ld_set_mr_dip(&logif, true, 0x0A070002);
+                demo_log_if_ld_enable(&logif);
+                
+                rtn = demo_log_if_update(p_cl, &logif);
+            }
+        }
+    }
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_phy_if_cmd_t phyif = {0};
+        
+        /* configure physical interface "emac0" */
+        /* -----------------------------------  */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "phyif" */
+            rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_phy_if_ld_enable(&phyif);
+                demo_phy_if_ld_set_promisc(&phyif, true);
+                demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_FLEXIBLE_ROUTER);
+                
+                /* update data in PFE */
+                rtn = demo_phy_if_update(p_cl, &phyif);
+            }
+        }
+        
+        /* configure physical interface "emac1" */
+        /* -----------------------------------  */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "phyif" */
+            rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_phy_if_ld_enable(&phyif);
+                demo_phy_if_ld_set_promisc(&phyif, true);
+                demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_FLEXIBLE_ROUTER);
+                
+                /* update data in PFE */
+                rtn = demo_phy_if_update(p_cl, &phyif);
+            }
+        }
+    }
+    
+    
+    /* unlock the interface database of PFE */
+    rtn = demo_if_session_unlock(p_cl, rtn);
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_qos.c b/sw/libfci_cli/src/libfci_demo/demo_feature_qos.c
new file mode 100644
index 0000000..ad0f096
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_qos.c
@@ -0,0 +1,382 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_qos.h"
+ 
+ 
+extern int demo_feature_L2_bridge_simple(FCI_CLIENT* p_cl);
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE egress QoS feature.
+ * @details    Scenario description:
+ *               [*] Let there be two computers (PCs), both in the same network subnet.
+ *                   Both PCs are connected through PFE. PFE acts as a simple bridge.
+ *               [*] Use libFCI to configure PFE egress QoS feature on PFE's emac0 physical
+ *                   interface, to prioritize and shape egress communication on emac0.
+ *             PC description:
+ *               PC0:
+ *                 --> IP address: 10.3.0.2/24
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *               PC1:
+ *                 --> IP address: 10.3.0.5/24
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *             Additional info:
+ *               QoS topology of this example:
+ * @verbatim
+                           SCH0
+                           (WRR)
+                        +--------+               SCH1
+                  Q0--->| 0      |               (PQ)
+                  Q1--->| 1      |            +--------+
+                        | ...    +--->SHP0--->| 0      |
+                        | 6      |            | 1      |
+                        | 7      |            | ...    |
+                        +--------+            | 4      +--->SHP2--->
+                                              | 5      |
+                                 Q6---SHP1--->| 6      |
+                                 Q7---------->| 7      |
+                                              +--------+
+   @endverbatim
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          Egress QoS should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_qos(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* setup PFE to classify traffic (not needed by Egress QoS, done for demo purposes)*/
+    /* =============================================================================== */
+    rtn = demo_feature_L2_bridge_simple(p_cl);
+    
+    
+    /* configure Egress QoS queues for emac0 */
+    /* ===================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_qos_queue_cmd_t que = {0};
+        
+        /* queue 0 */
+        /* ------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 0u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 3u);  /* 3 == WRED */
+                demo_qos_que_ld_set_min(&que, 100u);
+                demo_qos_que_ld_set_max(&que, 200u);
+                demo_qos_que_ld_set_zprob(&que, 0u, 10u);
+                demo_qos_que_ld_set_zprob(&que, 1u, 20u);
+                demo_qos_que_ld_set_zprob(&que, 2u, 30u);
+                demo_qos_que_ld_set_zprob(&que, 3u, 40u);
+                demo_qos_que_ld_set_zprob(&que, 4u, 50u);
+                demo_qos_que_ld_set_zprob(&que, 5u, 60u);
+                demo_qos_que_ld_set_zprob(&que, 6u, 70u);
+                demo_qos_que_ld_set_zprob(&que, 7u, 80u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* queue 1 */
+        /* ------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 1u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 2u);  /* 2 == TAIL DROP */
+                demo_qos_que_ld_set_max(&que, 125u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* queue 6 */
+        /* ------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 6u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 3u);  /* 3 == WRED */
+                demo_qos_que_ld_set_min(&que, 100u);
+                demo_qos_que_ld_set_max(&que, 200u);
+                demo_qos_que_ld_set_zprob(&que, 0u, 20u);
+                demo_qos_que_ld_set_zprob(&que, 1u, 20u);
+                demo_qos_que_ld_set_zprob(&que, 2u, 40u);
+                demo_qos_que_ld_set_zprob(&que, 3u, 40u);
+                demo_qos_que_ld_set_zprob(&que, 4u, 60u);
+                demo_qos_que_ld_set_zprob(&que, 5u, 60u);
+                demo_qos_que_ld_set_zprob(&que, 6u, 80u);
+                demo_qos_que_ld_set_zprob(&que, 7u, 80u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* queue 7 */
+        /* ------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 7u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 2u);  /* 2 == TAIL DROP */
+                demo_qos_que_ld_set_max(&que, 150u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* rest of the queues are unused (disabled) */
+        
+        /* queue 2 (disabled) */
+        /* ------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 2u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 0u);  /* 0 == DISABLED */
+                demo_qos_que_ld_set_max(&que, 0u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* queue 3 (disabled) */
+        /* ------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 3u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 0u);  /* 0 == DISABLED */
+                demo_qos_que_ld_set_max(&que, 0u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* queue 4 (disabled) */
+        /* ------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 4u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 0u);  /* 0 == DISABLED */
+                demo_qos_que_ld_set_max(&que, 0u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+        
+        /* queue 5 (disabled) */
+        /* ------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "que" */
+            rtn = demo_qos_que_get_by_id(p_cl, &que, "emac0", 5u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_que_ld_set_mode(&que, 0u);  /* 0 == DISABLED */
+                demo_qos_que_ld_set_max(&que, 0u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_que_update(p_cl, &que);
+            }
+        }
+    }
+    
+    
+    /* configure Egress QoS schedulers for emac0 */
+    /* ========================================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_qos_scheduler_cmd_t sch = {0};
+        
+        /* scheduler 0 */
+        /* ----------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "sch" */
+            rtn = demo_qos_sch_get_by_id(p_cl, &sch, "emac0", 0u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_sch_ld_set_mode(&sch, 2u);  /* 2 == packet rate */
+                demo_qos_sch_ld_set_algo(&sch, 3u);  /* 3 == WRR */
+                demo_qos_sch_ld_set_input(&sch, 0u, true,    0u, 10000u);
+                demo_qos_sch_ld_set_input(&sch, 1u, true,    1u, 20000u);
+                demo_qos_sch_ld_set_input(&sch, 2u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 3u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 4u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 5u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 6u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 7u, false, 255u, 0u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_sch_update(p_cl, &sch);
+            }
+        }
+        
+        /* scheduler 1 */
+        /* ----------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* get data from PFE and store them in the local variable "sch" */
+            rtn = demo_qos_sch_get_by_id(p_cl, &sch, "emac0", 1u);
+            if (FPP_ERR_OK == rtn)
+            {
+                /* modify locally stored data */
+                demo_qos_sch_ld_set_mode(&sch, 1u);  /* 1 == data rate */
+                demo_qos_sch_ld_set_algo(&sch, 0u);  /* 0 == PQ */
+                demo_qos_sch_ld_set_input(&sch, 0u, true,    8u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 1u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 2u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 3u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 4u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 5u, false, 255u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 6u, true,    6u, 0u);
+                demo_qos_sch_ld_set_input(&sch, 7u, true,    7u, 0u);
+                
+                /* update data in PFE */
+                rtn = demo_qos_sch_update(p_cl, &sch);
+            }
+        }
+    }
+    
+    
+    /* configure Egress QoS shapers for emac0 */
+    /* ====================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_qos_shaper_cmd_t shp = {0};
+        
+        /* shaper 0 */
+        /* -------- */
+        rtn = demo_qos_shp_get_by_id(p_cl, &shp, "emac0", 0u);
+        if (FPP_ERR_OK == rtn)
+        {
+            /* modify locally stored data */
+            demo_qos_shp_ld_set_mode(&shp, 2u);     /* 2 == packet rate */
+            demo_qos_shp_ld_set_position(&shp, 1u); /* 1 == input #0 of scheduler 1 */
+            demo_qos_shp_ld_set_isl(&shp, 1000u);   /* packets per sec */
+            demo_qos_shp_ld_set_min_credit(&shp, -5000);
+            demo_qos_shp_ld_set_max_credit(&shp, 10000);
+            
+            /* update data in PFE */
+            rtn = demo_qos_shp_update(p_cl, &shp);
+        }
+        
+        /* shaper 1 */
+        /* -------- */
+        rtn = demo_qos_shp_get_by_id(p_cl, &shp, "emac0", 1u);
+        if (FPP_ERR_OK == rtn)
+        {
+            /* modify locally stored data */
+            demo_qos_shp_ld_set_mode(&shp, 2u);     /* 2 == packet rate */
+            demo_qos_shp_ld_set_position(&shp, 7u); /* 7 == input #6 of scheduler 1 */
+            demo_qos_shp_ld_set_isl(&shp, 2000u);   /* packets per sec */
+            demo_qos_shp_ld_set_min_credit(&shp, -4000);
+            demo_qos_shp_ld_set_max_credit(&shp,  8000);
+            
+            /* update data in PFE */
+            rtn = demo_qos_shp_update(p_cl, &shp);
+        }
+        
+        /* shaper 2 */
+        /* -------- */
+        rtn = demo_qos_shp_get_by_id(p_cl, &shp, "emac0", 2u);
+        if (FPP_ERR_OK == rtn)
+        {
+            /* modify locally stored data */
+            demo_qos_shp_ld_set_mode(&shp, 1u);      /* 1 == data rate */
+            demo_qos_shp_ld_set_position(&shp, 0u);  /* 0 == output of scheduler 1 */
+            demo_qos_shp_ld_set_isl(&shp, 30000u);    /* bits per sec */
+            demo_qos_shp_ld_set_min_credit(&shp, -60000);
+            demo_qos_shp_ld_set_max_credit(&shp,  90000);
+            
+            /* update data in PFE */
+            rtn = demo_qos_shp_update(p_cl, &shp);
+        }
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_router_nat.c b/sw/libfci_cli/src/libfci_demo/demo_feature_router_nat.c
new file mode 100644
index 0000000..25a255e
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_router_nat.c
@@ -0,0 +1,309 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_rt_ct.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as a router (with one-to-many NAT).
+ * @details    Scenario description:
+ *               [*] Let there be three computers (PCs):
+ *                     --> PC0_20, which acts as a server
+ *                     --> PC1_2, which acts as a client
+ *                     --> PC1_5, which acts as a client
+ *               [*] Use libFCI to configure PFE as a router (with one-to-many NAT), allowing 
+ *                   TCP communication between the server PC and client PCs.
+ *               [*] Client PCs can communicate with the server PC via TCP port 4000.
+ *                   This scenario requires both source and destination port to be 4000.
+ *                   (no use of ephemeral ports)
+ *               [*] PC0_20 (server) has a public IP address (200.201.202.20/16).
+ *               [*] PC1_2 and PC1_5 (clients) have private IP addresses from 10.x.x.x range.
+ *                   They both share one public IP address (100.101.102.10/16) to communicate
+ *                   with the outside world (NAT+PAT "one-to-many" mapping).
+ *             PC description:
+ *               PC0_20 (server):
+ *                 --> IP address:  200.201.202.20/16
+ *                 --> MAC address: 0A:BB:CC:DD:EE:FF  
+ *                     (this is just a demo MAC; real MAC of the real PC0 should be used)
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Configured to send 100.101.0.0 traffic to PFE's emac0.
+ *                 --> Listens on TCP port 4000.
+ *               PC1_2 (client_2):
+ *                 --> IP address:  10.11.0.2/24
+ *                 --> MAC address: 0A:11:33:55:77:99
+ *                     (this is just a demo MAC; real MAC of the real PC1_2 should be used)
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Configured to send 200.201.0.0 traffic to PFE's emac1.
+ *                 --> Hidden behind NAT.
+ *               PC1_5 (client_5):
+ *                 --> IP address: 10.11.0.5/24
+ *                 --> MAC address: 0A:22:44:66:88:AA
+ *                     (this is just a demo MAC; real MAC of the real PC1_5 should be used)
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Configured to send 200.201.0.0 traffic to PFE's emac1.
+ *                 --> Hidden behind NAT.
+ *             Additional info:
+ *               [+] Conntrack struct has data members for an "orig" direction and for
+ *                   a "reply" direction. See FPP_CMD_IPV4_CONNTRACK.
+ *                   The "reply" direction data can be used for two purposes:
+ *                     - To automatically create a reply direction conntrack together with
+ *                       the orig direction conntrack in one FCI command.
+ *                     - To modify parts of the "orig" direction packet (IPs/ports), 
+ *                       effectively creating NAT/PAT behavior.
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          Router should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_router_nat(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* clear all IPv4 routes and conntracks in PFE (not necessary, done for demo purposes) */
+    /* =================================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_rtct_reset_ip4(p_cl);
+    }
+    
+    
+    /* create routes */
+    /* ============= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_rt_cmd_t rt = {0};
+        
+        /* route 20 (route to PC0_20) */
+        /* -------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0xBB,0xCC,0xDD,0xEE,0xFF});
+            demo_rt_ld_set_egress_phyif(&rt, "emac0");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 20uL, &rt);
+        }
+        
+        /* route 2 (route to PC1_2) */
+        /* ------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0x11,0x33,0x55,0x77,0x99});
+            demo_rt_ld_set_egress_phyif(&rt, "emac1");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 2uL, &rt);
+        }
+        
+        /* route 5 (route to PC1_5) */
+        /* ------------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0x22,0x44,0x66,0x88,0xAA});
+            demo_rt_ld_set_egress_phyif(&rt, "emac1");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 5uL, &rt);
+        }
+    }
+    
+    
+    /* set timeout for conntracks (not necessary; done for demo purposes) */
+    /* ================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        demo_ct_timeout_tcp(p_cl, 0xFFFFFFFFuL);
+    }
+    
+    
+    /* create conntracks between PC1_2 (client_2) and PC0_20 (server) */
+    /* ============================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_ct_cmd_t ct = {0};
+        
+        /* from PC1_2 (client_2) to PC0_20 (server) */
+        /* ---------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            /*  This conntrack is configured as an unidirectional NAT/PAT conntrack.
+                FCI command to create this conntrack results in one connection being
+                created in PFE - a connection from PC1_2 to PC0_20 ("orig" direction only).
+                Packets routed by this conntrack are modified by PFE as follows:
+                    --> Source IP of the routed packet is replaced with the conntrack's 
+                        "reply" dir destination IP address (NAT behavior).
+                    --> Source port of the routed packet is replaced with the conntrack's
+                        "reply" dir destination port (PAT behavior).
+            */
+            demo_ct_ld_set_protocol(&ct, 6u);  /* 6 == TCP */
+            demo_ct_ld_set_orig_dir(&ct, 0x0A0B0003u,0xC8C9CA14u,4000u,4000u, 0u,20uL, true);
+            demo_ct_ld_set_reply_dir(&ct,0xC8C9CA14u,0x6465660Au,4000u,40003u,0u, 0uL, false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+        
+        /* from PC0_20 (server) back to PC1_2 (client_2) */
+        /* --------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            /*  This conntrack is a complement to the previous one - it represents
+                connection from PC0_20 back to PC1_2.
+                Notice that this conntrack translates source IP / source port of 
+                the routed packet back to the values expected by the PC1_2.
+            */
+            demo_ct_ld_set_protocol(&ct, 6u);  /* 6 == TCP */
+            demo_ct_ld_set_orig_dir(&ct, 0xC8C9CA14u,0x6465660Au,4000u,40003u,0u,2uL, true);
+            demo_ct_ld_set_reply_dir(&ct,0x0A0B0003u,0xC8C9CA14u,4000u,4000u, 0u,0uL, false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+    }
+    
+    
+    /* create conntracks between PC1_5 (client_5) and PC0_20 (server) */
+    /* ============================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_ct_cmd_t ct = {0};
+        
+        /* from PC1_5 (client_5) to PC0_20 (server) */
+        /* ---------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            demo_ct_ld_set_protocol(&ct, 6u);  /* 6 == TCP */
+            demo_ct_ld_set_orig_dir(&ct, 0x0A0B0005u,0xC8C9CA14u,4000u,4000u, 0u,20uL, true);
+            demo_ct_ld_set_reply_dir(&ct,0xC8C9CA14u,0x6465660Au,4000u,40005u,0u, 0uL, false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+        
+        /* from PC0_20 (server) back to PC1_5 (client_5) */
+        /* --------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            demo_ct_ld_set_protocol(&ct, 6u);  /* 6 == TCP */
+            demo_ct_ld_set_orig_dir(&ct, 0xC8C9CA14u,0x6465660Au,4000u,40005u,0u,5uL, true);
+            demo_ct_ld_set_reply_dir(&ct,0x0A0B0005u,0xC8C9CA14u,4000u,4000u, 0u,0uL, false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+    }
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, false);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_ROUTER);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, false);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_ROUTER);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_router_simple.c b/sw/libfci_cli/src/libfci_demo/demo_feature_router_simple.c
new file mode 100644
index 0000000..6952474
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_router_simple.c
@@ -0,0 +1,215 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_rt_ct.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE as a simple router.
+ * @details    Scenario description:
+ *               [*] Let there be two computers (PCs): PC0_7 and PC1_11.
+ *                   Each PC is in a different network subnet.
+ *               [*] Use libFCI to configure PFE as a simple router, allowing ICMP (ping)
+ *                   communication between PC0_7 and PC1_11.
+ *             PC description:
+ *               PC0_7:
+ *                 --> IP  address: 10.7.0.2/24
+ *                 --> MAC address: 0A:01:23:45:67:89
+ *                     (this is just a demo MAC; real MAC of the real PC0_7 should be used)
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Configured to send 10.11.0.0 traffic to PFE's emac0.
+ *               PC1_11:
+ *                 --> IP  address: 10.11.0.5/24
+ *                 --> MAC address: 0A:FE:DC:BA:98:76
+ *                     (this is just a demo MAC; real MAC of the real PC1_11 should be used)
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Configured to send 10.7.0.0 traffic to PFE's emac1.
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          Router should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_router_simple(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* clear all IPv4 routes and conntracks in PFE (not necessary, done for demo purposes) */
+    /* =================================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_rtct_reset_ip4(p_cl);
+    }
+    
+    
+    /* create routes */
+    /* ============= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_rt_cmd_t rt = {0};
+        
+        /* route 7 (route to PC0_7) */
+        /* ------------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0x01,0x23,0x45,0x67,0x89});
+            demo_rt_ld_set_egress_phyif(&rt, "emac0");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 7uL, &rt);
+        }
+        
+        /* route 11 (route to PC1_11) */
+        /* -------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new route */
+            demo_rt_ld_set_as_ip4(&rt);
+            demo_rt_ld_set_dst_mac(&rt, (const uint8_t[6]){0x0A,0xFE,0xDC,0xBA,0x98,0x76});
+            demo_rt_ld_set_egress_phyif(&rt, "emac1");
+            
+            /* create a new route in PFE */
+            rtn = demo_rt_add(p_cl, 11uL, &rt);
+        }
+    }
+    
+    
+    /* set timeout for conntracks (not necessary; done for demo purposes) */
+    /* ================================================================== */
+    if (FPP_ERR_OK == rtn)
+    {
+        demo_ct_timeout_others(p_cl, 0xFFFFFFFFuL);  /* ping is ICMP, that is 'others' */
+    }
+    
+    
+    /* create conntracks */
+    /* ================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_ct_cmd_t ct = {0};
+        
+        /* conntrack from PC0_7 to PC1_11 (and back) */
+        /* ----------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new conntrack */
+            /*  This conntrack is configured as a bi-directional conntrack.
+                FCI command to create this conntrack results in two connections being 
+                created in PFE:
+                    --> one for the "orig" direction
+                    --> one for the "reply" direction
+            */
+            demo_ct_ld_set_protocol(&ct, 1u);  /* 1 == ICMP */
+            demo_ct_ld_set_orig_dir(&ct,  0x0A070002u,0x0A0B0005u,0u,0u, 0u,11uL, false);
+            demo_ct_ld_set_reply_dir(&ct, 0x0A0B0005u,0x0A070002u,0u,0u, 0u, 7uL, false);
+            
+            /* create a new conntrack in PFE */
+            rtn = demo_ct_add(p_cl, &ct);
+        }
+    }
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, false);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_ROUTER);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, false);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_ROUTER);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_feature_spd.c b/sw/libfci_cli/src/libfci_demo/demo_feature_spd.c
new file mode 100644
index 0000000..abb7acb
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_feature_spd.c
@@ -0,0 +1,302 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+#include "demo_log_if.h"
+#include "demo_spd.h"
+ 
+ 
+/*
+ * @brief      Use libFCI to configure PFE IPsec support.
+ * @details    Scenario description:
+ *               [*] Let there be two computers (PCs):
+ *                     --> PC0, which uses encrypted communication.
+ *                     --> PC1, which uses unencrypted communication.
+ *               [*] Use libFCI to configure PFE IPsec support, allowing ICMP (ping) and 
+ *                   TCP (port 4000) communication between PC0 and PC1.
+ *                     --> Traffic from PC0 should be decrypted by PFE, then sent to PC1.
+ *                     --> Traffic from PC1 should be encrypted by PFE, then sent to PC0.
+ *               [*] NOTE:
+ *                   To fully enable PFE IPsec support, it is required to configure 
+ *                   the underlying HSE (Hardware Security Engine). HSE configuration 
+ *                   is not done by the FCI API and is outside the scope of this demo.
+ *             PC description:
+ *               PC0:
+ *                 --> IP address: 10.7.0.2/24
+ *                 --> Accessible via PFE's emac0 physical interface.
+ *                 --> Configured to send 10.11.0.0 traffic to PFE's emac0.
+ *                 --> Requires IPsec-encrypted communication.
+ *               PC1:
+ *                 --> IP address: 10.11.0.5/24
+ *                 --> Accessible via PFE's emac1 physical interface.
+ *                 --> Configured to send 10.7.0.0 traffic to PFE's emac1.
+ *              
+ * @note       This code uses a suite of "demo_" functions. The "demo_" functions encapsulate
+ *             manipulation of libFCI data structs and calls of libFCI functions.
+ *             It is advised to inspect content of these "demo_" functions.
+ *              
+ * @param[in]  p_cl         FCI client
+ *                          To create a client, use libFCI function fci_open().
+ * @return     FPP_ERR_OK : All FCI commands were successfully executed.
+ *                          IPsec support should be up and running.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_feature_spd(FCI_CLIENT* p_cl)
+{  
+    assert(NULL != p_cl);
+    int rtn = FPP_ERR_OK;
+    
+    
+    /* configure SPD database entries on emac0 */
+    /* ======================================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_spd_cmd_t spd = {0};
+        uint32_t src_ip[4] = {0};
+        uint32_t dst_ip[4] = {0};
+        
+        /* create SPD entry for ICMP traffic (ping) from PC0 to PC1 */
+        /* -------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new SPD entry */
+            /* SPI passed in the demo_spd_ld_set_action() should be known by HSE */
+            src_ip[0] = 0x0A070002;
+            dst_ip[0] = 0x0A0B0005;
+            demo_spd_ld_set_protocol(&spd, 1u);  /* 1 == ICMP */ 
+            demo_spd_ld_set_ip(&spd, src_ip, dst_ip, false);
+            demo_spd_ld_set_port(&spd, false, 0u, false, 0u);
+            demo_spd_ld_set_action(&spd, FPP_SPD_ACTION_PROCESS_DECODE, 0u, 0x11335577);
+            
+            /* create a new SPD entry in PFE */
+            rtn = demo_spd_add(p_cl, "emac0", 0u, &spd);
+        }
+        
+        /* create SPD entry for TCP traffic from PC0 to PC1 */
+        /* ------------------------------------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new SPD entry */
+            /* SPI passed in the demo_spd_ld_set_action() should be known by HSE */
+            src_ip[0] = 0x0A070002;
+            dst_ip[0] = 0x0A0B0005;
+            demo_spd_ld_set_protocol(&spd, 6u);  /* 6 == TCP */ 
+            demo_spd_ld_set_ip(&spd, src_ip, dst_ip, false);
+            demo_spd_ld_set_port(&spd, true, 4000u, true, 4000u);
+            demo_spd_ld_set_action(&spd, FPP_SPD_ACTION_PROCESS_DECODE, 0u, 0x22446688);
+            
+            /* create a new SPD entry in PFE */
+            rtn = demo_spd_add(p_cl, "emac0", 1u, &spd);
+        }
+    }
+    
+    
+    /* configure SPD database entries on emac1 */
+    /* ======================================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        fpp_spd_cmd_t spd = {0};
+        uint32_t src_ip[4] = {0};
+        uint32_t dst_ip[4] = {0};
+        
+        /* create SPD entry for ICMP traffic (ping) from PC1 to PC0 */
+        /* -------------------------------------------------------- */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new SPD entry */
+            /* SA_ID passed in the demo_spd_ld_set_action() should be 
+               a valid index to some SAD entry in HSE */
+            src_ip[0] = 0x0A0B0005;
+            dst_ip[0] = 0x0A070002;
+            demo_spd_ld_set_protocol(&spd, 1u);  /* 1 == ICMP */ 
+            demo_spd_ld_set_ip(&spd, src_ip, dst_ip, false);
+            demo_spd_ld_set_port(&spd, false, 0u, false, 0u);
+            demo_spd_ld_set_action(&spd, FPP_SPD_ACTION_PROCESS_ENCODE, 1u, 0u);
+            
+            /* create a new SPD entry in PFE */
+            rtn = demo_spd_add(p_cl, "emac1", 0u, &spd);
+        }
+        
+        /* create SPD entry for TCP traffic from PC1 to PC0 */
+        /* ------------------------------------------------ */
+        if (FPP_ERR_OK == rtn)
+        {
+            /* locally prepare data for a new SPD entry */
+            /* SA_ID passed in the demo_spd_ld_set_action() should be 
+               a valid index to some SAD entry in HSE */
+            src_ip[0] = 0x0A0B0005;
+            dst_ip[0] = 0x0A070002;
+            demo_spd_ld_set_protocol(&spd, 6u);  /* 6 == TCP */ 
+            demo_spd_ld_set_ip(&spd, src_ip, dst_ip, false);
+            demo_spd_ld_set_port(&spd, true, 4000u, true, 4000u);
+            demo_spd_ld_set_action(&spd, FPP_SPD_ACTION_PROCESS_ENCODE, 2u, 0);
+            
+            /* create a new SPD entry in PFE */
+            rtn = demo_spd_add(p_cl, "emac1", 1u, &spd);
+        }
+    }
+    
+    
+    /* configure physical interfaces */
+    /* ============================= */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* lock the interface database of PFE */
+        rtn = demo_if_session_lock(p_cl);
+        if (FPP_ERR_OK == rtn)
+        {
+            fpp_phy_if_cmd_t phyif = {0};
+            
+            /* configure physical interface "emac0" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac0");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, false);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_DEFAULT);
+                
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "emac1" */
+            /* ------------------------------------ */
+            if (FPP_ERR_OK == rtn)
+            {
+                /* get data from PFE and store them in the local variable "phyif" */
+                rtn = demo_phy_if_get_by_name(p_cl, &phyif, "emac1");
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* modify locally stored data */
+                    demo_phy_if_ld_enable(&phyif);
+                    demo_phy_if_ld_set_promisc(&phyif, false);
+                    demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_DEFAULT);
+                    
+                    /* update data in PFE */
+                    rtn = demo_phy_if_update(p_cl, &phyif);
+                }
+            }
+            
+            /* configure physical interface "util" */
+            /* ----------------------------------- */
+            /* This interface represents interaction between PFE and HSE.
+               This example configures util in Flexible Router mode to allow for distribution
+               of the traffic which arrives from HSE. */
+            if (FPP_ERR_OK == rtn)
+            {
+                fpp_log_if_cmd_t logif = {0};
+                fpp_phy_if_cmd_t phyif = {0};
+                
+                /* create and configure a logical interface for traffic from PC0 to PC1 */
+                /* -------------------------------------------------------------------- */
+                if (FPP_ERR_OK == rtn)
+                {
+                    rtn = demo_log_if_add(p_cl, &logif, "From-PC0_to-PC1", "util");
+                    if (FPP_ERR_OK == rtn)
+                    {
+                        /* NOTE: 1u == ID of emac1 */
+                        demo_log_if_ld_set_promisc(&logif, false);
+                        demo_log_if_ld_set_egress_phyifs(&logif, (1uL << 1u));
+                        demo_log_if_ld_set_match_mode_or(&logif, false);
+                        demo_log_if_ld_clear_all_mr(&logif);
+                        demo_log_if_ld_set_mr_sip(&logif, true, 0x0A070002);
+                        demo_log_if_ld_set_mr_dip(&logif, true, 0x0A0B0005);
+                        demo_log_if_ld_enable(&logif);
+                        
+                        rtn = demo_log_if_update(p_cl, &logif);
+                    }
+                }
+                
+                /* create and configure a logical interface for traffic from PC1 to PC0 */
+                /* -------------------------------------------------------------------- */
+                if (FPP_ERR_OK == rtn)
+                {
+                    rtn = demo_log_if_add(p_cl, &logif, "From-PC1_to-PC0", "util");
+                    if (FPP_ERR_OK == rtn)
+                    {
+                        /* NOTE: 0u == ID of emac0 */
+                        demo_log_if_ld_set_promisc(&logif, false);
+                        demo_log_if_ld_set_egress_phyifs(&logif, (1uL << 0u));
+                        demo_log_if_ld_set_match_mode_or(&logif, false);
+                        demo_log_if_ld_clear_all_mr(&logif);
+                        demo_log_if_ld_set_mr_sip(&logif, true, 0x0A0B0005);
+                        demo_log_if_ld_set_mr_dip(&logif, true, 0x0A070002);
+                        demo_log_if_ld_enable(&logif);
+                        
+                        rtn = demo_log_if_update(p_cl, &logif);
+                    }
+                }
+                
+                /* configure physical interface "util" */
+                /* ----------------------------------- */
+                if (FPP_ERR_OK == rtn)
+                {
+                    /* get data from PFE and store them in the local variable "phyif" */
+                    rtn = demo_phy_if_get_by_name(p_cl, &phyif, "util");
+                    if (FPP_ERR_OK == rtn)
+                    {
+                        /* modify locally stored data */
+                        demo_phy_if_ld_enable(&phyif);
+                        demo_phy_if_ld_set_promisc(&phyif, false);
+                        demo_phy_if_ld_set_mode(&phyif, FPP_IF_OP_FLEXIBLE_ROUTER);
+                        
+                        /* update data in PFE */
+                        rtn = demo_phy_if_update(p_cl, &phyif);
+                    }
+                }
+            }
+        }
+        
+        /* unlock the interface database of PFE */
+        rtn = demo_if_session_unlock(p_cl, rtn);
+    }
+    
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fp.c b/sw/libfci_cli/src/libfci_demo/demo_fp.c
similarity index 55%
rename from sw/libfci_cli/src/libfci_interface/fci_fp.c
rename to sw/libfci_cli/src/libfci_demo/demo_fp.c
index 7027acb..64d6e67 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_fp.c
+++ b/sw/libfci_cli/src/libfci_demo/demo_fp.c
@@ -30,96 +30,50 @@
  
  
 #include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
 #include <string.h>
 #include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
 #include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
-#include "fci_common.h"
-#include "fci_fp.h"
  
+#include "demo_common.h"
+#include "demo_fp.h"
  
-/* ==== PRIVATE FUNCTIONS ================================================== */
  
- 
-/*
- * @brief          Network-to-host (ntoh) function for a FP rule properties struct.
- * @param[in,out]  p_rtn_rule_props  The FP rule properties struct to be converted.
- */
-static void ntoh_rule_props(fpp_fp_rule_props_t* p_rtn_rule_props)
-{
-    assert(NULL != p_rtn_rule_props);
-    
-    
-    p_rtn_rule_props->data = ntohl(p_rtn_rule_props->data);
-    p_rtn_rule_props->mask = ntohl(p_rtn_rule_props->mask);
-    p_rtn_rule_props->offset = ntohs(p_rtn_rule_props->offset);
-    ntoh_enum(&(p_rtn_rule_props->match_action), sizeof(fpp_fp_rule_match_action_t));
-    ntoh_enum(&(p_rtn_rule_props->offset_from), sizeof(fpp_fp_offset_from_t));
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a FP rule properties struct.
- * @param[in,out]  p_rtn_rule_props  The FP rule properties struct to be converted.
- */
-static void hton_rule_props(fpp_fp_rule_props_t* p_rtn_rule_props)
-{
-    assert(NULL != p_rtn_rule_props);
-    
-    
-    p_rtn_rule_props->data = htonl(p_rtn_rule_props->data);
-    p_rtn_rule_props->mask = htonl(p_rtn_rule_props->mask);
-    p_rtn_rule_props->offset = htons(p_rtn_rule_props->offset);
-    hton_enum(&(p_rtn_rule_props->match_action), sizeof(fpp_fp_rule_match_action_t));
-    hton_enum(&(p_rtn_rule_props->offset_from), sizeof(fpp_fp_offset_from_t));
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a FP table struct when a rule is
- *                 inserted into the table.
- * @param[in,out]  p_rtn_table  The FP table struct to be converted.
- */
-static void hton_table(fpp_fp_table_cmd_t* p_rtn_table)
-{
-    assert(NULL != p_rtn_table);
-    p_rtn_table->table_info.t.position = htons(p_rtn_table->table_info.t.position);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
  
  
 /*
  * @brief       Use FCI calls to get configuration data of a requested FP rule
- *              from the PFE. Identify the rule by its name.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_rule   Space for data from the PFE.
- * @param[out]  p_rtn_idx    Space for index of the requested FP rule (from the PFE).
+ *              from PFE. Identify the rule by its name.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_rule   Space for data from PFE.
+ * @param[out]  p_rtn_idx    Space for index of the requested FP rule.
  *                           This is a generic index of the given rule in a common pool of
- *                           FP rules. It has no ties to any FP table.
+ *                           FP rules within PFE. It has no ties to any particular FP table.
  *                           Can be NULL. If NULL, then no index is stored.
  * @param[in]   p_rule_name  Name of the requested FP rule.
- *                           Names of FP rules are user-defined. See fci_fp_rule_add().
- * @return      FPP_ERR_OK : Requested FP rule was found.
- *                           A copy of its configuration was stored into p_rtn_rule.
- *                           Its index in a common pool of FP rules was stored into p_rtn_idx.
- *              other      : Some error occured (represented by the respective error code).
+ *                           Names of FP rules are user-defined.
+ *                           See demo_fp_rule_add().
+ * @return      FPP_ERR_OK : The requested FP rule was found.
+ *                           A copy of its configuration data was stored into p_rtn_rule.
+ *                           Its common pool index was stored into p_rtn_idx.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
  *                           No data copied.
  */
-int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule, 
-                            uint16_t* p_rtn_idx, const char* p_rule_name)
+int demo_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule, 
+                             uint16_t* p_rtn_idx, const char* p_rule_name)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_rule);
     assert(NULL != p_rule_name);
     /* 'p_rtn_index' is allowed to be NULL */
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fp_rule_cmd_t cmd_to_fci = {0};
     fpp_fp_rule_cmd_t reply_from_fci = {0};
@@ -131,10 +85,10 @@ int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule,
     rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
                     sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
                     &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order of rule properties */
     
     /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) && strcmp(p_rule_name, (char*)(reply_from_fci.r.rule_name)))
+    while ((FPP_ERR_OK == rtn) && 
+           (0 != strcmp((char*)(reply_from_fci.r.rule_name), p_rule_name)))
     {
         idx++;
         
@@ -142,10 +96,9 @@ int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule,
         rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
                         sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order of rule properties */
     }
     
-    /* if search successful, then assign the data */
+    /* if a query is successful, then assign the data */
     if (FPP_ERR_OK == rtn)
     {
         *p_rtn_rule = reply_from_fci;
@@ -155,34 +108,35 @@ int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule,
         }
     }
     
+    print_if_error(rtn, "demo_fp_rule_get_by_name() failed!");
+    
     return (rtn);
 }
  
  
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
  
  
 /*
- * @brief       Use FCI calls to create a new FP rule in the PFE.
- * @param[in]   p_cl         FCI client instance
+ * @brief       Use FCI calls to create a new FP rule in PFE.
+ * @param[in]   p_cl         FCI client
  * @param[in]   p_rule_name  Name of the new FP rule.
  *                           The name is user-defined.
- * @param[in]   p_rule_data  Configuration data for the new FP rule.
+ * @param[in]   p_rule_data  Configuration data of the new FP rule.
  *                           To create a new FP rule, a local data struct must be created,
  *                           configured and then passed to this function.
- *                           See [localdata] functions to learn more.
+ *                           See [localdata_fprule] to learn more.
  * @return      FPP_ERR_OK : New FP rule was created.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name,
-                    const fpp_fp_rule_cmd_t* p_rule_data)
+int demo_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name,
+                     const fpp_fp_rule_cmd_t* p_rule_data)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rule_name);
     assert(NULL != p_rule_data);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fp_rule_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -192,29 +146,29 @@ int fci_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name,
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        hton_rule_props(&(cmd_to_fci.r));  /* set correct byte order of rule properties */
         cmd_to_fci.action = FPP_ACTION_REGISTER;
         rtn = fci_write(p_cl, FPP_CMD_FP_RULE, sizeof(fpp_fp_rule_cmd_t), 
                                               (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fp_rule_add() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief      Use FCI calls to destroy the target FP rule in the PFE.
- * @param[in]  p_cl         FCI client instance
+ * @brief      Use FCI calls to destroy the target FP rule in PFE.
+ * @param[in]  p_cl         FCI client
  * @param[in]  p_rule_name  Name of the FP rule to destroy.
- * @return     FPP_ERR_OK : FP rule was destroyed.
- *             other      : Some error occured (represented by the respective error code).
+ * @return     FPP_ERR_OK : The FP rule was destroyed.
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name)
+int demo_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name)
 {
     assert(NULL != p_cl);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fp_rule_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -223,31 +177,31 @@ int fci_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name)
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        hton_rule_props(&(cmd_to_fci.r));  /* set correct byte order of rule properties */
         cmd_to_fci.action = FPP_ACTION_DEREGISTER;
         rtn = fci_write(p_cl, FPP_CMD_FP_RULE, sizeof(fpp_fp_rule_cmd_t), 
                                               (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fp_rule_del() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief       Use FCI calls to create a new FP table in the PFE.
- * @param[in]   p_cl          FCI client instance
+ * @brief       Use FCI calls to create a new FP table in PFE.
+ * @param[in]   p_cl          FCI client
  * @param[in]   p_table_name  Name of the new FP table.
  *                            The name is user-defined.
  * @return      FPP_ERR_OK : New FP table was created.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name)
+int demo_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name)
 {
     assert(NULL != p_cl);
     assert(NULL != p_table_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fp_table_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -256,29 +210,29 @@ int fci_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name)
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        /* only text was set, no need to change byte order */
         cmd_to_fci.action = FPP_ACTION_REGISTER;
         rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
                                                (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fp_table_add() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief      Use FCI calls to destroy the target FP table in the PFE.
- * @param[in]  p_cl          FCI client instance
+ * @brief      Use FCI calls to destroy the target FP table in PFE.
+ * @param[in]  p_cl          FCI client
  * @param[in]  p_table_name  Name of the FP table to destroy.
- * @return     FPP_ERR_OK : FP table was destroyed.
- *             other      : Some error occured (represented by the respective error code).
+ * @return     FPP_ERR_OK : The FP table was destroyed.
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name)
+int demo_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name)
 {
     assert(NULL != p_cl);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fp_table_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -287,34 +241,34 @@ int fci_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name)
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        /* only text was set, no need to change byte order */
         cmd_to_fci.action = FPP_ACTION_DEREGISTER;
         rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
                                                (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fp_table_del() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief       Use FCI calls to insert a FP rule at given position of a FP table in the PFE.
- * @param[in]   p_cl          FCI client instance
+ * @brief       Use FCI calls to insert a FP rule at a given position of a FP table in PFE.
+ * @param[in]   p_cl          FCI client
  * @param[in]   p_table_name  Name of an existing FP table.
  * @param[in]   p_rule_name   Name of an existing FP rule.
  * @param[in]   position      Index where to insert the rule. Starts at 0.
  * @return      FPP_ERR_OK : The rule was successfully inserted into the table.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name, 
-                             const char* p_rule_name, uint16_t position)
+int demo_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name, 
+                              const char* p_rule_name, uint16_t position)
 {
     assert(NULL != p_cl);
     assert(NULL != p_table_name);
     assert(NULL != p_rule_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fp_table_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -325,39 +279,39 @@ int fci_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name,
     }
     if (FPP_ERR_OK == rtn)
     {
-        cmd_to_fci.table_info.t.position = position;
+        cmd_to_fci.table_info.t.position = htons(position);
     }
     
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        hton_table(&cmd_to_fci);  /* set correct byte order */
         cmd_to_fci.action = FPP_ACTION_USE_RULE;
         rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
                                                (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fp_table_insert_rule() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief       Use FCI calls to remove a FP rule from a FP table in the PFE.
- * @param[in]   p_cl          FCI client instance
+ * @brief       Use FCI calls to remove a FP rule from a FP table in PFE.
+ * @param[in]   p_cl          FCI client
  * @param[in]   p_table_name  Name of an existing FP table.
- * @param[in]   p_rule_name   Name of an existing FP rule.
+ * @param[in]   p_rule_name   Name of a FP rule which is present in the FP table.
  * @return      FPP_ERR_OK : The rule was successfully removed from the table.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name, 
-                             const char* p_rule_name)
+int demo_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name, 
+                              const char* p_rule_name)
 {
     assert(NULL != p_cl);
     assert(NULL != p_table_name);
     assert(NULL != p_rule_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fp_table_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -370,12 +324,13 @@ int fci_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name,
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        hton_table(&cmd_to_fci);  /* set correct byte order */
         cmd_to_fci.action = FPP_ACTION_UNUSE_RULE;
         rtn = fci_write(p_cl, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
                                                (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fp_table_remove_rule() failed!");
+    
     return (rtn);
 }
  
@@ -383,129 +338,224 @@ int fci_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name,
 /* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
 /*
  * @defgroup    localdata_fprule  [localdata_fprule]
- * @brief:      Functions marked as [localdata_fprule] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_fp_rule_add() to 
- *              create a new FP rule with given configuration in the PFE.
+ * @brief:      Functions marked as [localdata_fprule] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_rule (a struct with configuration data).
+ *              For addition of FP rules, there are no "initial data" to be obtained from PFE.
+ *              Simply declare a local data struct and configure it.
+ *              Then, after all modifications are done and finished,
+ *              call demo_fp_rule_add() to create a new FP rule in PFE.
  */
  
  
 /*
- * @brief          Set data template of a FP rule.
+ * @brief          Set a data "template" of a FP rule.
  * @details        [localdata_fprule]
  * @param[in,out]  p_rule  Local data to be modified.
- *                         For FP rules, there are no "initial data" to be obtained from PFE.
- *                         Simply declare a local data struct and configure it.
- * @param[in]      data    Data template (value)
+ * @param[in]      data    Data "template" (a value)
  *                         This value will be compared with a selected value from 
  *                         the inspected traffic.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
  */
-int fci_fp_rule_ld_set_data(fpp_fp_rule_cmd_t* p_rule, uint32_t data)
+void demo_fp_rule_ld_set_data(fpp_fp_rule_cmd_t* p_rule, uint32_t data)
 {
     assert(NULL != p_rule);
-    p_rule->r.data = data;
-    return (FPP_ERR_OK);
+    p_rule->r.data = htonl(data);
 }
  
  
 /*
- * @brief          Set bitmask of a FP rule.
+ * @brief          Set a bitmask of a FP rule.
  * @details        [localdata_fprule]
  * @param[in,out]  p_rule  Local data to be modified.
- *                         For FP rules, there are no "initial data" to be obtained from PFE.
- *                         Simply declare a local data struct and configure it.
  * @param[in]      mask    Bitmask for more precise data selection.
  *                         This bitmask is applied on the selected 32bit value from
  *                         the inspected traffic.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
  */
-int fci_fp_rule_ld_set_mask(fpp_fp_rule_cmd_t* p_rule, uint32_t mask)
+void demo_fp_rule_ld_set_mask(fpp_fp_rule_cmd_t* p_rule, uint32_t mask)
 {
     assert(NULL != p_rule);
-    p_rule->r.mask = mask;
-    return (FPP_ERR_OK);
+    p_rule->r.mask = htonl(mask);
 }
  
  
 /*
- * @brief          Set offset and base for offset ("offset from") of a FP rule.
+ * @brief          Set an offset and a base for the offset ("offset from") of a FP rule.
  * @details        [localdata_fprule]
  * @param[in,out]  p_rule  Local data to be modified.
- *                         For FP rules, there are no "initial data" to be obtained from PFE.
- *                         Simply declare a local data struct and configure it.
  * @param[in]      offset  Offset (in bytes) into traffic's data.
- *                         This offset is applied from the respective base ("offset_from").
- *                         A 32bit data value which lies on the offset is the value selected
+ *                         The offset is applied from the respective base ("offset_from").
+ *                         Data value (32bit) which lies on the offset is the value selected
  *                         for comparison under the given FP rule.
- * @param[in]      offset_from  The base for offset calculation.
- *                              See description of fpp_fp_offset_from_t type 
- *                              in the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
+ * @param[in]      offset_from  Base for an offset calculation.
+ *                              See description of the fpp_fp_offset_from_t type 
+ *                              in FCI API Reference.
  */
-int fci_fp_rule_ld_set_offset(fpp_fp_rule_cmd_t* p_rule, uint16_t offset, 
-                              fpp_fp_offset_from_t offset_from)
+void demo_fp_rule_ld_set_offset(fpp_fp_rule_cmd_t* p_rule, uint16_t offset, 
+                                fpp_fp_offset_from_t offset_from)
 {
     assert(NULL != p_rule);
-    p_rule->r.offset = offset;
+    
+    p_rule->r.offset = htons(offset);
+    
+    hton_enum(&offset_from, sizeof(fpp_fp_offset_from_t));
     p_rule->r.offset_from = offset_from;
-    return (FPP_ERR_OK);
 }
  
  
 /*
- * @brief          Set/unset inverted mode of FP rule match evaluation.
+ * @brief          Set/unset an inverted mode of a FP rule match evaluation.
  * @details        [localdata_fprule]
  * @param[in,out]  p_rule  Local data to be modified.
- *                         For FP rules, there are no "initial data" to be obtained from PFE.
- *                         Simply declare a local data struct and configure it.
- * @param[in]      invert  A request to set/unset the inverted mode of evaluation.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
+ * @param[in]      invert  Request to set/unset the inverted mode of evaluation.
  */
-int fci_fp_rule_ld_set_invert(fpp_fp_rule_cmd_t* p_rule, bool invert)
+void demo_fp_rule_ld_set_invert(fpp_fp_rule_cmd_t* p_rule, bool invert)
 {
     assert(NULL != p_rule);
-    p_rule->r.invert = invert;  /* NOTE: Implicit cast of bool to uintX_t */
-    return (FPP_ERR_OK);
+    p_rule->r.invert = invert;  /* NOTE: Implicit cast from bool to uint8_t */
 }
  
  
 /*
- * @brief          Set action to be done if inspected traffic satisfies the given FP rule.
+ * @brief          Set action to be done if inspected traffic satisfies a FP rule.
  * @details        [localdata_fprule]
  * @param[in,out]  p_rule  Local data to be modified.
- *                         For FP rules, there are no "initial data" to be obtained from PFE.
- *                         Simply declare a local data struct and configure it.
- * @param[in]      match_action      An action to be done.
- *                                   See description of fpp_fp_rule_match_action_t type
- *                                   in the FCI API Reference.
- * @param[in]      p_next_rule_name  Name of the next FP rule to execute.
- *                                   Is meaningful only if the match action is FP_NEXT_RULE.
+ * @param[in]      match_action      Action to be done.
+ *                                   See description of the fpp_fp_rule_match_action_t type
+ *                                   in FCI API Reference.
+ * @param[in]      p_next_rule_name  Name of a next FP rule to execute.
+ *                                   Meaningful only if the match action is FP_NEXT_RULE.
  *                                   Can be NULL. If NULL or "" (empty string), 
  *                                   then no rule is set as the next rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
  */
-int fci_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule, 
-                                    fpp_fp_rule_match_action_t match_action,
-                                    const char* p_next_rule_name)
+void demo_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule, 
+                                      fpp_fp_rule_match_action_t match_action,
+                                      const char* p_next_rule_name)
 {
     assert(NULL != p_rule);
     /* 'p_next_rule_name' is allowed to be NULL */
     
+    hton_enum(&match_action, sizeof(fpp_fp_rule_match_action_t));
     p_rule->r.match_action = match_action;
-    return set_text((char*)(p_rule->r.next_rule_name), p_next_rule_name, IFNAMSIZ);
+    
+    set_text((char*)(p_rule->r.next_rule_name), p_next_rule_name, IFNAMSIZ);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query the status of an invert mode of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the FP rule:
+ *             true  : was running in the inverted mode
+ *             false : was NOT running in the inverted mode
+ */
+bool demo_fp_rule_ld_is_invert(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    return (bool)(p_rule->r.invert);
+}
+ 
+ 
+/*
+ * @brief      Query the name of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Name of the FP rule.
+ */
+const char* demo_fp_rule_ld_get_name(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    return (const char*)(p_rule->r.rule_name);
+}
+ 
+ 
+/*
+ * @brief      Query the name of a "next FP rule".
+ * @details    [localdata_fprule]
+ *             "Next FP rule" is meaningful only when "match_action == FP_NEXT_RULE"
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Name of the "next FP rule".
+ */
+const char* demo_fp_rule_ld_get_next_name(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    return (const char*)(p_rule->r.next_rule_name);
+}
+ 
+ 
+/*
+ * @brief      Query the data "template" of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Data "template" used by the FP rule.
+ */
+uint32_t demo_fp_rule_ld_get_data(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    return ntohl(p_rule->r.data);
+}
+ 
+ 
+/*
+ * @brief      Query the bitmask of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Bitmask used by the FP rule.
+ */
+uint32_t demo_fp_rule_ld_get_mask(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    return ntohl(p_rule->r.mask);
+}
+ 
+ 
+/*
+ * @brief      Query the offset of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Offset where to find the inspected value in the traffic data.
+ */
+uint16_t demo_fp_rule_ld_get_offset(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    return ntohs(p_rule->r.offset);
+}
+ 
+ 
+/*
+ * @brief      Query the offset base ("offset from") of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Base position in traffic data to use for offset calculation.
+ */
+fpp_fp_offset_from_t demo_fp_rule_ld_get_offset_from(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    
+    fpp_fp_offset_from_t tmp_offset_from = (p_rule->r.offset_from);
+    ntoh_enum(&tmp_offset_from, sizeof(fpp_fp_offset_from_t));
+    
+    return (tmp_offset_from);
+}
+ 
+ 
+/*
+ * @brief      Query the match action of a FP rule.
+ * @details    [localdata_fprule]
+ * @param[in]  p_rule  Local data to be queried.
+ * @return     Match action of the FP rule.
+ */
+fpp_fp_rule_match_action_t demo_fp_rule_ld_get_match_action(const fpp_fp_rule_cmd_t* p_rule)
+{
+    assert(NULL != p_rule);
+    
+    fpp_fp_rule_match_action_t tmp_match_action = (p_rule->r.match_action);
+    ntoh_enum(&tmp_match_action, sizeof(fpp_fp_rule_match_action_t));
+    
+    return (tmp_match_action);
 }
  
  
@@ -513,33 +563,32 @@ int fci_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule,
  
  
 /*
- * @brief      Use FCI calls to iterate through all FP rules of a given FP table in the PFE.
- *             Execute a print function for each reported FP rule.
- * @param[in]  p_cl           FCI client instance
+ * @brief      Use FCI calls to iterate through all available FP rules of a given FP table
+ *             in PFE. Execute a callback print function for each applicable FP rule.
+ * @param[in]  p_cl           FCI client
  * @param[in]  p_cb_print     Callback print function.
- *                            --> If the callback returns zero, then all is OK and 
- *                                the next FP rule in table is picked for a print process.
- *                            --> If the callback returns non-zero, then some problem is 
+ *                            --> If the callback returns ZERO, then all is OK and 
+ *                                a next FP rule in table is picked for a print process.
+ *                            --> If the callback returns NON-ZERO, then some problem is 
  *                                assumed and this function terminates prematurely.
  * @param[in]  p_table_name   Name of a FP table.
- *                            Names of FP tables are user-defined. See fci_fp_table_add().
- * @param[in]  position_init  Start invoking callback print function from 
- *                            this position in the table.
+ *                            Names of FP tables are user-defined. See demo_fp_table_add().
+ * @param[in]  position_init  Start invoking a callback print function from 
+ *                            this position in the FP table.
  *                            If 0, start from the very first FP rule in the table.
  * @param[in]  count          Print only this count of FP rules, then end.
  *                            If 0, keep printing FP rules till the end of the table.
- * @return     FPP_ERR_OK : Successfully iterated through FP rules of the given FP table.
- *             other      : Some error occured (represented by the respective error code).
+ * @return     FPP_ERR_OK : Successfully iterated through all FP rules of the given FP table.
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, 
-                       const char* p_table_name, uint16_t position_init, uint16_t count)
+int demo_fp_table_print(FCI_CLIENT* p_cl, demo_fp_rule_cb_print_t p_cb_print, 
+                        const char* p_table_name, uint16_t position_init, uint16_t count)
 {
     assert(NULL != p_cl);
     assert(NULL != p_cb_print);
     assert(NULL != p_table_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fp_table_cmd_t cmd_to_fci = {0};
     fpp_fp_table_cmd_t reply_from_fci = {0};
@@ -552,7 +601,7 @@ int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
         count--;  /* WARNING: intentional use of owf behavior */
     }
     
-    /*  do the query  */
+    /* do the query */
     if (FPP_ERR_OK == rtn)
     {
         /* start query process */
@@ -560,7 +609,6 @@ int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
         rtn = fci_query(p_cl, FPP_CMD_FP_TABLE,
                         sizeof(fpp_fp_table_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_rule_props(&(reply_from_fci.table_info.r));  /* set correct byte order */
     
         /* query loop */
         uint16_t position = 0u;
@@ -568,7 +616,8 @@ int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
         {
             if (position >= position_init)
             {
-                rtn = p_cb_print(&(reply_from_fci.table_info.r), position);
+                const fpp_fp_rule_cmd_t tmp_rule = {0u, (reply_from_fci.table_info.r)};
+                rtn = p_cb_print(&tmp_rule, position);
                 count--;
             }
             
@@ -580,7 +629,6 @@ int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
                 rtn = fci_query(p_cl, FPP_CMD_FP_TABLE,
                                 sizeof(fpp_fp_table_cmd_t), (unsigned short*)(&cmd_to_fci),
                                 &reply_length, (unsigned short*)(&reply_from_fci));
-                ntoh_rule_props(&(reply_from_fci.table_info.r));  /* set correct byte order */
             }
         }
         
@@ -592,35 +640,36 @@ int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
         }
     }
     
+    print_if_error(rtn, "demo_fp_table_print() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief      Use FCI calls to iterate through all existing FP rules in the PFE (regardless
- *             of table affiliation). Execute a print function for each reported FP rule.
- * @param[in]  p_cl           FCI client instance
+ * @brief      Use FCI calls to iterate through all available FP rules in PFE (regardless
+ *             of table affiliation). Execute a print function for each applicable FP rule.
+ * @param[in]  p_cl           FCI client
  * @param[in]  p_cb_print     Callback print function.
- *                            --> If the callback returns zero, then all is OK and 
- *                                the next FP rule is picked for a print process.
- *                            --> If the callback returns non-zero, then some problem is 
+ *                            --> If the callback returns ZERO, then all is OK and 
+ *                                a next FP rule is picked for a print process.
+ *                            --> If the callback returns NON-ZERO, then some problem is 
  *                                assumed and this function terminates prematurely.
- * @param[in]  idx_init       Start invoking callback print function from 
+ * @param[in]  idx_init       Start invoking a callback print function from 
  *                            this index of FP rule query.
  *                            If 0, start from the very first queried FP rule.
  * @param[in]  count          Print only this count of FP rules, then end.
  *                            If 0, keep printing FP rules till there is no more available.
- * @return     FPP_ERR_OK : Successfully iterated through FP rules.
- *             other      : Some error occured (represented by the respective error code).
+ * @return     FPP_ERR_OK : Successfully iterated through all available FP rules.
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, 
-                          uint16_t idx_init, uint16_t count)
+int demo_fp_rule_print_all(FCI_CLIENT* p_cl, demo_fp_rule_cb_print_t p_cb_print, 
+                           uint16_t idx_init, uint16_t count)
 {
     assert(NULL != p_cl);
     assert(NULL != p_cb_print);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fp_rule_cmd_t cmd_to_fci = {0};
     fpp_fp_rule_cmd_t reply_from_fci = {0};
@@ -637,7 +686,6 @@ int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
     rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
                     sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
                     &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order */
 
     /* query loop */
     uint16_t idx = 0u;
@@ -645,7 +693,7 @@ int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
     {
         if (idx >= idx_init)
         {
-            rtn = p_cb_print(&(reply_from_fci.r), idx);
+            rtn = p_cb_print(&reply_from_fci, idx);
             count--;
         }
         
@@ -657,7 +705,6 @@ int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
             rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
                             sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
                             &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_rule_props(&(reply_from_fci.r));  /* set correct byte order */
         }
     }
     
@@ -668,39 +715,39 @@ int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print,
         rtn = FPP_ERR_OK;
     }
     
+    print_if_error(rtn, "demo_fp_rule_print_all() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief       Use FCI calls to get a count of all FP rules in the PFE (regardless
+ * @brief       Use FCI calls to get a count of all available FP rules in PFE (regardless
  *              of table affiliation).
  * @param[in]   p_cl         FCI client instance
  * @param[out]  p_rtn_count  Space to store the count of FP rules.
- * @return      FPP_ERR_OK : Successfully counted FP rules.
+ * @return      FPP_ERR_OK : Successfully counted all available FP rules.
  *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  *                           No count was stored.
  */
-int fci_fp_rule_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+int demo_fp_rule_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_count);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fp_rule_cmd_t cmd_to_fci = {0};
     fpp_fp_rule_cmd_t reply_from_fci = {0};
     unsigned short reply_length = 0u;
-    uint16_t count = 0u;
+    uint32_t count = 0u;
         
     /* start query process */
     cmd_to_fci.action = FPP_ACTION_QUERY;
     rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
                     sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
                     &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting FP rules) */
     
     /* query loop */
     while (FPP_ERR_OK == rtn)
@@ -711,7 +758,6 @@ int fci_fp_rule_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
         rtn = fci_query(p_cl, FPP_CMD_FP_RULE,
                         sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting FP rules) */
     }
     
     /* query loop runs till there are no more FP rules to report */
@@ -722,6 +768,8 @@ int fci_fp_rule_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
         rtn = FPP_ERR_OK;
     }
     
+    print_if_error(rtn, "demo_fp_rule_get_count() failed!");
+    
     return (rtn);
 }
  
diff --git a/sw/libfci_cli/src/libfci_demo/demo_fp.h b/sw/libfci_cli/src/libfci_demo/demo_fp.h
new file mode 100644
index 0000000..d2fb8a9
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_fp.h
@@ -0,0 +1,89 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+
+#ifndef DEMO_FP_H_
+#define DEMO_FP_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*demo_fp_rule_cb_print_t)(const fpp_fp_rule_cmd_t* p_rule, uint16_t position);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+
+int demo_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule, uint16_t* p_rtn_idx, const char* p_rule_name);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+
+int demo_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name, const fpp_fp_rule_cmd_t* p_rule_data);
+int demo_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name);
+
+int demo_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name);
+int demo_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name);
+int demo_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name, const char* p_rule_name, uint16_t position);
+int demo_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name, const char* p_rule_name);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+void demo_fp_rule_ld_set_data(fpp_fp_rule_cmd_t* p_rule, uint32_t data);
+void demo_fp_rule_ld_set_mask(fpp_fp_rule_cmd_t* p_rule, uint32_t mask);
+void demo_fp_rule_ld_set_offset(fpp_fp_rule_cmd_t* p_rule, uint16_t offset, fpp_fp_offset_from_t offset_from);
+void demo_fp_rule_ld_set_invert(fpp_fp_rule_cmd_t* p_rule, bool invert);
+void demo_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule, fpp_fp_rule_match_action_t match_action,
+                                      const char* p_next_rule_name);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool demo_fp_rule_ld_is_invert(const fpp_fp_rule_cmd_t* p_rule);
+
+const char* demo_fp_rule_ld_get_name(const fpp_fp_rule_cmd_t* p_rule);
+const char* demo_fp_rule_ld_get_next_name(const fpp_fp_rule_cmd_t* p_rule);
+uint32_t    demo_fp_rule_ld_get_data(const fpp_fp_rule_cmd_t* p_rule);
+uint32_t    demo_fp_rule_ld_get_mask(const fpp_fp_rule_cmd_t* p_rule);
+uint16_t    demo_fp_rule_ld_get_offset(const fpp_fp_rule_cmd_t* p_rule);
+fpp_fp_offset_from_t demo_fp_rule_ld_get_offset_from(const fpp_fp_rule_cmd_t* p_rule);
+fpp_fp_rule_match_action_t demo_fp_rule_ld_get_match_action(const fpp_fp_rule_cmd_t* p_rule);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int demo_fp_table_print(FCI_CLIENT* p_cl, demo_fp_rule_cb_print_t p_cb_print, const char* p_table_name,
+                        uint16_t position_init, uint16_t count);
+                        
+int demo_fp_rule_print_all(FCI_CLIENT* p_cl, demo_fp_rule_cb_print_t p_cb_print, uint16_t idx_init, uint16_t count);
+int demo_fp_rule_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fwfeat.c b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.c
similarity index 56%
rename from sw/libfci_cli/src/libfci_interface/fci_fwfeat.c
rename to sw/libfci_cli/src/libfci_demo/demo_fwfeat.c
index a87d5b0..6636c86 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_fwfeat.c
+++ b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.c
@@ -30,44 +30,45 @@
  
  
 #include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
 #include <string.h>
 #include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
 #include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
-#include "fci_common.h"
-#include "fci_fwfeat.h"
- 
  
-/* ==== PRIVATE FUNCTIONS ================================================== */
+#include "demo_common.h"
+#include "demo_fwfeat.h"
  
-/* empty */
  
 /* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
  
  
 /*
  * @brief       Use FCI calls to get configuration data of a requested FW feature
- *              from the PFE. Identify the FW feature by its name.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_fwfeat Space for data from the PFE.
+ *              from PFE. Identify the FW feature by its name.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_fwfeat Space for data from PFE.
  * @param[in]   p_name       Name of the requested FW feature.
- * @return      FPP_ERR_OK : Requested FW feature was found.
- *                           A copy of its configuration was stored into p_rtn_fwfeat.
- *              other      : Some error occured (represented by the respective error code).
+ *                           Names of FW features are hardcoded.
+ *                           Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                           available FW features (and their names) from PFE.
+ *                           See demo_fwfeat_print_all().
+ * @return      FPP_ERR_OK : The requested FW feature was found.
+ *                           A copy of its configuration data was stored into p_rtn_fwfeat.
+ *              other      : Some error occurred (represented by the respective error code).
  *                           No data copied.
  */
-int fci_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, 
-                           const char* p_name)
+int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, 
+                            const char* p_name)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_fwfeat);
     assert(NULL != p_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fw_features_cmd_t cmd_to_fci = {0};
     fpp_fw_features_cmd_t reply_from_fci = {0};
@@ -79,7 +80,7 @@ int fci_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat
                         sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
     
-    /* query loop (with the search condition) */
+    /* query loop (with a search condition) */
     while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
     {
         cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
@@ -88,34 +89,39 @@ int fci_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat
                         &reply_length, (unsigned short*)(&reply_from_fci));
     }
     
-    /* if search successful, then assign the data */
+    /* if a query is successful, then assign the data */
     if (FPP_ERR_OK == rtn)
     {
         *p_rtn_fwfeat = reply_from_fci;
     }
     
+    print_if_error(rtn, "demo_fwfeat_get_by_name() failed!");
+    
     return (rtn);
 }
  
  
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
  
  
 /*
- * @brief      Use FCI calls to enable/disable a target FW feature in the PFE.
- * @param[in]  p_cl     FCI client instance
- * @param[in]  p_name   Name of the requested FW feature.
- * @param[in]  enable   A request to set/unset the FW feature.
- * @return     FPP_ERR_OK : FW feature was successfully enabled/disabled in the PFE.
- *             other      : Some error occured (represented by the respective error code).
+ * @brief      Use FCI calls to enable/disable a target FW feature in PFE.
+ * @param[in]  p_cl     FCI client
+ * @param[in]  p_name   Name of a FW feature.
+ *                      Names of FW features are hardcoded.
+ *                      Use FPP_ACTION_QUERY+FPP_ACTION_QUERY_CONT to get a list of
+ *                      available FW features (and their names) from PFE.
+ *                      See demo_fwfeat_print_all().
+ * @param[in]  enable   Request to set/unset the FW feature.
+ * @return     FPP_ERR_OK : FW feature was successfully enabled/disabled in PFE.
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable)
+int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable)
 {
     assert(NULL != p_cl);
     assert(NULL != p_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_fw_features_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
@@ -133,32 +139,114 @@ int fci_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable)
                                                  (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_fwfeat_set() failed!");
+    
     return (rtn);
 }
  
  
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+/*
+ * @defgroup    localdata_fwfeat  [localdata_fwfeat]
+ * @brief:      Functions marked as [localdata_fwfeat] access only local data. 
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_fwfeat (a struct with configuration data).
+ *              Initial data for p_fwfeat can be obtained via demo_fwfeat_get_by_name().
+ */
+ 
+ 
+/*
+ * @brief      Query the current status of a FW feature.
+ * @details    [localdata_fwfeat]
+ * @param[in]  p_fwfeat  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the FW feature:
+ *             true  : was enabled
+ *             false : was disabled
+ */
+bool demo_fwfeat_ld_is_enabled(const fpp_fw_features_cmd_t* p_fwfeat)
+{
+    assert(NULL != p_fwfeat);
+    return (bool)(p_fwfeat->val);
+}
+ 
+ 
+/*
+ * @brief      Query the default status of a FW feature.
+ * @details    [localdata_fwfeat]
+ * @param[in]  p_fwfeat  Local data to be queried.
+ * @return     By default, the FW feature:
+ *             true  : is initially enabled
+ *             false : is initially disabled
+ */
+bool demo_fwfeat_ld_is_enabled_by_def(const fpp_fw_features_cmd_t* p_fwfeat)
+{
+    assert(NULL != p_fwfeat);
+    return (bool)(p_fwfeat->def_val);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the name of a FW feature.
+ * @details    [localdata_fwfeat]
+ * @param[in]  p_fwfeat  Local data to be queried.
+ * @return     Name of the FW feature.
+ */
+const char* demo_fwfeat_ld_get_name(const fpp_fw_features_cmd_t* p_fwfeat)
+{
+    assert(NULL != p_fwfeat);
+    return (p_fwfeat->name);
+}
+ 
+ 
+/*
+ * @brief      Query the description text of a FW feature.
+ * @details    [localdata_fwfeat]
+ * @param[in]  p_fwfeat  Local data to be queried.
+ * @return     Description text of the FW feature.
+ */
+const char* demo_fwfeat_ld_get_desc(const fpp_fw_features_cmd_t* p_fwfeat)
+{
+    assert(NULL != p_fwfeat);
+    return (p_fwfeat->desc);
+}
+ 
+ 
+/*
+ * @brief      Query the variant of a FW feature.
+ * @details    [localdata_fwfeat]
+ * @param[in]  p_fwfeat  Local data to be queried.
+ * @return     Variant of a FW feature (always disabled / always enabled / configurable).
+ */
+uint8_t demo_fwfeat_ld_get_variant(const fpp_fw_features_cmd_t* p_fwfeat)
+{
+    assert(NULL != p_fwfeat);
+    return (p_fwfeat->variant);
+}
+ 
+ 
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
  
  
 /*
- * @brief      Use FCI calls to iterate through all FW features in the PFE and
+ * @brief      Use FCI calls to iterate through all available FW features in PFE and
  *             execute a callback print function for each reported FW feature.
- * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cl        FCI client
  * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next FW feature is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next FW feature is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
  *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through FW features.
- *             other      : Some error occured (represented by the respective error code).
+ * @return     FPP_ERR_OK : Successfully iterated through all available FW features.
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_fwfeat_print_all(FCI_CLIENT* p_cl, fci_fwfeat_cb_print_t p_cb_print)
+int demo_fwfeat_print_all(FCI_CLIENT* p_cl, demo_fwfeat_cb_print_t p_cb_print)
 {
     assert(NULL != p_cl);
     assert(NULL != p_cb_print);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fw_features_cmd_t cmd_to_fci = {0};
     fpp_fw_features_cmd_t reply_from_fci = {0};
@@ -191,31 +279,32 @@ int fci_fwfeat_print_all(FCI_CLIENT* p_cl, fci_fwfeat_cb_print_t p_cb_print)
         rtn = FPP_ERR_OK;
     }
     
+    print_if_error(rtn, "demo_fwfeat_print_all() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief       Use FCI calls to get a count of all FW features in the PFE.
- * @param[in]   p_cl         FCI client instance
+ * @brief       Use FCI calls to get a count of all available FW features in PFE.
+ * @param[in]   p_cl         FCI client
  * @param[out]  p_rtn_count  Space to store the count of FW features.
- * @return      FPP_ERR_OK : Successfully counted FW features.
+ * @return      FPP_ERR_OK : Successfully counted all available FW features.
  *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  *                           No count was stored.
  */
-int fci_fwfeat_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
+int demo_fwfeat_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_count);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_fw_features_cmd_t cmd_to_fci = {0};
     fpp_fw_features_cmd_t reply_from_fci = {0};
     unsigned short reply_length = 0u;
-    uint16_t count = 0u;
+    uint32_t count = 0u;
         
     /* start query process */
     cmd_to_fci.action = FPP_ACTION_QUERY;
@@ -242,6 +331,8 @@ int fci_fwfeat_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
         rtn = FPP_ERR_OK;
     }
     
+    print_if_error(rtn, "demo_fwfeat_get_count() failed!");
+    
     return (rtn);
 }
  
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fwfeat.h b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.h
similarity index 63%
rename from sw/libfci_cli/src/libfci_interface/fci_fwfeat.h
rename to sw/libfci_cli/src/libfci_demo/demo_fwfeat.h
index c48076d..4dfc11d 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_fwfeat.h
+++ b/sw/libfci_cli/src/libfci_demo/demo_fwfeat.h
@@ -28,28 +28,40 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * ========================================================================= */
 
-#ifndef FCI_SPD_H_
-#define FCI_SPD_H_
+#ifndef DEMO_FWFEAT_H_
+#define DEMO_FWFEAT_H_
 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
 
 /* ==== TYPEDEFS & DATA ==================================================== */
 
-typedef int (*fci_fwfeat_cb_print_t)(const fpp_fw_features_cmd_t* p_fwfeat);
+typedef int (*demo_fwfeat_cb_print_t)(const fpp_fw_features_cmd_t* p_fwfeat);
 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
 
-int fci_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, const char* p_name);
+int demo_fwfeat_get_by_name(FCI_CLIENT* p_cl, fpp_fw_features_cmd_t* p_rtn_fwfeat, const char* p_name);
 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
 
-int fci_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable);
+int demo_fwfeat_set(FCI_CLIENT* p_cl, const char* p_name, bool enable);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool demo_fwfeat_ld_is_enabled(const fpp_fw_features_cmd_t* p_fwfeat);
+bool demo_fwfeat_ld_is_enabled_by_def(const fpp_fw_features_cmd_t* p_fwfeat);
+
+const char* demo_fwfeat_ld_get_name(const fpp_fw_features_cmd_t* p_fwfeat);
+const char* demo_fwfeat_ld_get_desc(const fpp_fw_features_cmd_t* p_fwfeat);
+uint8_t     demo_fwfeat_ld_get_variant(const fpp_fw_features_cmd_t* p_fwfeat);
 
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
 
-int fci_fwfeat_print_all(FCI_CLIENT* p_cl, fci_fwfeat_cb_print_t p_cb_print);
-int fci_fwfeat_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
+int demo_fwfeat_print_all(FCI_CLIENT* p_cl, demo_fwfeat_cb_print_t p_cb_print);
+int demo_fwfeat_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
 
 /* ========================================================================= */
 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_l2_bd.c b/sw/libfci_cli/src/libfci_demo/demo_l2_bd.c
new file mode 100644
index 0000000..bc014e2
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_l2_bd.c
@@ -0,0 +1,1220 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <string.h>
+#include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+
+#include "demo_common.h" 
+#include "demo_l2_bd.h"
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested bridge domain
+ *              from PFE. Identify the domain by its VLAN ID.
+ * @param[in]   p_cl      FCI client
+ * @param[out]  p_rtn_bd  Space for data from PFE.
+ * @param[in]   vlan      VLAN ID of the requested bridge domain.
+ * @return      FPP_ERR_OK : The requested bridge domain was found.
+ *                           A copy of its configuration data was stored into p_rtn_bd.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_l2_bd_get_by_vlan(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_bd);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    fpp_l2_bd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) && (ntohs(reply_from_fci.vlan) != vlan))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                        sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_bd = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_l2_bd_get_by_vlan() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested static entry
+ *              from PFE. Identify the entry by VLAN ID of the parent bridge domain and
+ *              by MAC address of the entry.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_stent  Space for data from PFE.
+ * @param[in]   vlan         VLAN ID of the parent bridge domain.
+ * @param[in]   p_mac        MAC address of the requested static entry.
+ * @return      FPP_ERR_OK : The requested static entry was found.
+ *                           A copy of its configuration data was stored into p_rtn_stent.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_l2_stent_get_by_vlanmac(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
+                                 uint16_t vlan, const uint8_t p_mac[6])
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_stent);
+    assert(NULL != p_mac);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) &&
+            !(
+                (ntohs(reply_from_fci.vlan) == vlan) &&
+                (0 == memcmp((reply_from_fci.mac), p_mac, 6))
+             )
+          )
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                        sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_stent = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_l2_stent_get_by_vlanmac() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target bridge domain
+ *                 in PFE.
+ * @param[in]      p_cl  FCI client
+ * @param[in,out]  p_bd  Local data struct which represents a new configuration of 
+ *                       the target bridge domain.
+ *                       It is assumed that the struct contains a valid data of some 
+ *                       bridge domain.
+ * @return        FPP_ERR_OK : Configuration of the target bridge domain was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             The local data struct was not updated.
+ */
+int demo_l2_bd_update(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_bd);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_l2_bd_cmd_t cmd_to_fci = (*p_bd);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_bd_get_by_vlan(p_cl, p_bd, ntohs(p_bd->vlan));
+    }
+    
+    print_if_error(rtn, "demo_l2_bd_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target static entry
+ *                 in PFE.
+ * @param[in]      p_cl     FCI client
+ * @param[in,out]  p_stent  Local data struct which represents a new configuration of 
+ *                          the target static entry.
+ *                          It is assumed that the struct contains a valid data of some 
+ *                          static entry.
+ * @return        FPP_ERR_OK : Configuration of the target static entry was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             Local data struct not updated.
+ */
+int demo_l2_stent_update(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_stent);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_l2_static_ent_cmd_t cmd_to_fci = (*p_stent);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t), 
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_l2_stent_get_by_vlanmac(p_cl, p_stent, 
+                                           ntohs(p_stent->vlan), (p_stent->mac));
+    }
+    
+    print_if_error(rtn, "demo_l2_stent_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief         Use FCI calls to flush static entries from MAC tables of 
+ *                all bridge domains in PFE.
+ * @param[in]     p_cl  FCI client
+ * @return        FPP_ERR_OK : Static MAC table entries of all bridge domains were 
+ *                             successfully flushed in PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_flush_static(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    int rtn = fci_write(p_cl, FPP_CMD_L2_FLUSH_STATIC, 0u, NULL);
+    print_if_error(rtn, "demo_l2_flush_static() failed!");
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief         Use FCI calls to flush dynamically learned entries from MAC tables of
+ *                all bridge domains in PFE.
+ * @param[in]     p_cl  FCI client
+ * @return        FPP_ERR_OK : Learned MAC table entries of all bridge domains were
+ *                             successfully flushed in the PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_flush_learned(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    int rtn = fci_write(p_cl, FPP_CMD_L2_FLUSH_LEARNED, 0u, NULL);
+    print_if_error(rtn, "demo_l2_flush_learned() failed!");
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief         Use FCI calls to flush all entries from MAC tables of 
+ *                all bridge domains in PFE.
+ * @param[in]     p_cl  FCI client
+ * @return        FPP_ERR_OK : All MAC table entries of all bridge domains were
+ *                             successfully flushed in the PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_flush_all(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    int rtn = fci_write(p_cl, FPP_CMD_L2_FLUSH_ALL, 0u, NULL);
+    print_if_error(rtn, "demo_l2_flush_all() failed!");
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new bridge domain in PFE.
+ * @param[in]   p_cl      FCI client
+ * @param[out]  p_rtn_if  Space for data from PFE.
+ *                        This will contain a copy of configuration data of 
+ *                        the newly created bridge domain.
+ *                        Can be NULL. If NULL, then there is no local data to fill.
+ * @param[in]   vlan      VLAN ID of the new bridge domain.
+ * @return      FPP_ERR_OK : New bridge domain was created.
+ *                           If applicable, then its configuration data were 
+ *                           copied into p_rtn_bd.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_l2_bd_add(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    /* 'p_rtn_bd' is allowed to be NULL */
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = htons(vlan);
+    cmd_to_fci.ucast_hit  = 3u;  /* 3 == discard */
+    cmd_to_fci.ucast_miss = 3u;  /* 3 == discard */
+    cmd_to_fci.mcast_hit  = 3u;  /* 3 == discard */
+    cmd_to_fci.mcast_miss = 3u;  /* 3 == discard */
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data (if applicable) */
+    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_bd))
+    {
+        rtn = demo_l2_bd_get_by_vlan(p_cl, p_rtn_bd, vlan);
+    }
+    
+    print_if_error(rtn, "demo_l2_bd_add() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target bridge domain in PFE.
+ * @param[in]  p_cl    FCI client
+ * @param[in]  vlan    VLAN ID of the bridge domain to destroy.
+ *                     NOTE: Bridge domains marked as "default" or "fallback" 
+ *                           cannot be destroyed.
+ * @return     FPP_ERR_OK : The bridge domain was destroyed.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_bd_del(FCI_CLIENT* p_cl, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = htons(vlan);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_l2_bd_del() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new static entry in PFE.
+ *              The new entry is associated with a provided parent bridge domain.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_stent  Space for data from PFE.
+ *                           This will contain a copy of configuration data of 
+ *                           the newly created static entry.
+ *                           Can be NULL. If NULL, then there is no local data to fill.
+ * @param[in]   vlan         VLAN ID of the parent bridge domain.
+ * @param[in]   p_mac        MAC address of the new static entry.
+ * @return      FPP_ERR_OK : New static entry was created.
+ *                           If applicable, then its configuration data were 
+ *                           copied into p_rtn_stent.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_l2_stent_add(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
+                      uint16_t vlan, const uint8_t p_mac[6])
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_mac);
+    /* 'p_rtn_stent' is allowed to be NULL */
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = htons(vlan);
+    memcpy(cmd_to_fci.mac, p_mac, 6);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t),
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data (if applicable) */
+    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_stent))
+    {
+        rtn = demo_l2_stent_get_by_vlanmac(p_cl, p_rtn_stent, vlan, p_mac);
+    }
+    
+    print_if_error(rtn, "demo_l2_stent_add() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target static entry in PFE.
+ * @param[in]  p_cl    FCI client
+ * @param[in]  vlan    VLAN ID of the parent bridge domain.
+ * @param[in]  p_mac   MAC address of the static entry to destroy.
+ * @return     FPP_ERR_OK : The static entry was destroyed.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_stent_del(FCI_CLIENT* p_cl, uint16_t vlan, const uint8_t p_mac[6])
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_mac);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.vlan = htons(vlan);
+    memcpy(cmd_to_fci.mac, p_mac, 6);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t),
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_l2_stent_del() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_bd  [localdata_bd]
+ * @brief:      Functions marked as [localdata_bd] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_bd (a struct with configuration data).
+ *              Initial data for p_bd can be obtained via demo_l2_bd_get_by_vlan().
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call demo_l2_bd_update() to update 
+ *              the configuration of a real bridge domain in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set action to be done if unicast packet's destination MAC is
+ *                 found (hit) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd         Local data to be modified.
+ * @param[in]      hit_action   New action.
+ *                              For details about bridge domain hit/miss actions,
+ *                              see a description of the ucast_hit in FCI API Reference.
+ */
+void demo_l2_bd_ld_set_ucast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t hit_action)
+{
+    assert(NULL != p_bd);
+    p_bd->ucast_hit = hit_action;
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if unicast packet's destination MAC is NOT
+ *                 found (miss) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd         Local data to be modified.
+ * @param[in]      miss_action  New action.
+ *                              For details about bridge domain hit/miss actions,
+ *                              see a description of the ucast_hit in FCI API Reference.
+ */
+void demo_l2_bd_ld_set_ucast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t miss_action)
+{
+    assert(NULL != p_bd);
+    p_bd->ucast_miss = miss_action;
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if multicast packet's destination MAC is 
+ *                 found (hit) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd         Local data to be modified.
+ * @param[in]      hit_action   New action.
+ *                              For details about bridge domain hit/miss actions,
+ *                              see a description of the ucast_hit in FCI API Reference.
+ */
+void demo_l2_bd_ld_set_mcast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t hit_action)
+{
+    assert(NULL != p_bd);
+    p_bd->mcast_hit = hit_action;
+}
+ 
+ 
+/*
+ * @brief          Set action to be done if multicast packet's destination MAC is NOT
+ *                 found (miss) in a bridge domain's MAC table.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd         Local data to be modified.
+ * @param[in]      hit_action   New action.
+ *                              For details about bridge domain hit/miss actions,
+ *                              see a description of the ucast_hit in FCI API Reference.
+ */
+void demo_l2_bd_ld_set_mcast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t miss_action)
+{
+    assert(NULL != p_bd);
+    p_bd->mcast_miss = miss_action;
+}
+ 
+ 
+/*
+ * @brief          Insert a physical interface into a bridge domain.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd      Local data to be modified.
+ * @param[in]      phyif_id  ID of the physical interface.
+ *                           IDs of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ * @param[in]      vlan_tag  Request to add/keep a VLAN tag (true) or to remove 
+ *                           the VLAN tag (false) of a traffic egressed through
+ *                           the given physical interface.
+ */
+void demo_l2_bd_ld_insert_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id, bool vlan_tag)
+{
+    assert(NULL != p_bd);
+    
+    if (32uL > phyif_id)  /* a check to prevent an undefined behavior */
+    {
+        const uint32_t phyif_bitmask = (1uL << phyif_id);
+        
+        p_bd->if_list |= htonl(phyif_bitmask);
+        
+        if (vlan_tag)
+        {
+            /* VLAN TAG is desired == physical interface must NOT be on the untag list. */
+            p_bd->untag_if_list &= htonl((uint32_t)(~phyif_bitmask));
+        }
+        else
+        {
+            /* VLAN TAG is NOT desired == physical interface must BE on the untag list. */
+            p_bd->untag_if_list |= htonl(phyif_bitmask);
+        }
+    }
+}
+ 
+ 
+/*
+ * @brief          Remove a physical interface from a bridge domain.
+ * @details        [localdata_bd]
+ * @param[in,out]  p_bd      Local data to be modified.
+ * @param[in]      phyif_id  ID of the physical interface.
+ *                           IDs of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ */
+void demo_l2_bd_ld_remove_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
+{
+    assert(NULL != p_bd);
+    
+    if (32uL > phyif_id)  /* a check to prevent an undefined behavior */
+    {
+        const uint32_t phyif_bitmask = (1uL << phyif_id);
+        p_bd->if_list &= htonl((uint32_t)(~phyif_bitmask));
+    }
+}
+ 
+ 
+ 
+ 
+/*
+ * @defgroup    localdata_stent  [localdata_stent]
+ * @brief:      Functions marked as [localdata_stent] acess only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_stent (a struct with configuration data).
+ *              Initial data for p_stent can be obtained via demo_l2_stent_get_by_vlanmac().
+ *              If some local data modifications are made, then after all local data changes
+ *              are done and finished, call demo_l2_stent_update() to update 
+ *              the configuration of a real static entry in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set target physical interfaces (forwarding list) which 
+ *                 shall receive a copy of the accepted traffic.
+ * @details        [localdata_stent]
+ *                 New forwarding list fully replaces the old one.
+ * @param[in,out]  p_stent  Local data to be modified.
+ * @param[in]      fwlist   Target physical interfaces (forwarding list). A bitset.
+ *                          Each physical interface is represented by one bit.
+ *                          Conversion between physical interface ID and a corresponding
+ *                          fwlist bit is (1uL << "ID of a target physical interface").
+ */
+void demo_l2_stent_ld_set_fwlist(fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist)
+{
+    assert(NULL != p_stent);
+    p_stent->forward_list = htonl(fwlist);
+}
+ 
+ 
+/*
+ * @brief          Set/unset 'local' flag of a static entry.
+ * @details        [localdata_stent]
+ *                 Related to L2L3 Bridge feature (see FCI API Reference).
+ * @param[in,out]  p_stent  Local data to be modified.
+ * @param[in]      set      Request to set/unset the flag.
+ *                          See description of the fpp_l2_static_ent_cmd_t type 
+ *                          in FCI API reference.
+ */
+void demo_l2_stent_ld_set_local(fpp_l2_static_ent_cmd_t* p_stent, bool set)
+{
+    assert(NULL != p_stent);
+    p_stent->local = set;  /* NOTE: implicit cast from bool to uint8_t */
+}
+ 
+ 
+/*
+ * @brief          Set/unset a flag for a frame discarding feature tied with a static entry.
+ * @details        [localdata_stent]
+ * @param[in,out]  p_stent  Local data to be modified.
+ * @param[in]      set      Request to set/unset the flag.
+ *                          See description of fpp_l2_static_ent_cmd_t type
+ *                          in FCI API reference.
+ */
+void demo_l2_stent_ld_set_src_discard(fpp_l2_static_ent_cmd_t* p_stent, bool set)
+{
+    assert(NULL != p_stent);
+    p_stent->src_discard = set;  /* NOTE: implicit cast from bool to uint8_t */
+}
+ 
+ 
+/*
+ * @brief          Set/unset a flag for a frame discarding feature tied with a static entry.
+ * @details        [localdata_stent]
+ * @param[in,out]  p_stent  Local data to be modified.
+ * @param[in]      set      Request to set/unset the flag.
+ *                          See description of fpp_l2_static_ent_cmd_t type
+ *                          in FCI API reference.
+ */
+void demo_l2_stent_ld_set_dst_discard(fpp_l2_static_ent_cmd_t* p_stent, bool set)
+{
+    assert(NULL != p_stent);
+    p_stent->dst_discard = set;  /* NOTE: implicit cast from bool to uint8_t */
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query status of a "default" flag.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the bridge domain:
+ *             true  : was set as a default domain.
+ *             false : was NOT set as a default domain.
+ */
+bool demo_l2_bd_ld_is_default(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    
+    fpp_l2_bd_flags_t tmp_flags = (p_bd->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_l2_bd_flags_t));
+    
+    return (bool)(tmp_flags & FPP_L2_BD_DEFAULT);
+}
+ 
+ 
+/*
+ * @brief      Query status of a "fallback" flag.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the bridge domain:
+ *             true  : was set as a fallback domain.
+ *             false : was NOT set as a fallback domain.
+ */
+bool demo_l2_bd_ld_is_fallback(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    
+    fpp_l2_bd_flags_t tmp_flags = (p_bd->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_l2_bd_flags_t));
+    
+    return (bool)(tmp_flags & FPP_L2_BD_FALLBACK);
+}
+ 
+ 
+/*
+ * @brief      Query whether a physical interface is a member of a bridge domain.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd      Local data to be queried.
+ * @param[in]  phyif_id  ID of the physical interface.
+ *                       IDs of physical interfaces are hardcoded.
+ *                       See FCI API Reference, chapter Interface Management.
+ * @return     At time when the data was obtained from PFE, the requested physical interface:
+ *             true  : was a member of the given bridge domain.
+ *             false : was NOT a member of the given bridge domain.
+ */
+bool demo_l2_bd_ld_has_phyif(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
+{
+    assert(NULL != p_bd);
+    
+    bool rtn = false;
+    
+    if (32uL > phyif_id)
+    {
+        const uint32_t phyif_bitmask = (1uL << phyif_id);
+        rtn = (bool)(ntohl(p_bd->if_list) & phyif_bitmask);
+    }
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Query whether traffic from a physical interface is tagged by a bridge domain.
+ *             This function returns meaningful results only if 
+ *             the target physical interface is a member of the bridge domain.
+ *             See demo_l2_bd_ld_has_phyif().
+ * @details    [localdata_bd]
+ * @param[in]  p_bd      Local data to be queried.
+ * @param[in]  phyif_id  ID of the physical interface.
+ *                       IDs of physical interfaces are hardcoded.
+ *                       See FCI API Reference, chapter Interface Management.
+ * @return     At time when the data was obtained from PFE, traffic from 
+ *             the requested physical interface:
+ *             true  : was being VLAN tagged by the given bridge domain.
+ *             false : was NOT being VLAN tagged by the given bridge domain.
+ */
+bool demo_l2_bd_ld_is_phyif_tagged(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
+{
+    assert(NULL != p_bd);
+    
+    bool rtn = false;
+    if (32uL > phyif_id)
+    {
+        /* untag_list uses inverted logic - if interface IS on the list, it is UNTAGGED */
+        const uint32_t phyif_bitmask = (1uL << phyif_id);
+        rtn = !(ntohl(p_bd->untag_if_list) & phyif_bitmask);
+    }
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the VLAN ID of a bridge domain.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     VLAN ID of the bridge domain.
+ */
+uint16_t demo_l2_bd_ld_get_vlan(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return ntohs(p_bd->vlan);
+}
+ 
+ 
+/*
+ * @brief      Query the bridge action which is executed on unicast hit.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Bridge action (see a description of the ucast_hit in FCI API Reference).
+ */
+uint8_t demo_l2_bd_ld_get_ucast_hit(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return (p_bd->ucast_hit);
+}
+ 
+ 
+/*
+ * @brief      Query the bridge action which is executed on unicast miss.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Bridge action (see a description of the ucast_hit in FCI API Reference).
+ */
+uint8_t demo_l2_bd_ld_get_ucast_miss(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return (p_bd->ucast_miss);
+}
+ 
+ 
+/*
+ * @brief      Query the bridge action which is executed on multicast hit.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Bridge action (see a description of the ucast_hit in FCI API Reference).
+ */
+uint8_t demo_l2_bd_ld_get_mcast_hit(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return (p_bd->mcast_hit);
+}
+ 
+ 
+/*
+ * @brief      Query the bridge action which is executed on multicast miss.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Bridge action (see a description of the ucast_hit in FCI API Reference).
+ */
+uint8_t demo_l2_bd_ld_get_mcast_miss(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return (p_bd->mcast_miss);
+}
+ 
+ 
+/*
+ * @brief      Query the list of member physical interfaces of a bridge domain.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Bitset with physical interfaces being represented as bits.
+ */
+uint32_t demo_l2_bd_ld_get_if_list(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return ntohl(p_bd->if_list);
+}
+ 
+ 
+/*
+ * @brief      Query the untag list of a bridge domain.
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Bitset with physical interfaces being represented as bits.
+ */
+uint32_t demo_l2_bd_ld_get_untag_if_list(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    return ntohl(p_bd->untag_if_list);
+}
+ 
+ 
+/*
+ * @brief      Query the flags of a bridge domain (the whole bitset).
+ * @details    [localdata_bd]
+ * @param[in]  p_bd  Local data to be queried.
+ * @return     Flags bitset.
+ */
+fpp_l2_bd_flags_t demo_l2_bd_ld_get_flags(const fpp_l2_bd_cmd_t* p_bd)
+{
+    assert(NULL != p_bd);
+    
+    fpp_l2_bd_flags_t tmp_flags = (p_bd->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_l2_bd_flags_t));
+    
+    return (tmp_flags);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query whether a physical interface is a member of 
+ *             a static entry's forwarding list.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @param[in]  fwlist_bitflag  Queried physical interface. A bitflag.
+ *                             Each physical interface is represented by one bit.
+ *                             Conversion between physical interface ID and a corresponding
+ *                             fwlist bit is (1uL << "ID of a target physical interface").
+ *                             Hint: It is recommended to always query only a single bitflag.
+ * @return     At time when the data was obtained from PFE, the static entry:
+ *             true  : had at least one queried forward list bitflag set
+ *             false : had none of the queried forward list bitflags set
+ */
+bool demo_l2_stent_ld_is_fwlist_phyifs(const fpp_l2_static_ent_cmd_t* p_stent,
+                                       uint32_t fwlist_bitflag)
+{
+    assert(NULL != p_stent);
+    return (bool)(ntohl(p_stent->forward_list) & fwlist_bitflag);
+}
+ 
+ 
+/*
+ * @brief      Query status of the "local" flag of a static entry.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the static entry:
+ *             true  : was set as local.
+ *             false : was NOT set as local.
+ */
+bool demo_l2_stent_ld_is_local(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_stent);
+    return (bool)(p_stent->local);
+}
+ 
+ 
+/*
+ * @brief      Query status of the "src_discard" flag of a static entry.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the static entry:
+ *             true  : was set to discard ETH frames with a matching source MAC.
+ *             false : was NOT set to discard ETH frames with a matching source MAC.
+ */
+bool demo_l2_stent_ld_is_src_discard(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_stent);
+    return (bool)(p_stent->src_discard);
+}
+ 
+ 
+/*
+ * @brief      Query status of the "dst_discard" flag of a static entry.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the static entry:
+ *             true  : was set to discard ETH frames with a matching destination MAC.
+ *             false : was NOT set to discard ETH frames with a matching destination MAC.
+ */
+bool demo_l2_stent_ld_is_dst_discard(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_stent);
+    return (bool)(p_stent->dst_discard);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the VLAN ID of a static entry.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @return     VLAN ID of the static entry.
+ */
+uint16_t demo_l2_stent_ld_get_vlan(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_stent);
+    return ntohs(p_stent->vlan);
+}
+ 
+ 
+/*
+ * @brief      Query the MAC address of a static entry.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @return     MAC address of the static entry.
+ */
+const uint8_t* demo_l2_stent_ld_get_mac(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_stent);
+    return (p_stent->mac);
+}
+ 
+ 
+/*
+ * @brief      Query the forwarding list (a bitset) of a static entry.
+ * @details    [localdata_stent]
+ * @param[in]  p_stent  Local data to be queried.
+ * @return     Bitset with physical interfaces being represented as bits.
+ */
+uint32_t demo_l2_stent_ld_get_fwlist(const fpp_l2_static_ent_cmd_t* p_stent)
+{
+    assert(NULL != p_stent);
+    return ntohl(p_stent->forward_list);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available bridge domains in PFE and
+ *             execute a callback print function for each bridge domain.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next bridge domain is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all available bridge domains.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_bd_print_all(FCI_CLIENT* p_cl, demo_l2_bd_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    fpp_l2_bd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                            sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more bridge domains to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_BD_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_l2_bd_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available bridge domains in PFE.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_count  Space to store the count of bridge domains.
+ * @return      FPP_ERR_OK : Successfully counted all available bridge domains.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No value copied.
+ */
+int demo_l2_bd_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_l2_bd_cmd_t cmd_to_fci = {0};
+    fpp_l2_bd_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_BD,
+                        sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more bridge domains to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_BD_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_l2_bd_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available static entries in PFE and
+ *             execute a callback print function for each applicable static entry.
+ * @param[in]  p_cl        FCI client instance
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next static entry is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]  by_vlan     [optional parameter]
+ *                          Request to print only those static entries
+ *                          which are associated with a particular bridge domain.
+ * @param[in]  vlan        [optional parameter]
+ *                          VLAN ID of a bridge domain.
+ *                          Applicable only if (true == by_vlan), otherwise ignored.
+ * @return     FPP_ERR_OK : Successfully iterated through all available static entries.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_l2_stent_print_all(FCI_CLIENT* p_cl, demo_l2_stent_cb_print_t p_cb_print, 
+                            bool by_vlan, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /*  query loop  */
+    while (FPP_ERR_OK == rtn)
+    {
+        if ((false == by_vlan) ||
+            ((true == by_vlan) && (ntohs(reply_from_fci.vlan) == vlan)))
+        {
+            rtn = p_cb_print(&reply_from_fci);
+        }
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more static entries to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_l2_stent_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all applicable static entries in PFE.
+ * @param[in]   p_cl         FCI client instance
+ * @param[out]  p_rtn_count  Space to store the count of static entries.
+ * @param[in]   by_vlan     [optional parameter]
+ *                           Request to count only those static entries
+ *                           which are associated with a particular bridge domain.
+ * @param[in]   vlan        [optional parameter]
+ *                           VLAN ID of a bridge domain.
+ *                           Applicable only if (true == by_vlan), otherwise ignored.
+ * @return      FPP_ERR_OK : Successfully counted all applicable static entries.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No value copied.
+ */
+int demo_l2_stent_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                            bool by_vlan, uint16_t vlan)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
+    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint16_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if ((false == by_vlan) ||
+            ((true == by_vlan) && (ntohs(reply_from_fci.vlan) == vlan)))
+        {
+            count++;
+        }
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
+                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more static entries to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_l2_stent_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_l2_bd.h b/sw/libfci_cli/src/libfci_demo/demo_l2_bd.h
new file mode 100644
index 0000000..2f92262
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_l2_bd.h
@@ -0,0 +1,126 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+#ifndef DEMO_L2_BD_H_
+#define DEMO_L2_BD_H_
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+/* ==== TYPEDEFS & DATA ==================================================== */
+ 
+typedef int (*demo_l2_bd_cb_print_t)(const fpp_l2_bd_cmd_t* p_bd);
+typedef int (*demo_l2_stent_cb_print_t)(const fpp_l2_static_ent_cmd_t* p_stent);
+ 
+#define DEMO_L2_BD_ACTION_FORWARD  (0u)
+#define DEMO_L2_BD_ACTION_FLOOD    (1u)
+#define DEMO_L2_BD_ACTION_PUNT     (2u)
+#define DEMO_L2_BD_ACTION_DISCARD  (3u)
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+int demo_l2_bd_get_by_vlan(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan);
+ 
+int demo_l2_stent_get_by_vlanmac(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
+                                 uint16_t vlan, const uint8_t p_mac[6]);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+int demo_l2_bd_update(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_bd);
+ 
+int demo_l2_stent_update(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_stent);
+ 
+int demo_l2_flush_static(FCI_CLIENT* p_cl);
+int demo_l2_flush_learned(FCI_CLIENT* p_cl);
+int demo_l2_flush_all(FCI_CLIENT* p_cl);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+ 
+int demo_l2_bd_add(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan);
+int demo_l2_bd_del(FCI_CLIENT* p_cl, uint16_t vlan);
+ 
+int demo_l2_stent_add(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent, uint16_t vlan, const uint8_t p_mac[6]);
+int demo_l2_stent_del(FCI_CLIENT* p_cl, uint16_t vlan, const uint8_t p_mac[6]);
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+ 
+void demo_l2_bd_ld_set_ucast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+void demo_l2_bd_ld_set_ucast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+void demo_l2_bd_ld_set_mcast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+void demo_l2_bd_ld_set_mcast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
+void demo_l2_bd_ld_insert_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id, bool vlan_tag);
+void demo_l2_bd_ld_remove_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
+ 
+void demo_l2_stent_ld_set_fwlist(fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist);
+void demo_l2_stent_ld_set_local(fpp_l2_static_ent_cmd_t* p_stent, bool set);
+void demo_l2_stent_ld_set_src_discard(fpp_l2_static_ent_cmd_t* p_stent, bool set);
+void demo_l2_stent_ld_set_dst_discard(fpp_l2_static_ent_cmd_t* p_stent, bool set);
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+bool demo_l2_bd_ld_is_default(const fpp_l2_bd_cmd_t* p_bd);
+bool demo_l2_bd_ld_is_fallback(const fpp_l2_bd_cmd_t* p_bd);
+bool demo_l2_bd_ld_has_phyif(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
+bool demo_l2_bd_ld_is_phyif_tagged(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
+ 
+uint16_t demo_l2_bd_ld_get_vlan(const fpp_l2_bd_cmd_t* p_bd);
+uint8_t  demo_l2_bd_ld_get_ucast_hit(const fpp_l2_bd_cmd_t* p_bd);
+uint8_t  demo_l2_bd_ld_get_ucast_miss(const fpp_l2_bd_cmd_t* p_bd);
+uint8_t  demo_l2_bd_ld_get_mcast_hit(const fpp_l2_bd_cmd_t* p_bd);
+uint8_t  demo_l2_bd_ld_get_mcast_miss(const fpp_l2_bd_cmd_t* p_bd);
+uint32_t demo_l2_bd_ld_get_if_list(const fpp_l2_bd_cmd_t* p_bd);
+uint32_t demo_l2_bd_ld_get_untag_if_list(const fpp_l2_bd_cmd_t* p_bd);
+fpp_l2_bd_flags_t demo_l2_bd_ld_get_flags(const fpp_l2_bd_cmd_t* p_bd);
+ 
+ 
+bool demo_l2_stent_ld_is_fwlist_phyifs(const fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist_bitflag);
+bool demo_l2_stent_ld_is_local(const fpp_l2_static_ent_cmd_t* p_stent);
+bool demo_l2_stent_ld_is_src_discard(const fpp_l2_static_ent_cmd_t* p_stent);
+bool demo_l2_stent_ld_is_dst_discard(const fpp_l2_static_ent_cmd_t* p_stent);
+ 
+uint16_t        demo_l2_stent_ld_get_vlan(const fpp_l2_static_ent_cmd_t* p_stent);
+const uint8_t*  demo_l2_stent_ld_get_mac(const fpp_l2_static_ent_cmd_t* p_stent);
+uint32_t        demo_l2_stent_ld_get_fwlist(const fpp_l2_static_ent_cmd_t* p_stent);
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+int demo_l2_bd_print_all(FCI_CLIENT* p_cl, demo_l2_bd_cb_print_t p_cb_print);
+int demo_l2_bd_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+ 
+int demo_l2_stent_print_all(FCI_CLIENT* p_cl, demo_l2_stent_cb_print_t p_cb_print, bool by_vlan, uint16_t vlan);
+int demo_l2_stent_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, bool by_vlan, uint16_t vlan);
+ 
+/* ========================================================================= */
+ 
+#endif
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_log_if.c b/sw/libfci_cli/src/libfci_demo/demo_log_if.c
new file mode 100644
index 0000000..c98ce37
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_log_if.c
@@ -0,0 +1,1590 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <string.h>
+#include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_log_if.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief       Set/unset a flag in a logical interface struct.
+ * @param[out]  p_rtn_phyif  Struct to be modified.
+ * @param[in]   enable       New state of a flag.
+ * @param[in]   flag         The flag.
+ */
+static void set_logif_flag(fpp_log_if_cmd_t* p_rtn_logif, bool enable, fpp_if_flags_t flag)
+{
+    assert(NULL != p_rtn_logif);
+    
+    hton_enum(&flag, sizeof(fpp_if_flags_t));
+    
+    if (enable)
+    {
+        p_rtn_logif->flags |= flag;
+    }
+    else
+    {
+        p_rtn_logif->flags &= (fpp_if_flags_t)(~flag);
+    }
+}
+ 
+ 
+/*
+ * @brief       Set/unset a match rule flag in a logical interface stuct.
+ * @param[out]  p_rtn_logif  Struct to be modified.
+ * @param[in]   enable       New state of a match rule flag.
+ * @param[in]   match_rule   The match rule flag.
+ */
+static void set_logif_mr_flag(fpp_log_if_cmd_t* p_rtn_logif, bool enable,
+                              fpp_if_m_rules_t match_rule)
+{
+    assert(NULL != p_rtn_logif);
+    
+    hton_enum(&match_rule, sizeof(fpp_if_m_rules_t));
+    
+    if (enable)
+    {
+        p_rtn_logif->match |= match_rule;
+    }
+    else
+    {
+        p_rtn_logif->match &= (fpp_if_m_rules_t)(~match_rule);
+    }
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested logical interface
+ *              from PFE. Identify the interface by its name.
+ * @details     To use this function properly, the interface database of PFE must be
+ *              locked for exclusive access. See demo_log_if_get_by_name_sa() for
+ *              an example of a database lock procedure.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_logif  Space for data from PFE.
+ * @param[in]   p_name       Name of the requested logical interface.
+ *                           Names of logical interfaces are user-defined.
+ *                           See demo_log_if_add().
+ * @return      FPP_ERR_OK : The requested logical interface was found.
+ *                           A copy of its configuration data was stored into p_rtn_logif.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_log_if_get_by_name(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, 
+                            const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_logif);
+    assert(NULL != p_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) && (0 != strcmp((reply_from_fci.name), p_name)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_logif = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_log_if_get_by_name() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested logical interface
+ *              from PFE. Identify the interface by its name.
+ * @details     This is a standalone (_sa) function.
+ *              It shows how to properly access a logical interface. Namely:
+ *              1. Lock the interface database of PFE for exclusive access by this FCI client.
+ *              2. Execute one or more FCI calls which access physical or logical interfaces.
+ *              3. Unlock the exclusive access lock.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_logif  Space for data from PFE.
+ * @param[in]   p_name       Name of the requested logical interface.
+ *                           Names of logical interfaces are user-defined.
+ *                           See demo_log_if_add().
+ * @return      FPP_ERR_OK : The requested logical interface was found.
+ *                           A copy of its configuration data was stored into p_rtn_logif.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+inline int demo_log_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, 
+                                     const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_logif);
+    assert(NULL != p_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    /* lock the interface database of PFE for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    print_if_error(rtn, "demo_log_if_get_by_name_sa() --> "
+                        "fci_write(FPP_CMD_IF_LOCK_SESSION) failed!");
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_log_if_get_by_name(p_cl, p_rtn_logif, p_name);
+    }
+    
+    /* unlock the interface database's exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
+    
+    print_if_error(rtn_unlock, "demo_log_if_get_by_name_sa() --> "
+                               "fci_write(FPP_CMD_IF_UNLOCK_SESSION) failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target logical interface
+ *                 in PFE.
+ * @details        To use this function properly, the interface database of PFE must be
+ *                 locked for exclusive access. See demo_log_if_get_by_name_sa() for
+ *                 an example of a database lock procedure.
+ * @param[in]      p_cl     FCI client
+ * @param[in,out]  p_phyif  Local data struct which represents a new configuration of
+ *                          the target logical interface.
+ *                          It is assumed that the struct contains a valid data of some 
+ *                          logical interface.
+ * @return        FPP_ERR_OK : Configuration of the target logical interface was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                              The local data struct was not updated.
+ */
+int demo_log_if_update(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_logif);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_log_if_cmd_t cmd_to_fci = (*p_logif);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+                                         (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_log_if_get_by_name(p_cl, p_logif, (p_logif->name));
+    }
+    
+    print_if_error(rtn, "demo_log_if_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new logical interface in PFE.
+ * @details     To use this function properly, the interface database of PFE must be
+ *              locked for exclusive access. See demo_log_if_get_by_name_sa() for
+ *              an example of a database lock procedure.
+ * @param[in]   p_cl           FCI client
+ * @param[out]  p_rtn_logif    Space for data from PFE.
+ *                             This will contain a copy of configuration data of 
+ *                             the newly created logical interface.
+ *                             Can be NULL. If NULL, then there is no local data to fill.
+ * @param[in]   p_name         Name of the new logical interface.
+ *                             The name is user-defined.
+ * @param[in]   p_parent_name  Name of a parent physical interface.
+ *                             Names of physical interfaces are hardcoded.
+ *                             See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : New logical interface was created.
+ *                           If applicable, then its configuration data were 
+ *                           copied into p_rtn_logif.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_log_if_add(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name, 
+                   const char* p_parent_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_name);
+    assert(NULL != p_parent_name);
+    /* 'p_rtn_logif' is allowed to be NULL */
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_name, IFNAMSIZ);
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = set_text((cmd_to_fci.parent_name), p_parent_name, IFNAMSIZ);
+    }
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_REGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+                                             (unsigned short*)(&cmd_to_fci));
+    }
+    
+    /* read back and update caller data (if applicable) */
+    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_logif))
+    {
+        rtn = demo_log_if_get_by_name(p_cl, p_rtn_logif, p_name);
+    }
+    
+    print_if_error(rtn, "demo_log_if_add() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to destroy the target logical interface in PFE.
+ * @details    To use this function properly, the interface database of PFE must be
+ *             locked for exclusive access. See demo_log_if_get_by_name_sa() for
+ *             an example of a database lock procedure.
+ * @param[in]  p_cl    FCI client
+ * @param[in]  p_name  Name of the logical interface to destroy.
+ * @return     FPP_ERR_OK : The logical interface was destroyed.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_log_if_del(FCI_CLIENT* p_cl, const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.name), p_name, IFNAMSIZ);
+    
+    /* send data */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+        rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+                                             (unsigned short*)(&cmd_to_fci));
+    }
+    
+    print_if_error(rtn, "demo_log_if_del() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_logif  [localdata_logif]
+ * @brief:      Functions marked as [localdata_logif] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_logif (a struct with configuration data).
+ *              Initial data for p_logif can be obtained via demo_log_if_get_by_name().
+ *              If some modifications are made to local data, then after all modifications
+ *              are done and finished, call demo_log_if_update() to update
+ *              the configuration of a real logical interface in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Enable ("up") a logical interface.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ */
+void demo_log_if_ld_enable(fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    set_logif_flag(p_logif, true, FPP_IF_ENABLED);
+}
+ 
+ 
+/*
+ * @brief          Disable ("down") a logical interface.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ */
+void demo_log_if_ld_disable(fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    set_logif_flag(p_logif, false, FPP_IF_ENABLED);
+}
+ 
+ 
+/*
+ * @brief          Set/unset a promiscuous mode of a logical interface.
+ * @details        [localdata_logif]
+ *                 Promiscuous mode of a logical interface means the interface
+ *                 will accept all incoming traffic, regardless of active match rules.
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the promiscuous mode.
+ */
+void demo_log_if_ld_set_promisc(fpp_log_if_cmd_t* p_logif, bool enable)
+{
+    assert(NULL != p_logif);
+    set_logif_flag(p_logif, enable, FPP_IF_PROMISC);
+}
+ 
+ 
+/*
+ * @brief          Set/unset a loopback mode of a logical interface.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the loopback mode.
+ */
+void demo_log_if_ld_set_loopback(fpp_log_if_cmd_t* p_logif, bool enable)
+{
+    assert(NULL != p_logif);
+    set_logif_flag(p_logif, enable, FPP_IF_LOOPBACK);
+}
+ 
+ 
+/*
+ * @brief          Set match mode (chaining mode of match rules).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      match_mode_is_or  Request to set match mode.
+ *                                   For details about logical interface match modes,
+ *                                   see description of the fpp_if_flags_t type
+ *                                   in FCI API Reference.
+ */
+void demo_log_if_ld_set_match_mode_or(fpp_log_if_cmd_t* p_logif, bool match_mode_is_or)
+{
+    assert(NULL != p_logif);
+    set_logif_flag(p_logif, match_mode_is_or, FPP_IF_MATCH_OR);
+}
+ 
+ 
+/*
+ * @brief          Set/unset inverted mode of traffic acceptance.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset inverted mode.
+ *                          For details about logical interface inverted mode,
+ *                          see description of the fpp_if_flags_t type
+ *                          in FCI API Reference.
+ */
+void demo_log_if_ld_set_discard_on_m(fpp_log_if_cmd_t* p_logif, bool enable)
+{
+    assert(NULL != p_logif);
+    set_logif_flag(p_logif, enable, FPP_IF_DISCARD);
+}
+ 
+ 
+/*
+ * @brief          Set target physical interfaces (egress vector) which 
+ *                 shall receive a copy of the accepted traffic.
+ * @details        [localdata_logif]
+ *                 New egress vector fully replaces the old one.
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      egress   Target physical interfaces (egress vector). A bitset.
+ *                          Each physical interface is represented by one bit.
+ *                          Conversion between physical interface ID and a corresponding
+ *                          egress vector bit is (1uL << "ID of a target physical interface").
+ */
+void demo_log_if_ld_set_egress_phyifs(fpp_log_if_cmd_t* p_logif, uint32_t egress)
+{
+    assert(NULL != p_logif);
+    p_logif->egress = htonl(egress);
+}
+ 
+ 
+/*
+ * @brief      Query the flags of a logical interface (the whole bitset).
+ * @details    [localdata_phyif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Flags bitset at time when the data was obtained from PFE.
+ */
+fpp_if_flags_t demo_log_if_ld_get_flags(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_flags_t tmp_flags = (p_logif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (tmp_flags);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief          Clear all match rules of a logical interface.
+ *                 (also zeroify all match rule arguments of the logical interface)
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ */
+void demo_log_if_ld_clear_all_mr(fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    p_logif->match = 0u;
+    memset(&(p_logif->arguments), 0, sizeof(fpp_if_m_args_t));
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_ETH).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_eth(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_ETH);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_VLAN).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_vlan(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_VLAN);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_PPPOE).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_pppoe(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_PPPOE);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_ARP).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_arp(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_ARP);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_MCAST).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_mcast(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_MCAST);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_IPV4).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_ip4(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_IPV4);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_IPV6).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_ip6(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_IPV6);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_IPX).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_ipx(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_IPX);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_BCAST).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_bcast(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_BCAST);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_UDP).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_udp(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_UDP);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_TCP).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_tcp(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_TCP);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_ICMP).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_icmp(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_ICMP);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (TYPE_IGMP).
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ */
+void demo_log_if_ld_set_mr_type_igmp(fpp_log_if_cmd_t* p_logif, bool set)
+{
+    assert(NULL != p_logif);
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_TYPE_IGMP);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (VLAN) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      vlan     New VLAN ID for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'vlan' argument with the value of traffic's 'VID' field.
+ */
+void demo_log_if_ld_set_mr_vlan(fpp_log_if_cmd_t* p_logif, bool set, uint16_t vlan)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_VLAN);
+    p_logif->arguments.vlan = htons(vlan);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (PROTO) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      proto    New IP Protocol Number for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'proto' argument with the value of traffic's 'Protocol' field.
+ *                          See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ */
+void demo_log_if_ld_set_mr_proto(fpp_log_if_cmd_t* p_logif, bool set, uint8_t proto)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_PROTO);
+    p_logif->arguments.proto = proto;
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (SPORT) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      sport    New source port value for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'sport' argument with the value of traffic's 'source port' field.
+ */
+void demo_log_if_ld_set_mr_sport(fpp_log_if_cmd_t* p_logif, bool set, uint16_t sport)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_SPORT);
+    p_logif->arguments.sport = htons(sport);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (DPORT) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      dport    New destination port value for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dport' argument with the value of traffic's 
+ *                          'destination port' field.
+ */
+void demo_log_if_ld_set_mr_dport(fpp_log_if_cmd_t* p_logif, bool set, uint16_t dport)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_DPORT);
+    p_logif->arguments.dport = htons(dport);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (SIP6) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      p_sip6   New source IPv6 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'sip' argument with the value of traffic's 
+ *                          'source address' (applicable on IPv6 traffic only).
+ */
+void demo_log_if_ld_set_mr_sip6(fpp_log_if_cmd_t* p_logif, bool set, 
+                               const uint32_t p_sip6[4])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_sip6);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_SIP6);
+    
+    p_logif->arguments.ipv.v6.sip[0] = htonl(p_sip6[0]);
+    p_logif->arguments.ipv.v6.sip[1] = htonl(p_sip6[1]);
+    p_logif->arguments.ipv.v6.sip[2] = htonl(p_sip6[2]);
+    p_logif->arguments.ipv.v6.sip[3] = htonl(p_sip6[3]);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (SIP6) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      p_dip6   New destination IPv6 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dip' argument with the value of traffic's 
+ *                          'destination address' (applicable on IPv6 traffic only).
+ */
+void demo_log_if_ld_set_mr_dip6(fpp_log_if_cmd_t* p_logif, bool set, 
+                               const uint32_t p_dip6[4])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_dip6);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_DIP6);
+    
+    p_logif->arguments.ipv.v6.dip[0] = htonl(p_dip6[0]);
+    p_logif->arguments.ipv.v6.dip[1] = htonl(p_dip6[1]);
+    p_logif->arguments.ipv.v6.dip[2] = htonl(p_dip6[2]);
+    p_logif->arguments.ipv.v6.dip[3] = htonl(p_dip6[3]);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (SIP) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      sip      New source IPv4 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'sip' argument with the value of traffic's 
+ *                          'source address' (applicable on IPv4 traffic only).
+ */
+void demo_log_if_ld_set_mr_sip(fpp_log_if_cmd_t* p_logif, bool set, uint32_t sip)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_SIP);
+    p_logif->arguments.ipv.v4.sip = htonl(sip);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (DIP) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      dip      New destination IPv4 address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dip' argument with the value of traffic's 
+ *                          'destination address' (applicable on IPv4 traffic only).
+ */
+void demo_log_if_ld_set_mr_dip(fpp_log_if_cmd_t* p_logif, bool set, uint32_t dip)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_DIP);
+    p_logif->arguments.ipv.v4.dip = htonl(dip);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (ETHTYPE) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      ethtype  New EtherType number for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'ethtype' argument with the value of traffic's 'EtherType' field.
+ *                          See "IANA EtherType number (IEEE 802)":
+ *                https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml
+ */
+void demo_log_if_ld_set_mr_ethtype(fpp_log_if_cmd_t* p_logif, bool set, uint16_t ethtype)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_ETHTYPE);
+    p_logif->arguments.ethtype = htons(ethtype);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (FP0) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      fp_table0_name  Name of a FlexibleParser table for this match rule.
+ *                                 Requested FlexibleParser table must already exist in PFE.
+ *                                 When this match rule is active, it inspects traffic
+ *                                 according to rules listed in the referenced
+ *                                 FlexibleParser table.
+ */
+void demo_log_if_ld_set_mr_fp0(fpp_log_if_cmd_t* p_logif, bool set, 
+                               const char* fp_table0_name)
+{
+    assert(NULL != p_logif);
+    /* 'fp_table0_name' is allowed to be NULL */
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_FP0);
+    set_text((p_logif->arguments.fp_table0), fp_table0_name, IFNAMSIZ);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (FP1) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      fp_table1_name  Name of a FlexibleParser table for this match rule.
+ *                                 Requested FlexibleParser table must already exist in PFE.
+ *                                 When this match rule is active, it inspects traffic
+ *                                 according to rules listed in the referenced
+ *                                 FlexibleParser table.
+ */
+void demo_log_if_ld_set_mr_fp1(fpp_log_if_cmd_t* p_logif, bool set, 
+                               const char* fp_table1_name)
+{
+    assert(NULL != p_logif);
+    /* 'fp_table1_name' is allowed to be NULL */
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_FP1);
+    set_text((p_logif->arguments.fp_table1), fp_table1_name, IFNAMSIZ);
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (SMAC) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      p_smac   New source MAC address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'smac' argument with the value of traffic's 'source MAC' field.
+ */
+void demo_log_if_ld_set_mr_smac(fpp_log_if_cmd_t* p_logif, bool set, const uint8_t p_smac[6])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_smac);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_SMAC);
+    memcpy((p_logif->arguments.smac), p_smac, (6 * sizeof(uint8_t)));
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (DMAC) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      p_dmac   New destination MAC address for this match rule.
+ *                          When this match rule is active, it compares value of its
+ *                          'dmac' argument with the value of traffic's 
+ *                          'destination MAC' field.
+ */
+void demo_log_if_ld_set_mr_dmac(fpp_log_if_cmd_t* p_logif, bool set, const uint8_t p_dmac[6])
+{
+    assert(NULL != p_logif);
+    assert(NULL != p_dmac);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_DMAC);
+    memcpy((p_logif->arguments.dmac), p_dmac, (6 * sizeof(uint8_t)));
+}
+ 
+ 
+/*
+ * @brief          Set/unset the given match rule (HIF_COOKIE) and its argument.
+ * @details        [localdata_logif]
+ * @param[in,out]  p_logif  Local data to be modified.
+ * @param[in]      set      Request to set/unset the given match rule.
+ * @param[in]      hif_cookie  New hif cookie value for this match rule.
+ *                             When this match rule is active, it compares value of its
+ *                            'hif_cookie' argument with the value of a hif_cookie tag.
+ *                             Hif_cookie tag is a part of internal overhead data, attached
+ *                             to traffic by a host's PFE driver.
+ */
+void demo_log_if_ld_set_mr_hif_cookie(fpp_log_if_cmd_t* p_logif, bool set, 
+                                      uint32_t hif_cookie)
+{
+    assert(NULL != p_logif);
+    
+    set_logif_mr_flag(p_logif, set, FPP_IF_MATCH_HIF_COOKIE);
+    p_logif->arguments.hif_cookie = htonl(hif_cookie);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query the status of the "enable" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : was enabled  ("up")
+ *             false : was disabled ("down")
+ */
+bool demo_log_if_ld_is_enabled(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_flags_t tmp_flags = (p_logif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_ENABLED);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "enable" flag (inverted logic).
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : was disabled ("down")
+ *             false : was enabled  ("up)
+ */
+bool demo_log_if_ld_is_disabled(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return !demo_log_if_ld_is_enabled(p_logif);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "promiscuous mode" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : was in a promiscuous mode
+ *             false : was NOT in a promiscuous mode
+ */
+bool demo_log_if_ld_is_promisc(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_flags_t tmp_flags = (p_logif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_PROMISC);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "loopback" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : was in a loopback mode
+ *             false : was NOT in a loopback mode
+ */
+bool demo_log_if_ld_is_loopback(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_flags_t tmp_flags = (p_logif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_LOOPBACK);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "match mode" flag (chaining mode of match rules).
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : was using OR match mode
+ *             false : was using AND match mode
+ */
+bool demo_log_if_ld_is_match_mode_or(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_flags_t tmp_flags = (p_logif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_MATCH_OR);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "discard on match" flag.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : was discarding traffic that passed its matching process
+ *             false : was NOT discarding traffic that passed its matching process
+ */
+bool demo_log_if_ld_is_discard_on_m(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_flags_t tmp_flags = (p_logif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_DISCARD);
+}
+ 
+ 
+/*
+ * @brief      Query whether a physical interface is a member of 
+ *             a logical interface's egress vector.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @param[in]  egress_bitflag  Queried physical interface. A bitflag.
+ *                             Each physical interface is represented by one bit.
+ *                             Conversion between physical interface ID and a corresponding
+ *                             egress vector bit is 
+ *                             (1uL << "ID of a target physical interface").
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : had at least one queried egress bitflag set
+ *             false : had none of the queried egress bitflags set
+ */
+bool demo_log_if_ld_is_egress_phyifs(const fpp_log_if_cmd_t* p_logif, uint32_t egress_bitflag)
+{
+    assert(NULL != p_logif);
+    return (bool)(ntohl(p_logif->match) & egress_bitflag);
+}
+ 
+ 
+/*
+ * @brief      Query whether a match rule is active or not.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @param[in]  match_rule  Queried match rule.
+ * @return     At time when the data was obtained from PFE, the logical interface:
+ *             true  : had at least one queried match rule set
+ *             false : had none of the queried match rules set
+ */
+bool demo_log_if_ld_is_match_rule(const fpp_log_if_cmd_t* p_logif, 
+                                  fpp_if_m_rules_t match_rule)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_m_rules_t tmp_match = (p_logif->match);
+    ntoh_enum(&tmp_match, sizeof(fpp_if_m_rules_t));
+    
+    return (bool)(tmp_match & match_rule);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the name of a logical interface.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Name of the logical interface.
+ */
+const char* demo_log_if_ld_get_name(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->name);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a logical interface.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     ID of the logical interface.
+ */
+uint32_t demo_log_if_ld_get_id(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->id);
+}
+ 
+ 
+/*
+ * @brief      Query the name of a logical interface's parent.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Name of the parent physical interface.
+ */
+const char* demo_log_if_ld_get_parent_name(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->parent_name);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a logical interface's parent.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     ID of the parent physical interface.
+ */
+uint32_t demo_log_if_ld_get_parent_id(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->parent_id);
+}
+ 
+ 
+/*
+ * @brief      Query the target physical interfaces (egress vector) of a logical interface.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Egress vector.
+ */
+uint32_t demo_log_if_ld_get_egress(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->egress);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the match rule bitset of a logical interface.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Match rule bitset.
+ */
+fpp_if_m_rules_t demo_log_if_ld_get_mr_bitset(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    
+    fpp_if_m_rules_t tmp_match = (p_logif->match);
+    ntoh_enum(&tmp_match, sizeof(fpp_if_m_rules_t));
+    
+    return (tmp_match);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule VLAN.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (VLAN ID) of the given match rule.
+ */
+uint16_t demo_log_if_ld_get_mr_arg_vlan(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohs(p_logif->arguments.vlan);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule PROTO.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (Protocol ID) of the given match rule.
+ */
+uint8_t demo_log_if_ld_get_mr_arg_proto(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->arguments.proto);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule SPORT.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (source port ID) of the given match rule.
+ */
+uint16_t demo_log_if_ld_get_mr_arg_sport(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohs(p_logif->arguments.sport);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule DPORT.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (destination port ID) of the given match rule.
+ */
+uint16_t demo_log_if_ld_get_mr_arg_dport(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohs(p_logif->arguments.dport);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule SIP6.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (source IPv6) of the given match rule.
+ */
+const uint32_t* demo_log_if_ld_get_mr_arg_sip6(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    static uint32_t rtn_sip6[4] = {0u};
+    
+    rtn_sip6[0] = ntohl(p_logif->arguments.ipv.v6.sip[0]);
+    rtn_sip6[1] = ntohl(p_logif->arguments.ipv.v6.sip[1]);
+    rtn_sip6[2] = ntohl(p_logif->arguments.ipv.v6.sip[2]);
+    rtn_sip6[3] = ntohl(p_logif->arguments.ipv.v6.sip[3]);
+    
+    return (rtn_sip6);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule DIP6.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (destination IPv6) of the given match rule.
+ */
+const uint32_t* demo_log_if_ld_get_mr_arg_dip6(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    static uint32_t rtn_dip6[4] = {0u};
+    
+    rtn_dip6[0] = ntohl(p_logif->arguments.ipv.v6.dip[0]);
+    rtn_dip6[1] = ntohl(p_logif->arguments.ipv.v6.dip[1]);
+    rtn_dip6[2] = ntohl(p_logif->arguments.ipv.v6.dip[2]);
+    rtn_dip6[3] = ntohl(p_logif->arguments.ipv.v6.dip[3]);
+    
+    return (rtn_dip6);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule SIP.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (source IPv4) of the given match rule.
+ */
+uint32_t demo_log_if_ld_get_mr_arg_sip(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->arguments.ipv.v4.sip);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule DIP.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (destination IPv4) of the given match rule.
+ */
+uint32_t demo_log_if_ld_get_mr_arg_dip(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->arguments.ipv.v4.dip);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule ETHTYPE.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (EtherType ID) of the given match rule.
+ */
+uint16_t demo_log_if_ld_get_mr_arg_ethtype(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohs(p_logif->arguments.ethtype);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule FP0.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (name of a FlexibleParser table) of the given match rule.
+ */
+const char* demo_log_if_ld_get_mr_arg_fp0(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->arguments.fp_table0);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule FP1.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (name of a FlexibleParser table) of the given match rule.
+ */
+const char* demo_log_if_ld_get_mr_arg_fp1(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->arguments.fp_table1);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule SMAC.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (source MAC address) of the given match rule.
+ */
+const uint8_t* demo_log_if_ld_get_mr_arg_smac(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->arguments.smac);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule DMAC.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (destination MAC address) of the given match rule.
+ */
+const uint8_t* demo_log_if_ld_get_mr_arg_dmac(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return (p_logif->arguments.dmac);
+}
+ 
+ 
+/*
+ * @brief      Query the argument of the match rule HIF_COOKIE.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Argument (hif cookie value) of the given match rule.
+ */
+uint32_t demo_log_if_ld_get_mr_arg_hif_cookie(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->arguments.hif_cookie);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the statistics of a logical interface - processed.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Count of processed packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_log_if_ld_get_stt_processed(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->stats.processed);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of a logical interface - accepted.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Count of accepted packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_log_if_ld_get_stt_accepted(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->stats.accepted);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of a logical interface - rejected.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Count of rejected packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_log_if_ld_get_stt_rejected(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->stats.rejected);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of a logical interface - discarded.
+ * @details    [localdata_logif]
+ * @param[in]  p_logif  Local data to be queried.
+ * @return     Count of discarded packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_log_if_ld_get_stt_discarded(const fpp_log_if_cmd_t* p_logif)
+{
+    assert(NULL != p_logif);
+    return ntohl(p_logif->stats.discarded);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available logical interfaces in PFE and
+ *             execute a callback print function for each applicable logical interface.
+ * @details    To use this function properly, the interface database of PFE must be
+ *             locked for exclusive access. See demo_log_if_get_by_name_sa() for
+ *             an example of a database lock procedure.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next logical interface is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]  p_parent_name   [optional parameter] Name of a parent physical interface.
+ *                             Names of physical interfaces are hardcoded.
+ *                             See FCI API Reference, chapter Interface Management.
+ *                             Can be NULL.
+ *                             If NULL, then all available logical interfaces are printed.
+ *                             If non-NULL, then only those logical interfaces which are 
+ *                             children of the given physical interface are printed.
+ * @return     FPP_ERR_OK : Successfully iterated through all available logical interfaces.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_log_if_print_all(FCI_CLIENT* p_cl, demo_log_if_cb_print_t p_cb_print,
+                         const char* p_parent_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    /* 'p_parent_name' is allowed to be NULL */
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if ((NULL == p_parent_name) || 
+            (0 == strcmp((reply_from_fci.parent_name), p_parent_name)))
+        {
+            rtn = p_cb_print(&reply_from_fci);
+        }
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                            sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more logical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_log_if_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available logical interfaces in PFE.
+ * @details     To use this function properly, the interface database of PFE must be
+ *              locked for exclusive access. See demo_log_if_get_by_name_sa() for
+ *              an example of a database lock procedure.
+ * @param[in]   p_cl           FCI client
+ * @param[out]  p_rtn_count    Space to store the count of logical interfaces.
+ * @param[in]   p_parent_name  [optional parameter] Name of a parent physical interface.
+ *                             Names of physical interfaces are hardcoded.
+ *                             See FCI API Reference, chapter Interface Management.
+ *                             Can be NULL.
+ *                             If NULL, then all available logical interfaces are counted.
+ *                             If non-NULL, then only those logical interfaces which are 
+ *                             children of the given physical interface are counted.
+ * @return      FPP_ERR_OK : Successfully counted all applicable logical interfaces.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_log_if_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                         const char* p_parent_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    /* 'p_parent_name' is allowed to be NULL */
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_log_if_cmd_t cmd_to_fci = {0};
+    fpp_log_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if ((NULL == p_parent_name) || 
+            (0 == strcmp((reply_from_fci.parent_name), p_parent_name)))
+        {
+            count++;
+        }
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
+                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more logical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_log_if_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_log_if.h b/sw/libfci_cli/src/libfci_demo/demo_log_if.h
new file mode 100644
index 0000000..25075ec
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_log_if.h
@@ -0,0 +1,144 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+#ifndef DEMO_LOG_IF_H_
+#define DEMO_LOG_IF_H_
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+/* ==== TYPEDEFS & DATA ==================================================== */
+ 
+typedef int (*demo_log_if_cb_print_t)(const fpp_log_if_cmd_t* p_logif);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+int demo_log_if_get_by_name(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name);
+int demo_log_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+int demo_log_if_update(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+ 
+int demo_log_if_add(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name, const char* p_parent_name);
+int demo_log_if_del(FCI_CLIENT* p_cl, const char* p_name);
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+ 
+void demo_log_if_ld_enable(fpp_log_if_cmd_t* p_logif);
+void demo_log_if_ld_disable(fpp_log_if_cmd_t* p_logif);
+void demo_log_if_ld_set_promisc(fpp_log_if_cmd_t* p_logif, bool enable);
+void demo_log_if_ld_set_loopback(fpp_log_if_cmd_t* p_logif, bool enable);
+void demo_log_if_ld_set_match_mode_or(fpp_log_if_cmd_t* p_logif, bool match_mode_is_or);
+void demo_log_if_ld_set_discard_on_m(fpp_log_if_cmd_t* p_logif, bool enable);
+void demo_log_if_ld_set_egress_phyifs(fpp_log_if_cmd_t* p_logif, uint32_t egress);
+ 
+void demo_log_if_ld_clear_all_mr(fpp_log_if_cmd_t* p_logif);
+void demo_log_if_ld_set_mr_type_eth(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_vlan(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_pppoe(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_arp(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_mcast(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_ip4(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_ip6(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_ipx(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_bcast(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_udp(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_tcp(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_icmp(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_type_igmp(fpp_log_if_cmd_t* p_logif, bool set);
+void demo_log_if_ld_set_mr_vlan(fpp_log_if_cmd_t* p_logif, bool set, uint16_t vlan);
+void demo_log_if_ld_set_mr_proto(fpp_log_if_cmd_t* p_logif, bool set, uint8_t proto);
+void demo_log_if_ld_set_mr_sport(fpp_log_if_cmd_t* p_logif, bool set, uint16_t sport);
+void demo_log_if_ld_set_mr_dport(fpp_log_if_cmd_t* p_logif, bool set, uint16_t dport);
+void demo_log_if_ld_set_mr_sip6(fpp_log_if_cmd_t* p_logif, bool set, const uint32_t p_sip6[4]);
+void demo_log_if_ld_set_mr_dip6(fpp_log_if_cmd_t* p_logif, bool set, const uint32_t p_sip6[4]);
+void demo_log_if_ld_set_mr_sip(fpp_log_if_cmd_t* p_logif, bool set, uint32_t sip);
+void demo_log_if_ld_set_mr_dip(fpp_log_if_cmd_t* p_logif, bool set, uint32_t dip);
+void demo_log_if_ld_set_mr_ethtype(fpp_log_if_cmd_t* p_logif, bool set, uint16_t ethtype);
+void demo_log_if_ld_set_mr_fp0(fpp_log_if_cmd_t* p_logif, bool set, const char* fp_table0_name);
+void demo_log_if_ld_set_mr_fp1(fpp_log_if_cmd_t* p_logif, bool set, const char* fp_table1_name);
+void demo_log_if_ld_set_mr_smac(fpp_log_if_cmd_t* p_logif, bool set, const uint8_t p_smac[6]);
+void demo_log_if_ld_set_mr_dmac(fpp_log_if_cmd_t* p_logif, bool set, const uint8_t p_dmac[6]);
+void demo_log_if_ld_set_mr_hif_cookie(fpp_log_if_cmd_t* p_logif, bool set, uint32_t hif_cookie);
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+bool demo_log_if_ld_is_enabled(const fpp_log_if_cmd_t* p_logif);
+bool demo_log_if_ld_is_disabled(const fpp_log_if_cmd_t* p_logif);
+bool demo_log_if_ld_is_promisc(const fpp_log_if_cmd_t* p_logif);
+bool demo_log_if_ld_is_loopback(const fpp_log_if_cmd_t* p_logif);
+bool demo_log_if_ld_is_match_mode_or(const fpp_log_if_cmd_t* p_logif);
+bool demo_log_if_ld_is_discard_on_m(const fpp_log_if_cmd_t* p_logif);
+bool demo_log_if_ld_is_egress_phyifs(const fpp_log_if_cmd_t* p_logif, uint32_t phyif_bitflag);
+bool demo_log_if_ld_is_mr(const fpp_log_if_cmd_t* p_logif, fpp_if_m_rules_t match_rule);
+ 
+const char*      demo_log_if_ld_get_name(const fpp_log_if_cmd_t* p_logif);
+uint32_t         demo_log_if_ld_get_id(const fpp_log_if_cmd_t* p_logif);
+const char*      demo_log_if_ld_get_parent_name(const fpp_log_if_cmd_t* p_logif);
+uint32_t         demo_log_if_ld_get_parent_id(const fpp_log_if_cmd_t* p_logif);
+uint32_t         demo_log_if_ld_get_egress(const fpp_log_if_cmd_t* p_logif);
+fpp_if_flags_t   demo_log_if_ld_get_flags(const fpp_log_if_cmd_t* p_logif);
+ 
+fpp_if_m_rules_t demo_log_if_ld_get_mr_bitset(const fpp_log_if_cmd_t* p_logif);
+uint16_t         demo_log_if_ld_get_mr_arg_vlan(const fpp_log_if_cmd_t* p_logif);
+uint8_t          demo_log_if_ld_get_mr_arg_proto(const fpp_log_if_cmd_t* p_logif);
+uint16_t         demo_log_if_ld_get_mr_arg_sport(const fpp_log_if_cmd_t* p_logif);
+uint16_t         demo_log_if_ld_get_mr_arg_dport(const fpp_log_if_cmd_t* p_logif);
+const uint32_t*  demo_log_if_ld_get_mr_arg_sip6(const fpp_log_if_cmd_t* p_logif);
+const uint32_t*  demo_log_if_ld_get_mr_arg_dip6(const fpp_log_if_cmd_t* p_logif);
+uint32_t         demo_log_if_ld_get_mr_arg_sip(const fpp_log_if_cmd_t* p_logif);
+uint32_t         demo_log_if_ld_get_mr_arg_dip(const fpp_log_if_cmd_t* p_logif);
+uint16_t         demo_log_if_ld_get_mr_arg_ethtype(const fpp_log_if_cmd_t* p_logif);
+const char*      demo_log_if_ld_get_mr_arg_fp0(const fpp_log_if_cmd_t* p_logif);
+const char*      demo_log_if_ld_get_mr_arg_fp1(const fpp_log_if_cmd_t* p_logif);
+const uint8_t*   demo_log_if_ld_get_mr_arg_smac(const fpp_log_if_cmd_t* p_logif);
+const uint8_t*   demo_log_if_ld_get_mr_arg_dmac(const fpp_log_if_cmd_t* p_logif);
+uint32_t         demo_log_if_ld_get_mr_arg_hif_cookie(const fpp_log_if_cmd_t* p_logif);
+ 
+uint32_t demo_log_if_ld_get_stt_processed(const fpp_log_if_cmd_t* p_logif);
+uint32_t demo_log_if_ld_get_stt_accepted(const fpp_log_if_cmd_t* p_logif);
+uint32_t demo_log_if_ld_get_stt_rejected(const fpp_log_if_cmd_t* p_logif);
+uint32_t demo_log_if_ld_get_stt_discarded(const fpp_log_if_cmd_t* p_logif);
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+int demo_log_if_print_all(FCI_CLIENT* p_cl, demo_log_if_cb_print_t p_cb_print, const char* p_parent_name);
+int demo_log_if_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, const char* p_parent_name);
+ 
+/* ========================================================================= */
+ 
+#endif
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_phy_if.c b/sw/libfci_cli/src/libfci_demo/demo_phy_if.c
new file mode 100644
index 0000000..f7409bb
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_phy_if.c
@@ -0,0 +1,897 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <string.h>
+#include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_phy_if.h"
+ 
+ 
+/* ==== PRIVATE FUNCTIONS ================================================== */
+ 
+ 
+/*
+ * @brief       Set/unset a flag in a physical interface struct.
+ * @param[out]  p_rtn_phyif  Struct to be modified.
+ * @param[in]   enable       New state of a flag.
+ * @param[in]   flag         The flag.
+ */
+static void set_phyif_flag(fpp_phy_if_cmd_t* p_rtn_phyif, bool enable, fpp_if_flags_t flag)
+{
+    assert(NULL != p_rtn_phyif);
+    
+    hton_enum(&flag, sizeof(fpp_if_flags_t));
+    
+    if (enable)
+    {
+        p_rtn_phyif->flags |= flag;
+    }
+    else
+    {
+        p_rtn_phyif->flags &= (fpp_if_flags_t)(~flag);
+    }
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested physical interface
+ *              from PFE. Identify the interface by its name.
+ * @details     To use this function properly, the interface database of PFE must be
+ *              locked for exclusive access. See demo_phy_if_get_by_name_sa() for
+ *              an example of a database lock procedure.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_phyif  Space for data from PFE.
+ * @param[in]   p_name       Name of the requested physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : The requested physical interface was found.
+ *                           A copy of its configuration data was stored into p_rtn_phyif.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_phy_if_get_by_name(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, 
+                            const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_phyif);
+    assert(NULL != p_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) && (0 != strcmp((reply_from_fci.name), p_name)))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_phyif = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_phy_if_get_by_name() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested physical interface
+ *              from PFE. Identify the interface by its name.
+ * @details     This is a standalone (_sa) function.
+ *              It shows how to properly access a physical interface. Namely:
+ *              1. Lock the interface database of PFE for exclusive access by this FCI client.
+ *              2. Execute one or more FCI calls which access physical or logical interfaces.
+ *              3. Unlock the exclusive access lock.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_phyif  Space for data from PFE.
+ * @param[in]   p_name       Name of the requested physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : The requested physical interface was found.
+ *                           A copy of its configuration data was stored into p_rtn_phyif.
+ *                           REMINDER: data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+inline int demo_phy_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif,
+                                      const char* p_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_phyif);
+    assert(NULL != p_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    /* lock the interface database of PFE for exclusive access by this FCI client */
+    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
+    
+    print_if_error(rtn, "demo_phy_if_get_by_name_sa() --> "
+                        "fci_write(FPP_CMD_IF_LOCK_SESSION) failed!");
+    
+    /* execute "payload" - FCI calls which access physical or logical interfaces */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_phy_if_get_by_name(p_cl, p_rtn_phyif, p_name);
+    }
+    
+    /* unlock the exclusive access lock */
+    /* result of the unlock action is returned only if previous "payload" actions were OK */
+    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
+    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));  
+    
+    print_if_error(rtn_unlock, "demo_phy_if_get_by_name_sa() --> "
+                               "fci_write(FPP_CMD_IF_UNLOCK_SESSION) failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target physical interface
+ *                 in PFE.
+ * @details        To use this function properly, the interface database of PFE must be
+ *                 locked for exclusive access. See demo_phy_if_get_by_name_sa() for
+ *                 an example of a database lock procedure.
+ * @param[in]      p_cl     FCI client
+ * @param[in,out]  p_phyif  Local data struct which represents a new configuration of
+ *                          the target physical interface.
+ *                          It is assumed that the struct contains a valid data of some 
+ *                          physical interface.
+ * @return        FPP_ERR_OK : Configuration of the target physical interface was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             The local data struct was not updated.
+ */
+int demo_phy_if_update(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_phy_if_cmd_t cmd_to_fci = (*p_phyif);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_PHY_IF, sizeof(fpp_phy_if_cmd_t), 
+                                         (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_phy_if_get_by_name(p_cl, p_phyif, (p_phyif->name));
+    }
+    
+    print_if_error(rtn, "demo_phy_if_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_phyif  [localdata_phyif]
+ * @brief:      Functions marked as [localdata_phyif] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_phyif (a struct with configuration data).
+ *              Initial data for p_phyif can be obtained via demo_phy_if_get_by_name().
+ *              If some modifications are made to local data, then after all modifications
+ *              are done and finished, call demo_phy_if_update() to update
+ *              the configuration of a real physical interface in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Enable ("up") a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ */
+void demo_phy_if_ld_enable(fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, true, FPP_IF_ENABLED);
+}
+ 
+ 
+/*
+ * @brief          Disable ("down") a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ */
+void demo_phy_if_ld_disable(fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, false, FPP_IF_ENABLED);
+}
+ 
+ 
+/*
+ * @brief          Set/unset a promiscuous mode of a physical interface.
+ * @details        [localdata_phyif]
+ *                 Promiscuous mode of a physical interface means the interface
+ *                 will accept and process all incoming traffic, regardless of
+ *                 the traffic's destination MAC.
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the promiscuous mode.
+ */
+void demo_phy_if_ld_set_promisc(fpp_phy_if_cmd_t* p_phyif, bool enable)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, enable, FPP_IF_PROMISC);
+}
+ 
+ 
+/*
+ * @brief          Set/unset this physical interface as a part of a loadbalancing bucket.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      enable   Request to add/remove this interface to/from
+ *                          a loadbalancing bucket.
+ */
+void demo_phy_if_ld_set_loadbalance(fpp_phy_if_cmd_t* p_phyif, bool enable)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, enable, FPP_IF_LOADBALANCE);
+}
+ 
+ 
+/*
+ * @brief          Set/unset a VLAN conformance check on a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the VLAN conformance check.
+ */
+void demo_phy_if_ld_set_vlan_conf(fpp_phy_if_cmd_t* p_phyif, bool enable)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, enable, FPP_IF_VLAN_CONF_CHECK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset a PTP conformance check on a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the PTP conformance check.
+ */
+void demo_phy_if_ld_set_ptp_conf(fpp_phy_if_cmd_t* p_phyif, bool enable)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, enable, FPP_IF_PTP_CONF_CHECK);
+}
+ 
+ 
+/*
+ * @brief          Set/unset a PTP promiscuous mode on a physical interface.
+ * @details        [localdata_phyif]
+ *                 This flag allows a PTP traffic to pass entry checks even if 
+ *                 the strict VLAN conformance check is active.
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the PTP promiscuous mode.
+ */
+void demo_phy_if_ld_set_ptp_promisc(fpp_phy_if_cmd_t* p_phyif, bool enable)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, enable, FPP_IF_PTP_PROMISC);
+}
+ 
+ 
+/*
+ * @brief          Set/unset acceptance of a Q-in-Q traffic on a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      enable   Request to set/unset the Q-in-Q acceptance.
+ */
+void demo_phy_if_ld_set_qinq(fpp_phy_if_cmd_t* p_phyif, bool enable)
+{
+    assert(NULL != p_phyif);
+    set_phyif_flag(p_phyif, enable, FPP_IF_ALLOW_Q_IN_Q);
+}
+ 
+ 
+/*
+ * @brief          Set an operation mode of a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif  Local data to be modified.
+ * @param[in]      mode     New operation mode.
+ *                          For details about physical interface operation modes,
+ *                          see description of the fpp_phy_if_op_mode_t type in
+ *                          FCI API Reference.
+ */
+void demo_phy_if_ld_set_mode(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_op_mode_t mode)
+{
+    assert(NULL != p_phyif);
+    hton_enum(&mode, sizeof(fpp_phy_if_op_mode_t));
+    p_phyif->mode = mode;
+}
+ 
+ 
+/*
+ * @brief          Set a blocking state of a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif      Local data to be modified.
+ * @param[in]      block_state  New blocking state
+ *                              For details about physical interface blocking states,
+ *                              see description of the fpp_phy_if_block_state_t type in
+ *                              FCI API Reference.
+ */
+void demo_phy_if_ld_set_block_state(fpp_phy_if_cmd_t* p_phyif,
+                                   fpp_phy_if_block_state_t block_state)
+{
+    assert(NULL != p_phyif);
+    hton_enum(&block_state, sizeof(fpp_phy_if_block_state_t));
+    p_phyif->block_state = block_state;
+}
+ 
+ 
+/*
+ * @brief          Set traffic mirroring from one physical interface to 
+ *                 another physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif        Local data to be modified.
+ * @param[in]      p_mirror_name  Name of a physical interface which shall be receiving
+ *                                a copy of traffic.
+ *                                Names of physical interfaces are hardcoded.
+ *                                See FCI API Reference, chapter Interface Management.
+ *                                Can be NULL. If NULL or "" (empty string), then
+ *                                traffic mirorring is disabled.
+ */
+void demo_phy_if_ld_set_mirror(fpp_phy_if_cmd_t* p_phyif, const char* p_mirror_name)
+{
+    assert(NULL != p_phyif);
+    /* 'p_mirror_name' is allowed to be NULL */
+    
+    if (FPP_ERR_OK == set_text(p_phyif->mirror, p_mirror_name, IFNAMSIZ))
+    {
+        const bool enable = ((NULL != p_mirror_name) && ('\0' != p_mirror_name[0]));
+        set_phyif_flag(p_phyif, enable, FPP_IF_MIRROR);
+    }
+}
+ 
+ 
+/*
+ * @brief          Set FlexibleParser table to act as a FlexibleFilter for 
+ *                 a physical interface.
+ * @details        [localdata_phyif]
+ * @param[in,out]  p_phyif       Local data to be modified.
+ * @param[in]      p_table_name  Name of a FlexibleParser table.
+ *                               Can be NULL. If NULL or "" (empty string), then
+ *                               FlexibleFilter of this physical interface is disabled.
+ */
+void demo_phy_if_ld_set_flexifilter(fpp_phy_if_cmd_t* p_phyif, const char* p_table_name)
+{
+    assert(NULL != p_phyif);
+    /* 'p_table_name' is allowed to be NULL */
+    
+    set_text(p_phyif->ftable, p_table_name, IFNAMSIZ);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query the status of the "enable" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was enabled  ("up")
+ *             false : was disabled ("down")
+ */
+bool demo_phy_if_ld_is_enabled(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_ENABLED);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "enable" flag (inverted logic).
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was disabled ("down")
+ *             false : was enabled  ("up)
+ */
+bool demo_phy_if_ld_is_disabled(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return !demo_phy_if_ld_is_enabled(p_phyif);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "promiscuous mode" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was in a promiscuous mode
+ *             false : was NOT in a promiscuous mode
+ */
+bool demo_phy_if_ld_is_promisc(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_PROMISC);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "loadbalance" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was part of a loadbalance bucket
+ *             false : was NOT part of a loadbalance bucket
+ */
+bool demo_phy_if_ld_is_loadbalance(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_LOADBALANCE);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "VLAN conformance check" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was checking VLAN conformance of an incoming traffic
+ *             false : was NOT checking VLAN conformance of an incoming traffic
+ */
+bool demo_phy_if_ld_is_vlan_conf(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_VLAN_CONF_CHECK);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "PTP conformance check" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was checking PTP conformance of an incoming traffic
+ *             false : was NOT checking PTP conformance of an incoming traffic
+ */
+bool demo_phy_if_ld_is_ptp_conf(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_PTP_CONF_CHECK);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "PTP promisc" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was using PTP promiscuous mode
+ *             false : was NOT using PTP promiscuous mode
+ */
+bool demo_phy_if_ld_is_ptp_promisc(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_PTP_PROMISC);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "Q-in-Q" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : was accepting Q-in-Q traffic
+ *             false : was NOT accepting Q-in-Q traffic
+ */
+bool demo_phy_if_ld_is_qinq(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_ALLOW_Q_IN_Q);
+}
+ 
+ 
+/*
+ * @brief      Query the status of the "mirror" flag.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     At time when the data was obtained from PFE, the physical interface:
+ *             true  : had the mirroring feature enabled
+ *             false : had the mirroring feature disabled
+ */
+bool demo_phy_if_ld_is_mirror(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (bool)(tmp_flags & FPP_IF_MIRROR);
+}
+ 
+ 
+/*
+ * @brief      Query the name of a physical interface.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Name of the physical interface.
+ */
+const char* demo_phy_if_ld_get_name(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (p_phyif->name);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a physical interface.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     ID of the physical interface.
+ */
+uint32_t demo_phy_if_ld_get_id(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return ntohl(p_phyif->id);
+}
+ 
+ 
+/*
+ * @brief      Query the flags of a physical interface (the whole bitset).
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Flags bitset at time when the data was obtained from PFE.
+ */
+fpp_if_flags_t demo_phy_if_ld_get_flags(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_if_flags_t tmp_flags = (p_phyif->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_if_flags_t));
+    
+    return (tmp_flags);
+}
+ 
+ 
+/*
+ * @brief      Query the operation mode of a physical interface.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Operation mode of the physical interface at time when 
+ *             the data was obtained from PFE.
+ */
+fpp_phy_if_op_mode_t demo_phy_if_ld_get_mode(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_phy_if_op_mode_t tmp_mode = (p_phyif->mode);
+    ntoh_enum(&tmp_mode, sizeof(fpp_phy_if_op_mode_t));
+    
+    return (tmp_mode);
+}
+ 
+ 
+/*
+ * @brief      Query the blocking state of a physical interface.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Blocking state of the physical interface at time when 
+ *             the data was obtained from PFE.
+ */
+fpp_phy_if_block_state_t demo_phy_if_ld_get_block_state(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    
+    fpp_phy_if_block_state_t tmp_block_state = (p_phyif->block_state);
+    ntoh_enum(&tmp_block_state, sizeof(fpp_phy_if_op_mode_t));
+    
+    return (tmp_block_state);
+}
+ 
+ 
+/*
+ * @brief      Query the MAC address of a physical interface.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     MAC address of the physical interface.
+ */
+const uint8_t* demo_phy_if_ld_get_mac(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (p_phyif->mac_addr);
+}
+ 
+ 
+/*
+ * @brief      Query the name of a mirroring recipient (physical interface).
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Name of the mirroring recipient (physical interface) at time when 
+ *             the data was obtained from PFE.
+ */
+const char* demo_phy_if_ld_get_mirror_name(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (p_phyif->mirror);
+}
+ 
+ 
+/*
+ * @brief      Query the name of a FlexibleParser table which is being used as
+ *             a FlexibleFilter for a physical interface.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Name of the FlexibleParser table which was being used as a FlexibleFilter
+ *             of the physical interface at time when the data was obtained from PFE.
+ */
+const char* demo_phy_if_ld_get_flexifilter(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return (p_phyif->ftable);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the statistics of a physical interface - ingress.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Count of ingress packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_phy_if_ld_get_stt_ingress(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return ntohl(p_phyif->stats.ingress);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of a physical interface - egress.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Count of egressed packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_phy_if_ld_get_stt_egress(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return ntohl(p_phyif->stats.egress);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of a physical interface - malformed.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Count of malformed packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_phy_if_ld_get_stt_malformed(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return ntohl(p_phyif->stats.malformed);
+}
+ 
+ 
+/*
+ * @brief      Query the statistics of a physical interface - discarded.
+ * @details    [localdata_phyif]
+ * @param[in]  p_phyif  Local data to be queried.
+ * @return     Count of discarded packets at the time when the data was obtained form PFE.
+ */
+uint32_t demo_phy_if_ld_get_stt_discarded(const fpp_phy_if_cmd_t* p_phyif)
+{
+    assert(NULL != p_phyif);
+    return ntohl(p_phyif->stats.discarded);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available physical interfaces in PFE and
+ *             execute a callback print function for each reported physical interface.
+ * @details    To use this function properly, the interface database of PFE must be
+ *             locked for exclusive access. See demo_phy_if_get_by_name_sa() for
+ *             an example of a database lock procedure.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next physical interface is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all available physical interfaces.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_phy_if_print_all(FCI_CLIENT* p_cl, demo_phy_if_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                    sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        print_if_error(rtn, "demo_phy_if_print_all() --> "
+                            "non-zero return from callback print function!");
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                            sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more physical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_phy_if_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available physical interfaces in PFE.
+ * @details     To use this function properly, the interface database of PFE must be
+ *              locked for exclusive access. See demo_phy_if_get_by_name_sa() for
+ *              an example of a database lock procedure.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_count  Space to store the count of physical interfaces.
+ * @return      FPP_ERR_OK : Successfully counted all available physical interfaces.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_phy_if_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_phy_if_cmd_t cmd_to_fci = {0};
+    fpp_phy_if_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                    sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
+                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more physical interfaces to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_phy_if_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_phy_if.h b/sw/libfci_cli/src/libfci_demo/demo_phy_if.h
new file mode 100644
index 0000000..71b1c3b
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_phy_if.h
@@ -0,0 +1,123 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+#ifndef DEMO_PHY_IF_H_
+#define DEMO_PHY_IF_H_
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+/* ==== TYPEDEFS & DATA ==================================================== */
+ 
+/* hardcoded PHY_IF names, IDs and bitflags (IDs 3 & 4 are reserved) */
+#define DEMO_PHY_IF_EMAC0_ID  (0u)
+#define DEMO_PHY_IF_EMAC1_ID  (1u)
+#define DEMO_PHY_IF_EMAC2_ID  (2u)
+#define DEMO_PHY_IF_UTIL_ID   (5u)
+#define DEMO_PHY_IF_HIF0_ID   (6u)
+#define DEMO_PHY_IF_HIF1_ID   (7u)
+#define DEMO_PHY_IF_HIF2_ID   (8u)
+#define DEMO_PHY_IF_HIF3_ID   (9u)
+ 
+#define DEMO_PHY_IF_EMAC0_BITFLAG  (1uL << DEMO_PHY_IF_EMAC0_ID)
+#define DEMO_PHY_IF_EMAC1_BITFLAG  (1uL << DEMO_PHY_IF_EMAC1_ID)
+#define DEMO_PHY_IF_EMAC2_BITFLAG  (1uL << DEMO_PHY_IF_EMAC2_ID)
+#define DEMO_PHY_IF_UTIL_BITFLAG   (1uL << DEMO_PHY_IF_UTIL_ID)
+#define DEMO_PHY_IF_HIF0_BITFLAG   (1uL << DEMO_PHY_IF_HIF0_ID)
+#define DEMO_PHY_IF_HIF1_BITFLAG   (1uL << DEMO_PHY_IF_HIF1_ID)
+#define DEMO_PHY_IF_HIF2_BITFLAG   (1uL << DEMO_PHY_IF_HIF2_ID)
+#define DEMO_PHY_IF_HIF3_BITFLAG   (1uL << DEMO_PHY_IF_HIF3_ID)
+ 
+typedef int (*demo_phy_if_cb_print_t)(const fpp_phy_if_cmd_t* p_phyif);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+int demo_phy_if_get_by_name(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, const char* p_name);
+int demo_phy_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, const char* p_name);
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+int demo_phy_if_update(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif);
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+ 
+void demo_phy_if_ld_enable(fpp_phy_if_cmd_t* p_phyif);
+void demo_phy_if_ld_disable(fpp_phy_if_cmd_t* p_phyif);
+void demo_phy_if_ld_set_promisc(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_loadbalance(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_vlan_conf(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_ptp_conf(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_ptp_promisc(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_qinq(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_discard_ttl(fpp_phy_if_cmd_t* p_phyif, bool enable);
+void demo_phy_if_ld_set_mode(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_op_mode_t mode);
+void demo_phy_if_ld_set_block_state(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_block_state_t block_state);
+void demo_phy_if_ld_set_mirror(fpp_phy_if_cmd_t* p_phyif, const char* p_mirror_name);
+void demo_phy_if_ld_set_flexifilter(fpp_phy_if_cmd_t* p_phyif, const char* p_table_name);
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+bool demo_phy_if_ld_is_enabled(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_disabled(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_promisc(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_loadbalance(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_vlan_conf(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_ptp_conf(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_ptp_promisc(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_qinq(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_discard_ttl(const fpp_phy_if_cmd_t* p_phyif);
+bool demo_phy_if_ld_is_mirror(const fpp_phy_if_cmd_t* p_phyif);
+ 
+const char*              demo_phy_if_ld_get_name(const fpp_phy_if_cmd_t* p_phyif);
+uint32_t                 demo_phy_if_ld_get_id(const fpp_phy_if_cmd_t* p_phyif);
+fpp_if_flags_t           demo_phy_if_ld_get_flags(const fpp_phy_if_cmd_t* p_phyif);
+fpp_phy_if_op_mode_t     demo_phy_if_ld_get_mode(const fpp_phy_if_cmd_t* p_phyif);
+fpp_phy_if_block_state_t demo_phy_if_ld_get_block_state(const fpp_phy_if_cmd_t* p_phyif);
+const uint8_t*           demo_phy_if_ld_get_mac(const fpp_phy_if_cmd_t* p_phyif);
+const char*              demo_phy_if_ld_get_mirror_name(const fpp_phy_if_cmd_t* p_phyif);
+const char*              demo_phy_if_ld_get_flexifilter(const fpp_phy_if_cmd_t* p_phyif);
+ 
+uint32_t demo_phy_if_ld_get_stt_ingress(const fpp_phy_if_cmd_t* p_phyif);
+uint32_t demo_phy_if_ld_get_stt_egress(const fpp_phy_if_cmd_t* p_phyif);
+uint32_t demo_phy_if_ld_get_stt_malformed(const fpp_phy_if_cmd_t* p_phyif);
+uint32_t demo_phy_if_ld_get_stt_discarded(const fpp_phy_if_cmd_t* p_phyif);
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+int demo_phy_if_print_all(FCI_CLIENT* p_cl, demo_phy_if_cb_print_t p_cb_print);
+int demo_phy_if_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+ 
+/* ========================================================================= */
+ 
+#endif
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_qos.c b/sw/libfci_cli/src/libfci_demo/demo_qos.c
new file mode 100644
index 0000000..b3cc3bc
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_qos.c
@@ -0,0 +1,1245 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <string.h>
+#include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_qos.h"
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested QoS queue
+ *              from PFE. Identify the QoS queue by the name of a parent 
+ *              physical interface and by the queue's ID.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_que     Space for data from PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
+ *              que_id        ID of the requested QoS queue.
+ * @return      FPP_ERR_OK : The requested QoS queue was found.
+ *                           A copy of its configuration data was stored into p_rtn_que.
+ *                           REMINDER: Data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_qos_que_get_by_id(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_rtn_que, 
+                           const char* p_phyif_name, uint8_t que_id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_que);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_queue_cmd_t cmd_to_fci = {0};
+    fpp_qos_queue_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.id = que_id;
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query (get the QoS queue directly; no need for a loop) */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
+                        sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_que = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_qos_que_get_by_id() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested QoS scheduler
+ *              from PFE. Identify the QoS scheduler by the name of a parent 
+ *              physical interface and by the scheduler's ID.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_que     Space for data from PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
+ *              sch_id        ID of the requested QoS scheduler.
+ * @return      FPP_ERR_OK : The requested QoS scheduler was found.
+ *                           A copy of its configuration data was stored into p_rtn_sch.
+ *                           REMINDER: Data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_qos_sch_get_by_id(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_rtn_sch, 
+                           const char* p_phyif_name, uint8_t sch_id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_sch);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
+    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.id = sch_id;
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query (get the QoS scheduler directly; no need for a loop) */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
+                        sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_sch = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_qos_sch_get_by_id() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested QoS shaper
+ *              from PFE. Identify the QoS shaper by the name of a parent 
+ *              physical interface and by the shaper's ID.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_que     Space for data from PFE.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
+ *              shp_id        ID of the requested QoS shaper.
+ * @return      FPP_ERR_OK : The requested QoS shaper was found.
+ *                           A copy of its configuration data was stored into p_rtn_shp.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_qos_shp_get_by_id(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_rtn_shp, 
+                           const char* p_phyif_name, uint8_t shp_id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_shp);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
+    fpp_qos_shaper_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    cmd_to_fci.id = shp_id;
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query (get the QoS shaper directly; no need for a loop) */
+    if (FPP_ERR_OK == rtn)
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY;
+        rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
+                        sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_shp = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_qos_shp_get_by_id() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target QoS queue
+ *                 in PFE.
+ * @param[in]      p_cl   FCI client
+ * @param[in,out]  p_que  Local data struct which represents a new configuration of 
+ *                        the target QoS queue.
+ *                        Initial data can be obtained via demo_qos_que_get_by_id().
+ * @return        FPP_ERR_OK : Configuration of the target QoS queue was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             The local data struct not updated.
+ */
+int demo_qos_que_update(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_que)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_que);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_qos_queue_cmd_t cmd_to_fci = (*p_que);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_QOS_QUEUE, sizeof(fpp_qos_queue_cmd_t), 
+                                        (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_qos_que_get_by_id(p_cl, p_que, (p_que->if_name), (p_que->id));
+    }
+    
+    print_if_error(rtn, "demo_qos_que_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target QoS scheduler
+ *                 in PFE.
+ * @param[in]      p_cl   FCI client
+ * @param[in,out]  p_sch  Local data struct which represents a new configuration of 
+ *                        the target QoS scheduler.
+ *                        Initial data can be obtained via demo_qos_sch_get_by_id().
+ * @return        FPP_ERR_OK : Configuration of the target QoS scheduler was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             The local data struct not updated.
+ */
+int demo_qos_sch_update(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_sch);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_qos_scheduler_cmd_t cmd_to_fci = (*p_sch);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_QOS_SCHEDULER, sizeof(fpp_qos_scheduler_cmd_t), 
+                                                (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_qos_sch_get_by_id(p_cl, p_sch, (p_sch->if_name), (p_sch->id));
+    }
+    
+    print_if_error(rtn, "demo_qos_sch_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief          Use FCI calls to update configuration of a target QoS shaper
+ *                 in PFE.
+ * @param[in]      p_cl   FCI client
+ * @param[in,out]  p_shp  Local data struct which represents a new configuration of 
+ *                        the target QoS shaper.
+ *                        Initial data can be obtained via demo_qos_shp_get_by_id().
+ * @return        FPP_ERR_OK : Configuration of the target QoS shaper was
+ *                             successfully updated in PFE.
+ *                             The local data struct was automatically updated with 
+ *                             readback data from PFE.
+ *                other      : Some error occurred (represented by the respective error code).
+ *                             The local data struct not updated.
+ */
+int demo_qos_shp_update(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_shp);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_qos_shaper_cmd_t cmd_to_fci = (*p_shp);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_QOS_SHAPER, sizeof(fpp_qos_shaper_cmd_t), 
+                                             (unsigned short*)(&cmd_to_fci));
+    
+    /* read back and update caller data */
+    if (FPP_ERR_OK == rtn)
+    {
+        rtn = demo_qos_shp_get_by_id(p_cl, p_shp, (p_shp->if_name), (p_shp->id));
+    }
+    
+    print_if_error(rtn, "demo_qos_shp_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_que  [localdata_que]
+ * @brief:      Functions marked as [localdata_que] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_que (a struct with configuration data).
+ *              Initial data for p_que can be obtained via demo_qos_que_get_by_id().
+ *              If some modifications are made to local data, then after all modifications
+ *              are done and finished, call demo_qos_que_update() to update
+ *              the configuration of a real QoS queue in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set a mode (queue discipline) of a QoS queue.
+ * @details        [localdata_que]
+ * @param[in,out]  p_que     Local data to be modified.
+ * @param[in]      que_mode  Queue mode (queue discipline).
+ *                           For valid modes, see FCI API Reference, 
+ *                           chapter 'fpp_qos_queue_cmd_t'.
+ */
+void demo_qos_que_ld_set_mode(fpp_qos_queue_cmd_t* p_que, uint8_t que_mode)
+{
+    assert(NULL != p_que);
+    p_que->mode = que_mode;
+}
+ 
+ 
+/*
+ * @brief          Set a minimal threshold of a QoS queue.
+ * @details        [localdata_que]
+ *                 Meaning of a minimal threshold depends on 
+ *                 a queue mode of the given QoS queue.
+ * @param[in,out]  p_que  Local data to be modified.
+ * @param[in]      min    Minimal threshold.
+ */
+void demo_qos_que_ld_set_min(fpp_qos_queue_cmd_t* p_que, uint32_t min)
+{
+    assert(NULL != p_que);
+    p_que->min = htonl(min);
+}
+ 
+ 
+/*
+ * @brief          Set a maximal threshold of a QoS queue.
+ * @details        [localdata_que]
+ *                 Meaning of a maximal threshold depends on 
+ *                 a queue mode of the given QoS queue.
+ * @param[in,out]  p_que  Local data to be modified.
+ * @param[in]      max    Maximal threshold.
+ */
+void demo_qos_que_ld_set_max(fpp_qos_queue_cmd_t* p_que, uint32_t max)
+{
+    assert(NULL != p_que);
+    p_que->max = htonl(max);
+}
+ 
+ 
+/*
+ * @brief          Set packet drop probability of a particular QoS queue's zone.
+ * @details        [localdata_que]
+ *                 Meaningful only for the que mode WRED.
+ * @param[in,out]  p_que     Local data to be modified.
+ * @param[in]      zprob_id  ID of a probability zone.
+ *                           There may be less than 32 zones actually implemented in PFE.
+ *                           (32 is just the max array limit)
+ *                           See FCI API Reference, chapter Egress QoS.
+ * @param[in]      percentage  Drop probability in [%].
+ */
+void demo_qos_que_ld_set_zprob(fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id, 
+                               uint8_t percentage)
+{
+    assert(NULL != p_que);
+    if (32u > zprob_id)
+    {
+        p_que->zprob[zprob_id] = percentage;
+    }
+}
+ 
+ 
+ 
+ 
+/*
+ * @defgroup    localdata_sch  [localdata_sch]
+ * @brief:      Functions marked as [localdata_sch] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_sch (a struct with configuration data).
+ *              Initial data for p_sch can be obtained via demo_qos_sch_get_by_id().
+ *              If some modifications are made to local data, then after all modifications
+ *              are done and finished, call demo_qos_sch_update() to update
+ *              the configuration of a real QoS scheduler in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set a mode of a QoS scheduler.
+ * @details        [localdata_sch]
+ * @param[in,out]  p_sch     Local data to be modified.
+ * @param[in]      sch_mode  Scheduler mode.
+ *                           For valid modes, see FCI API Reference, 
+ *                           chapter 'fpp_qos_scheduler_cmd_t'.
+ */
+void demo_qos_sch_ld_set_mode(fpp_qos_scheduler_cmd_t* p_sch, uint8_t sch_mode)
+{
+    assert(NULL != p_sch);
+    p_sch->mode = sch_mode;
+}
+ 
+ 
+/*
+ * @brief          Set a selection algorithm of a QoS scheduler.
+ * @details        [localdata_sch]
+ * @param[in,out]  p_sch  Local data to be modified.
+ * @param[in]      algo   Selection algorithm.
+ *                        For valid modes, see the FCI API Reference, 
+ *                        chapter 'fpp_qos_scheduler_cmd_t'.
+ */
+void demo_qos_sch_ld_set_algo(fpp_qos_scheduler_cmd_t* p_sch, uint8_t algo)
+{
+    assert(NULL != p_sch);
+    p_sch->algo = algo;
+}
+ 
+ 
+/*
+ * @brief          Set an input (and its properties) of a QoS scheduler.
+ * @details        [localdata_sch]
+ * @param[in,out]  p_sch     Local data to be modified.
+ * @param[in]      input_id  ID of the scheduler's input.
+ *                           There may be less than 32 inputs per scheduler 
+ *                           actually implemented in PFE. (32 is just the max array limit)
+ *                           See FCI API Reference, chapter Egress QoS.
+ *                 enable    Request to enable/disable the given scheduler input.
+ *                 src       Data source which is connected to the given sscheduler input.
+ *                           See FCI API Reference, chapter Egress QoS.
+ *                 weight    Weight ("importance") of the given scheduler input.
+ */
+void demo_qos_sch_ld_set_input(fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id, 
+                               bool enable, uint8_t src, uint32_t weight)
+{
+    assert(NULL != p_sch);
+    
+    if (32u > input_id)
+    {
+        if (enable)
+        {
+            p_sch->input_en |= htonl(1uL << input_id);
+        }
+        else
+        {
+            p_sch->input_en &= htonl((uint32_t)(~(1uL << input_id)));
+        }
+        
+        p_sch->input_w[input_id] = htonl(weight);
+        p_sch->input_src[input_id] = src;
+    }
+}
+ 
+ 
+ 
+ 
+/*
+ * @defgroup    localdata_shp  [localdata_shp]
+ * @brief:      Functions marked as [localdata_shp] access only local data.
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_shp (a struct with configuration data).
+ *              Initial data for p_shp can be obtained via demo_qos_shp_get_by_id().
+ *              If some modifications are made to local data, then after all modifications
+ *              are done and finished, call demo_shp_sch_update() to update
+ *              the configuration of a real QoS shaper in PFE.
+ */
+ 
+ 
+/*
+ * @brief          Set a mode of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp     Local data to be modified.
+ * @param[in]      shp_mode  Shaper mode.
+ *                           For valid modes, see FCI API Reference, 
+ *                           chapter 'fpp_qos_shaper_cmd_t'.
+ */
+void demo_qos_shp_ld_set_mode(fpp_qos_shaper_cmd_t* p_shp, uint8_t shp_mode)
+{
+    assert(NULL != p_shp);
+    p_shp->mode = shp_mode;
+}
+ 
+ 
+/*
+ * @brief          Set a position of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp     Local data to be modified.
+ * @param[in]      position  Position of the QoS shaper in a QoS configuration.
+ *                           For valid positions, see FCI API Reference, chapter Egress QoS.
+ */
+void demo_qos_shp_ld_set_position(fpp_qos_shaper_cmd_t* p_shp, uint8_t position)
+{
+    assert(NULL != p_shp);
+    p_shp->position = position;
+}
+ 
+ 
+/*
+ * @brief          Set an idle slope rate of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp  Local data to be modified.
+ * @param[in]      isl    Idle slope rate (units per second).
+ *                        Units depend on the mode of a QoS shaper.
+ */
+void demo_qos_shp_ld_set_isl(fpp_qos_shaper_cmd_t* p_shp, uint32_t isl)
+{
+    assert(NULL != p_shp);
+    p_shp->isl = htonl(isl);
+}
+ 
+ 
+/*
+ * @brief          Set a minimal credit of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp       Local data to be modified.
+ * @param[in]      min_credit  Minimal credit.
+ */
+void demo_qos_shp_ld_set_min_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t min_credit)
+{
+    assert(NULL != p_shp);
+    p_shp->min_credit = (int32_t)(htonl(min_credit));
+}
+ 
+ 
+/*
+ * @brief          Set a maximal credit of a QoS shaper.
+ * @details        [localdata_shp]
+ * @param[in,out]  p_shp       Local data to be modified.
+ * @param[in]      min_credit  Maximal credit.
+ */
+void demo_qos_shp_ld_set_max_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t max_credit)
+{
+    assert(NULL != p_shp);
+    p_shp->max_credit = (int32_t)(htonl(max_credit));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query the name of a parent physical interface of a QoS queue.
+ * @details    [localdata_que]
+ * @param[in]  p_que  Local data to be queried.
+ * @return     Name of a parent physical interface.
+ */
+const char* demo_qos_que_ld_get_if_name(const fpp_qos_queue_cmd_t* p_que)
+{
+    assert(p_que);
+    return (p_que->if_name);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a QoS queue.
+ * @details    [localdata_que]
+ * @param[in]  p_que  Local data to be queried.
+ * @return     ID of a QoS queue.
+ */
+uint8_t demo_qos_que_ld_get_id(const fpp_qos_queue_cmd_t* p_que)
+{
+    assert(p_que);
+    return (p_que->id);
+}
+ 
+ 
+/*
+ * @brief      Query the mode of a QoS queue.
+ * @details    [localdata_que]
+ * @param[in]  p_que  Local data to be queried.
+ * @return     Mode of a QoS queue.
+ */
+uint8_t demo_qos_que_ld_get_mode(const fpp_qos_queue_cmd_t* p_que)
+{
+    assert(p_que);
+    return (p_que->mode);
+}
+ 
+ 
+/*
+ * @brief      Query the minimal threshold of a QoS queue.
+ * @details    [localdata_que]
+ * @param[in]  p_que  Local data to be queried.
+ * @return     Minimal threshold of a QoS queue.
+ */
+uint32_t demo_qos_que_ld_get_min(const fpp_qos_queue_cmd_t* p_que)
+{
+    assert(p_que);
+    return ntohl(p_que->min);
+}
+ 
+ 
+/*
+ * @brief      Query the maximal threshold of a QoS queue.
+ * @details    [localdata_que]
+ * @param[in]  p_que  Local data to be queried.
+ * @return     Maximal threshold of a QoS queue.
+ */
+uint32_t demo_qos_que_ld_get_max(const fpp_qos_queue_cmd_t* p_que)
+{
+    assert(p_que);
+    return ntohl(p_que->max);
+}
+ 
+ 
+/*
+ * @brief      Query the percentage chance for packet drop.
+ * @details    [localdata_que]
+ * @param[in]  p_que     Local data to be queried.
+ * @param[in]  zprob_id  ID of a probability zone.
+ *                       There may be less than 32 zones actually implemented in PFE.
+ *                       (32 is just the max array limit)
+ *                       See FCI API Reference, chapter Egress QoS.
+ * @return     Percentage drop chance of the given probability zone.
+ */
+uint8_t demo_qos_que_ld_get_zprob_by_id(const fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id)
+{
+    assert(p_que);
+    return ((32u > zprob_id) ? (p_que->zprob[zprob_id]) : (255u));
+}
+ 
+ 
+ 
+ 
+ /*
+ * @brief      Query the name of a parent physical interface of a QoS scheduler.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch  Local data to be queried.
+ * @return     Name of a parent physical interface.
+ */
+const char* demo_qos_sch_ld_get_if_name(const fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(p_sch);
+    return (p_sch->if_name);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a QoS scheduler.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch  Local data to be queried.
+ * @return     ID of a QoS scheduler.
+ */
+uint8_t demo_qos_sch_ld_get_id(const fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(p_sch);
+    return (p_sch->id);
+}
+ 
+ 
+/*
+ * @brief      Query the mode of a QoS scheduler.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch  Local data to be queried.
+ * @return     Mode of a QoS scheduler.
+ */
+uint8_t demo_qos_sch_ld_get_mode(const fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(p_sch);
+    return (p_sch->mode);
+}
+ 
+ 
+/*
+ * @brief      Query the selection algorithm of a QoS scheduler.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch  Local data to be queried.
+ * @return     Selection algorithm of a QoS scheduler.
+ */
+uint8_t demo_qos_sch_ld_get_algo(const fpp_qos_scheduler_cmd_t* p_sch)
+{
+    assert(p_sch);
+    return (p_sch->algo);
+}
+ 
+ 
+/*
+ * @brief      Query whether an input of a QoS scheduler is enabled or not.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch     Local data to be queried.
+ * @param[in]  input_id  Queried scheduler input.
+ * @return     At time when the data was obtained from PFE, the input of the QoS scheduler:
+ *             true  : was enabled
+ *             false : was disabled
+ */
+bool demo_qos_sch_ld_is_input_enabled(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id)
+{
+    assert(NULL != p_sch);
+    return (bool)((32u > input_id) ? (ntohl(p_sch->input_en) & (1uL << input_id)) : (0u));
+}
+ 
+ 
+/*
+ * @brief      Query the weight of a QoS scheduler input.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch     Local data to be queried.
+ * @param[in]  input_id  Queried scheduler input.
+ * @return     Weight of a QoS scheduler input.
+ */
+uint32_t demo_qos_sch_ld_get_input_weight(const fpp_qos_scheduler_cmd_t* p_sch, 
+                                          uint8_t input_id)
+{
+    assert(NULL != p_sch);
+    return ((32u > input_id) ? (ntohl(p_sch->input_w[input_id])) : (0uL));
+}
+ 
+ 
+/*
+ * @brief      Query the traffic source of a QoS scheduler input.
+ * @details    [localdata_sch]
+ * @param[in]  p_sch     Local data to be queried.
+ * @param[in]  input_id  Queried scheduler input.
+ * @return     Traffic source of a QoS scheduler input.
+ */
+uint8_t demo_qos_sch_ld_get_input_src(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id)
+{
+    assert(NULL != p_sch);
+    return ((32u > input_id) ? (p_sch->input_src[input_id]) : (0uL));
+}
+ 
+ 
+ 
+ 
+ /*
+ * @brief      Query the name of a parent physical interface of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     Name of a parent physical interface.
+ */
+const char* demo_qos_shp_ld_get_if_name(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return (p_shp->if_name);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     ID of a QoS shaper.
+ */
+uint8_t demo_qos_shp_ld_get_id(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return (p_shp->id);
+}
+ 
+ 
+ /*
+ * @brief      Query the position of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     Position of a QoS shaper.
+ */
+uint8_t demo_qos_shp_ld_get_position(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return (p_shp->position);
+}
+ 
+ 
+/*
+ * @brief      Query the mode of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     Mode of a QoS shaper.
+ */
+uint8_t demo_qos_shp_ld_get_mode(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return (p_shp->mode);
+}
+ 
+ 
+/*
+ * @brief      Query the idle slope of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     Idle slope of a QoS shaper.
+ */
+uint32_t demo_qos_shp_ld_get_isl(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return ntohl(p_shp->isl);
+}
+ 
+ 
+/*
+ * @brief      Query the maximal credit of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     Maximal credit of a QoS shaper.
+ */
+int32_t demo_qos_shp_ld_get_max_credit(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return (int32_t)(ntohl(p_shp->max_credit));
+}
+ 
+ 
+/*
+ * @brief      Query the minimal credit of a QoS shaper.
+ * @details    [localdata_shp]
+ * @param[in]  p_shp  Local data to be queried.
+ * @return     Minimal credit of a QoS shaper.
+ */
+int32_t demo_qos_shp_ld_get_min_credit(const fpp_qos_shaper_cmd_t* p_shp)
+{
+    assert(p_shp);
+    return (int32_t)(ntohl(p_shp->min_credit));
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available QoS queues of 
+ *             a given physical interface and execute a callback print function for 
+ *             each QoS queue.
+ * @param[in]  p_cl          FCI client
+ * @param[in]  p_cb_print    Callback print function.
+ *                           --> If the callback returns ZERO, then all is OK and 
+ *                               a next QoS queue is picked for a print process.
+ *                           --> If the callback returns NON-ZERO, then some problem is 
+ *                               assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name  Name of a parent physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through all available QoS queues of 
+ *                          the given physical interface.
+ *             other      : Some error occurred (represented by the respective error code).
+ *                          No count was stored.
+ */
+int demo_qos_que_print_by_phyif(FCI_CLIENT* p_cl, demo_qos_que_cb_print_t p_cb_print, 
+                                const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_queue_cmd_t cmd_to_fci = {0};
+    fpp_qos_queue_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t que_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = que_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
+                            sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+            }
+            
+            que_id++;
+        }
+        
+        /* query loop runs till there are no more QoS queues to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_QUEUE_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    print_if_error(rtn, "demo_qos_que_print_by_phyif() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available QoS queues in PFE which
+ *              are a part of a given parent physical interface.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_count   Space to store the count of QoS queues.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted all applicable QoS queues.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_qos_que_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                                    const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_queue_cmd_t cmd_to_fci = {0};
+    fpp_qos_queue_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t que_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = que_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
+                            sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                que_id++;
+            }
+        }
+        
+        /* query loop runs till there are no more QoS queues to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_QUEUE_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = que_id;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    print_if_error(rtn, "demo_qos_que_get_count_by_phyif() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available QoS schedulers of
+ *             a given physical interface and execute a callback print function for 
+ *             each QoS scheduler.
+ * @param[in]  p_cl          FCI client
+ * @param[in]  p_cb_print    Callback print function.
+ *                           --> If the callback returns ZERO, then all is OK and 
+ *                               a next QoS scheduler is picked for a print process.
+ *                           --> If the callback returns NON-ZERO, then some problem is 
+ *                               assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name  Name of a parent physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through QoS schedulers of 
+ *                          the given physical interface.
+ *             other      : Some error occurred (represented by the respective error code).
+ *                          No count was stored.
+ */
+int demo_qos_sch_print_by_phyif(FCI_CLIENT* p_cl, demo_qos_sch_cb_print_t p_cb_print, 
+                                const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
+    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t sch_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = sch_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
+                            sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+            }
+            
+            sch_id++;
+        }
+        
+        /* query loop runs till there are no more QoS schedulers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SCHEDULER_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    print_if_error(rtn, "demo_qos_sch_print_by_phyif() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available QoS schedulers in PFE which
+ *              are a part of a given parent physical interface.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_count   Space to store the count of QoS schedulers.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted all applicable QoS schedulers.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_qos_sch_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                                    const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
+    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t sch_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = sch_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
+                            sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                sch_id++;
+            }
+        }
+        
+        /* query loop runs till there are no more QoS schedulers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SCHEDULER_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = sch_id;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    print_if_error(rtn, "demo_qos_sch_get_count_by_phyif() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available QoS shapers of 
+ *             a given physical interface and execute a callback print function for 
+ *             each QoS shaper.
+ * @param[in]  p_cl          FCI client
+ * @param[in]  p_cb_print    Callback print function.
+ *                           --> If the callback returns ZERO, then all is OK and 
+ *                               a next QoS shaper is picked for a print process.
+ *                           --> If the callback returns NON-ZERO, then some problem is 
+ *                               assumed and this function terminates prematurely.
+ * @param[in]  p_phyif_name  Name of a parent physical interface.
+ *                           Names of physical interfaces are hardcoded.
+ *                           See FCI API Reference, chapter Interface Management.
+ * @return     FPP_ERR_OK : Successfully iterated through all available QoS shapers of 
+ *                          the given physical interface.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_qos_shp_print_by_phyif(FCI_CLIENT* p_cl, demo_qos_shp_cb_print_t p_cb_print, 
+                                const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
+    fpp_qos_shaper_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t shp_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = shp_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
+                            sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                rtn = p_cb_print(&reply_from_fci);
+            }
+            
+            shp_id++;
+        }
+        
+        /* query loop runs till there are no more QoS shapers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SHAPER_NOT_FOUND == rtn)
+        {
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    print_if_error(rtn, "demo_qos_shp_print_by_phyif() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available QoS shapers in PFE which
+ *              are a part of a given parent physical interface.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_count   Space to store the count of QoS shapers.
+ * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted all applicable QoS shapers.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_qos_shp_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                                    const char* p_phyif_name)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_phyif_name);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
+    fpp_qos_shaper_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* prepare data */
+    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
+    
+    /* do the query */
+    if (FPP_ERR_OK == rtn)
+    {
+        /* query loop */
+        uint8_t shp_id = 0u;
+        while (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.id = shp_id;
+            cmd_to_fci.action = FPP_ACTION_QUERY;
+            rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
+                            sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+            
+            if (FPP_ERR_OK == rtn)
+            {
+                shp_id++;
+            }
+        }
+        
+        /* query loop runs till there are no more QoS shapers to report */
+        /* the following error is therefore OK and expected (it ends the query loop) */
+        if (FPP_ERR_QOS_SHAPER_NOT_FOUND == rtn)
+        {
+            *p_rtn_count = shp_id;
+            rtn = FPP_ERR_OK;
+        }
+    }
+    
+    print_if_error(rtn, "demo_qos_shp_get_count_by_phyif() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_qos.h b/sw/libfci_cli/src/libfci_demo/demo_qos.h
new file mode 100644
index 0000000..fdcbe92
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_qos.h
@@ -0,0 +1,113 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+
+#ifndef DEMO_QOS_H_
+#define DEMO_QOS_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*demo_qos_que_cb_print_t)(const fpp_qos_queue_cmd_t* p_que);
+typedef int (*demo_qos_sch_cb_print_t)(const fpp_qos_scheduler_cmd_t* p_sch);
+typedef int (*demo_qos_shp_cb_print_t)(const fpp_qos_shaper_cmd_t* p_shp);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+
+int demo_qos_que_get_by_id(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_rtn_que, const char* p_phyif_name, uint8_t que_id);
+int demo_qos_sch_get_by_id(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_rtn_sch, const char* p_phyif_name, uint8_t sch_id);
+int demo_qos_shp_get_by_id(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_rtn_shp, const char* p_phyif_name, uint8_t shp_id);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+
+int demo_qos_que_update(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_que);
+int demo_qos_sch_update(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_sch);
+int demo_qos_shp_update(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_shp);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+void demo_qos_que_ld_set_mode(fpp_qos_queue_cmd_t* p_que, uint8_t que_mode);
+void demo_qos_que_ld_set_min(fpp_qos_queue_cmd_t* p_que, uint32_t min);
+void demo_qos_que_ld_set_max(fpp_qos_queue_cmd_t* p_que, uint32_t max);
+void demo_qos_que_ld_set_zprob(fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id, uint8_t percentage);
+
+void demo_qos_sch_ld_set_mode(fpp_qos_scheduler_cmd_t* p_sch, uint8_t sch_mode);
+void demo_qos_sch_ld_set_algo(fpp_qos_scheduler_cmd_t* p_sch, uint8_t algo);
+void demo_qos_sch_ld_set_input(fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id, bool enable, uint8_t src, uint32_t weight);
+
+void demo_qos_shp_ld_set_mode(fpp_qos_shaper_cmd_t* p_shp, uint8_t shp_mode);
+void demo_qos_shp_ld_set_position(fpp_qos_shaper_cmd_t* p_shp, uint8_t position);
+void demo_qos_shp_ld_set_isl(fpp_qos_shaper_cmd_t* p_shp, uint32_t isl);
+void demo_qos_shp_ld_set_min_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t min_credit);
+void demo_qos_shp_ld_set_max_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t max_credit);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+const char* demo_qos_que_ld_get_if_name(const fpp_qos_queue_cmd_t* p_que);
+uint8_t     demo_qos_que_ld_get_id(const fpp_qos_queue_cmd_t* p_que);
+uint8_t     demo_qos_que_ld_get_mode(const fpp_qos_queue_cmd_t* p_que);
+uint32_t    demo_qos_que_ld_get_min(const fpp_qos_queue_cmd_t* p_que);
+uint32_t    demo_qos_que_ld_get_max(const fpp_qos_queue_cmd_t* p_que);
+uint8_t     demo_qos_que_ld_get_zprob_by_id(const fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id);
+
+const char* demo_qos_sch_ld_get_if_name(const fpp_qos_scheduler_cmd_t* p_sch);
+uint8_t     demo_qos_sch_ld_get_id(const fpp_qos_scheduler_cmd_t* p_sch);
+uint8_t     demo_qos_sch_ld_get_mode(const fpp_qos_scheduler_cmd_t* p_sch);
+uint8_t     demo_qos_sch_ld_get_algo(const fpp_qos_scheduler_cmd_t* p_sch);
+bool        demo_qos_sch_ld_is_input_enabled(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id);
+uint32_t    demo_qos_sch_ld_get_input_weight(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id);
+uint8_t     demo_qos_sch_ld_get_input_src(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id);
+
+const char* demo_qos_shp_ld_get_if_name(const fpp_qos_shaper_cmd_t* p_shp);
+uint8_t     demo_qos_shp_ld_get_id(const fpp_qos_shaper_cmd_t* p_shp);
+uint8_t     demo_qos_shp_ld_get_position(const fpp_qos_shaper_cmd_t* p_shp);
+uint8_t     demo_qos_shp_ld_get_mode(const fpp_qos_shaper_cmd_t* p_shp);
+uint32_t    demo_qos_shp_ld_get_isl(const fpp_qos_shaper_cmd_t* p_shp);
+int32_t     demo_qos_shp_ld_get_max_credit(const fpp_qos_shaper_cmd_t* p_shp);
+int32_t     demo_qos_shp_ld_get_min_credit(const fpp_qos_shaper_cmd_t* p_shp);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int demo_qos_que_print_by_phyif(FCI_CLIENT* p_cl, demo_qos_que_cb_print_t p_cb_print, const char* p_phyif_name);
+int demo_qos_que_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, const char* p_parent_name);
+
+int demo_qos_sch_print_by_phyif(FCI_CLIENT* p_cl, demo_qos_sch_cb_print_t p_cb_print, const char* p_phyif_name);
+int demo_qos_sch_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, const char* p_parent_name);
+
+int demo_qos_shp_print_by_phyif(FCI_CLIENT* p_cl, demo_qos_shp_cb_print_t p_cb_print, const char* p_phyif_name);
+int demo_qos_shp_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, const char* p_parent_name);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c
new file mode 100644
index 0000000..4c313cf
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.c
@@ -0,0 +1,2069 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+ 
+ 
+#include <assert.h>
+#include <string.h>
+#include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+ 
+#include "demo_common.h"
+#include "demo_rt_ct.h"
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested route from PFE.
+ *              Identify the route by its ID.
+ * @param[in]   p_cl      FCI client
+ * @param[out]  p_rtn_rt  Space for data from PFE.
+ * @param[in]   id        ID of the requested route.
+ *                        Route IDs are user-defined. See demo_rt_add().
+ * @return      FPP_ERR_OK : The requested route was found.
+ *                           A copy of its configuration data was stored into p_rtn_rt.
+ *                           REMINDER: Data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_rt_get_by_id(FCI_CLIENT* p_cl, fpp_rt_cmd_t* p_rtn_rt, uint32_t id)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_rt);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    fpp_rt_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) && (ntohl(reply_from_fci.id) != id))
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                        sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_rt = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_rt_get_by_id() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested IPv4 conntrack 
+ *              from PFE. Identify the conntrack by a specific tuple of parameters.
+ * @param[in]   p_cl       FCI client
+ * @param[out]  p_rtn_ct   Space for data from PFE.
+ * @param[in]   p_ct_data  Configuration data for IPv4 conntrack identification.
+ *                         To identify a conntrack, all the following data must be 
+ *                         correctly set:
+ *                           --> protocol
+ *                           --> saddr
+ *                           --> daddr
+ *                           --> sport
+ *                           --> dport
+ *                         REMINDER: It is assumed that data are in a network byte order.
+ * @return      FPP_ERR_OK : The requested IPv4 conntrack was found.
+ *                           A copy of its configuration was stored into p_rtn_ct.
+ *                           REMINDER: Data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_ct_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct_cmd_t* p_rtn_ct, 
+                                     const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_ct);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    fpp_ct_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) &&
+           !(
+             /* both sides are in network byte order (thus no byte order conversion needed) */
+             ((reply_from_fci.protocol) == (p_ct_data->protocol)) && 
+             ((reply_from_fci.sport) == (p_ct_data->sport)) && 
+             ((reply_from_fci.dport) == (p_ct_data->dport)) &&
+             ((reply_from_fci.saddr) == (p_ct_data->saddr)) && 
+             ((reply_from_fci.daddr) == (p_ct_data->daddr))
+            )
+          )
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                        sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_ct = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_ct_get_by_tuple() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get configuration data of a requested IPv6 conntrack 
+ *              from PFE. Identify the conntrack by a specific tuple of parameters.
+ * @param[in]   p_cl        FCI client
+ * @param[out]  p_rtn_ct6   Space for data from PFE.
+ * @param[in]   p_ct6_data  Configuration data for IPv6 conntrack identification.
+ *                          To identify a conntrack, all the following data must be 
+ *                          correctly set:
+ *                            --> protocol
+ *                            --> saddr
+ *                            --> daddr
+ *                            --> sport
+ *                            --> dport
+ *                          REMINDER: It is assumed that data are in a network byte order.
+ * @return      FPP_ERR_OK : The requested IPv6 conntrack was found.
+ *                           A copy of its configuration was stored into p_rtn_ct6.
+ *                           REMINDER: Data from PFE are in a network byte order.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No data copied.
+ */
+int demo_ct6_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct6_cmd_t* p_rtn_ct6, 
+                                      const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_ct6);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    fpp_ct6_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop (with a search condition) */
+    while ((FPP_ERR_OK == rtn) &&
+           !(
+             /* both sides are in network byte order (thus no byte order conversion needed) */
+             ((reply_from_fci.protocol) == (p_ct6_data->protocol)) && 
+             ((reply_from_fci.sport) == (p_ct6_data->sport)) && 
+             ((reply_from_fci.dport) == (p_ct6_data->dport)) &&
+             (0 == memcmp(reply_from_fci.saddr, p_ct6_data->saddr, (4 * sizeof(uint32_t)))) &&
+             (0 == memcmp(reply_from_fci.daddr, p_ct6_data->daddr, (4 * sizeof(uint32_t))))
+            )
+          )
+    {
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                        sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* if a query is successful, then assign the data */
+    if (FPP_ERR_OK == rtn)
+    {
+        *p_rtn_ct6 = reply_from_fci;
+    }
+    
+    print_if_error(rtn, "demo_ct6_get_by_tuple() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+ 
+ 
+/*
+ * @brief       Use FCI calls to update configuration of a target IPv4 conntrack in PFE.
+ * @details     For conntracks, only a few selected parameters can be modified.
+ *              See FCI API Reference, chapter FPP_CMD_IPV4_CONNTRACK, 
+ *              subsection "Action FPP_ACTION_UPDATE".
+ * @param[in]   p_cl       FCI client
+ * @param[in]   p_ct_data  Local data struct which represents a new configuration of 
+ *                         the target IPv4 conntrack.
+ *                         Initial data can be obtained via demo_ct_get_by_tuple().
+ * @return      FPP_ERR_OK : Configuration of the target IPv4 conntrack was
+ *                           successfully updated in PFE.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_update(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct_data;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to update configuration of a target IPv6 conntrack in PFE.
+ * @details     For conntracks, only a few selected parameters can be modified.
+ *              See FCI API Reference, chapter FPP_CMD_IPV6_CONNTRACK, 
+ *              subsection "Action FPP_ACTION_UPDATE".
+ * @param[in]   p_cl        FCI client
+ * @param[in]   p_ct6_data  Local data struct which represents a new configuration of 
+ *                          the target IPv6 conntrack.
+ *                          Initial data can be obtained via demo_ct6_get_by_tuple().
+ * @return      FPP_ERR_OK : Configuration of the target IPv6 conntrack was
+ *                           successfully updated in PFE.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct6_update(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct6_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct6_data;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_UPDATE;
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct6_update() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief       Use FCI calls to set timeout for IPv4 TCP conntracks in PFE.
+ * @param[in]   p_cl     FCI client
+ * @param[in]   timeout  Timeout [seconds]
+ * @return      FPP_ERR_OK : New timeout was set.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_timeout_tcp(FCI_CLIENT* p_cl, uint32_t timeout)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_timeout_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.protocol = htons(6u);  /* 6 == tcp */
+    cmd_to_fci.timeout_value1 = htonl(timeout);
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+                                                   (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct_timeout_tcp() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to set timeout for IPv4 UDP conntracks in PFE.
+ * @param[in]   p_cl      FCI client
+ * @param[in]   timeout   Timeout [seconds]
+ * @return      FPP_ERR_OK : New timeout was set.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_timeout_udp(FCI_CLIENT* p_cl, uint32_t timeout)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_timeout_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.protocol = htons(17u);  /* 17 == udp */
+    cmd_to_fci.timeout_value1 = htonl(timeout);
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+                                                   (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct_timeout_udp() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to set timeout for all other IPv4 conntracks than TCP/UDP ones.
+ * @param[in]   p_cl     FCI client
+ * @param[in]   timeout  Timeout [seconds]
+ * @return      FPP_ERR_OK : New timeout was set.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_timeout_others(FCI_CLIENT* p_cl, uint32_t timeout)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_timeout_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.protocol = htons(0u);  /* 0 == others */
+    cmd_to_fci.timeout_value1 = htonl(timeout);
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+                                                   (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct_timeout_others() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new route in PFE.
+ * @details     In the context of PFE, a "route" is a configuration data element that 
+ *              specifies which physical interface of PFE shall be used as an egress interface
+ *              and what destination MAC address shall be set in the routed traffic.
+ *              These "routes" are used as a part of IPv4/IPv6 conntracks.
+ * @param[in]   p_cl       FCI client
+ * @param[in]   id         ID of the new route.
+ * @param[in]   p_rt_data  Configuration data of the new route.
+ *                         To create a new route, a local data struct must be created,
+ *                         configured and then passed to this function.
+ *                         See [localdata_rt] to learn more.
+ * @return      FPP_ERR_OK : New route was created.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_rt_add(FCI_CLIENT* p_cl, uint32_t id, const fpp_rt_cmd_t* p_rt_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rt_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_rt_data;
+    cmd_to_fci.id = htonl(id);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
+                                           (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_rt_add() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target route in PFE.
+ * @param[in]   p_cl  FCI client
+ * @param[in]   id    ID of the route to destroy.
+ * @return      FPP_ERR_OK : The route was destroyed.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_rt_del(FCI_CLIENT* p_cl, uint32_t id)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci.id = htonl(id);
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
+                                           (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_rt_del() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new IPv4 conntrack in PFE.
+ * @param[in]   p_cl       FCI client
+ * @param[in]   p_ct_data  Configuration data of the new IPv4 conntrack.
+ *                         To create a new IPv4 conntrack, a local data struct must 
+ *                         be created, configured and then passed to this function.
+ *                         See [localdata_ct] to learn more.
+ * @return      FPP_ERR_OK : New IPv4 conntrack was created.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_add(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct_data;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct_add() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target IPv4 conntrack in PFE.
+ * @param[in]   p_cl       FCI client
+ * @param[in]   p_ct_data  Configuration data for IPv4 conntrack identification.
+ *                         To identify a conntrack, all the following data must be 
+ *                         correctly set:
+ *                           --> protocol
+ *                           --> saddr
+ *                           --> daddr
+ *                           --> sport
+ *                           --> dport
+ *                         REMINDER: It is assumed that data are in a network byte order.
+ * @return      FPP_ERR_OK : The IPv4 conntrack was destroyed.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_del(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct_data;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct_del() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief       Use FCI calls to create a new IPv6 conntrack in PFE.
+ * @param[in]   p_cl        FCI client
+ * @param[in]   p_ct6_data  Configuration data of the new IPv6 conntrack.
+ *                          To create a new IPv6 conntrack, a local data struct must 
+ *                          be created, configured and then passed to this function.
+ *                          See [localdata_ct6] to learn more.
+ * @return      FPP_ERR_OK : New IPv6 conntrack was created.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct6_add(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct6_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct6_data;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_REGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct6_add() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to destroy the target IPv6 conntrack in PFE.
+ * @param[in]   p_cl        FCI client
+ * @param[in]   p_ct6_data  Configuration data for IPv6 conntrack identification.
+ *                          To identify a conntrack, all the following data must be 
+ *                          correctly set:
+ *                            --> protocol
+ *                            --> saddr
+ *                            --> daddr
+ *                            --> sport
+ *                            --> dport
+ *                          REMINDER: It is assumed that data are in a network byte order.
+ * @return      FPP_ERR_OK : The IPv6 conntrack was destroyed.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct6_del(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_ct6_data);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    
+    /* prepare data */
+    cmd_to_fci = *p_ct6_data;
+    
+    /* send data */
+    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+                                                 (unsigned short*)(&cmd_to_fci));
+    
+    print_if_error(rtn, "demo_ct6_del() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief       Use FCI calls to reset (clear) all IPv4 routes & conntracks in PFE.
+ * @param[in]   p_cl  FCI client
+ * @return      FPP_ERR_OK : All IPv4 routes & conntracks were cleared.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_rtct_reset_ip4(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    /* prepare data */
+    /* empty */
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV4_RESET, 0, NULL);
+    
+    print_if_error(rtn, "demo_rtct_reset_ip4() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to reset (clear) all IPv6 routes & conntracks in PFE.
+ * @param[in]   p_cl  FCI clientf
+ * @return      FPP_ERR_OK : All IPv6 routes & conntracks were cleared.
+ *              other      : Some error occurred (represented by the respective error code).
+ */
+int demo_rtct_reset_ip6(FCI_CLIENT* p_cl)
+{
+    assert(NULL != p_cl);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    /* prepare data */
+    /* empty */
+    
+    /* send data */
+    rtn = fci_write(p_cl, FPP_CMD_IPV6_RESET, 0, NULL);
+    
+    print_if_error(rtn, "demo_rtct_reset_ip6() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+/*
+ * @defgroup    localdata_rt  [localdata_rt]
+ * @brief:      Functions marked as [localdata_rt] access only local data. 
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_rt (a struct with configuration data).
+ *              When adding a new route, there are no "initial data" to be obtained from PFE.
+ *              Simply declare a local data struct and configure it.
+ *              Then, after all modifications are done and finished,
+ *              call demo_rt_add() to create a new route in PFE.
+ *              REMINDER: In the context of PFE, a "route" is a configuration data element
+ *                        which is used as a part of IPv4/IPv6 conntracks.
+ */
+ 
+ 
+/*
+ * @brief          Set a route as an IPv4 route. If the route was previously set as 
+ *                 an IPv6 route, then the IPv6 flag is removed.
+ * @details        [localdata_rt]
+ *                 Symbol names are a bit confusing (inherited from another project).
+ *                 FPP_IP_ROUTE_6o4 == route is an IPv4 route
+ *                 FPP_IP_ROUTE_4o6 == route is an IPv6 route
+ *                 It is forbidden to set both flags at the same time (undefined behavior).
+ * @param[in,out]  p_rt  Local data to be modified.
+ */
+void demo_rt_ld_set_as_ip4(fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    p_rt->flags &= htonl(~FPP_IP_ROUTE_4o6);
+    p_rt->flags |= htonl(FPP_IP_ROUTE_6o4);
+}
+ 
+ 
+/*
+ * @brief          Set a route as an IPv6 route. If the route was previously set as
+ *                 an IPv4 route, then the IPv4 flag is removed.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                 Symbol names are a bit confusing (inherited from another project).
+ *                 FPP_IP_ROUTE_6o4 == route is an IPv4 route
+ *                 FPP_IP_ROUTE_4o6 == route is an IPv6 route
+ *                 It is forbidden to set both flags at the same time (undefined behavior).
+ * @param[in,out]  p_rt  Local data to be modified.
+ */
+void demo_rt_ld_set_as_ip6(fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    p_rt->flags &= htonl(~FPP_IP_ROUTE_6o4);
+    p_rt->flags |= htonl(FPP_IP_ROUTE_4o6);
+}
+ 
+ 
+/*
+ * @brief          Set a source MAC address of a route.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt  Local data to be modified.
+ *                 p_src_mac  Source MAC address.
+ */
+void demo_rt_ld_set_src_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_src_mac[6])
+{
+    assert(NULL != p_rt);
+    assert(NULL != p_src_mac);
+    memcpy((p_rt->src_mac), p_src_mac, (6 * sizeof(uint8_t)));
+}
+ 
+ 
+/*
+ * @brief          Set a destination MAC address of a route.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt       Local data to be modified.
+ *                 p_dst_mac  Destination MAC address.
+ */
+void demo_rt_ld_set_dst_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_dst_mac[6])
+{
+    assert(NULL != p_rt);
+    assert(NULL != p_dst_mac);
+    memcpy((p_rt->dst_mac), p_dst_mac, (6 * sizeof(uint8_t)));
+}
+ 
+ 
+/*
+ * @brief          Set an egress physical interface of a route.
+ * @details        [localdata_rt]
+ * @param[in,out]  p_rt          Local data to be modified.
+ * @param[in]      p_phyif_name  Name of a physical interface which shall be used as egress.
+ *                               Names of physical interfaces are hardcoded.
+ *                               See the FCI API Reference, chapter Interface Management.
+ */
+void demo_rt_ld_set_egress_phyif(fpp_rt_cmd_t* p_rt, const char* p_phyif_name)
+{
+    assert(NULL != p_rt);
+    assert(NULL != p_phyif_name);
+    set_text((p_rt->output_device), p_phyif_name, IFNAMSIZ);
+}
+ 
+ 
+ 
+ 
+/*
+ * @defgroup    localdata_ct  [localdata_ct]
+ * @brief:      Functions marked as [localdata_ct] access only local data. 
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_ct (a struct with configuration data).
+ *              When adding a new IPv4 conntrack, there are no "initial data" to be obtained 
+ *              from PFE. Simply declare a local data struct and configure it.
+ *              Then, after all modifications are done and finished,
+ *              call demo_ct_add() to create a new IPv4 conntrack in PFE. 
+ */
+ 
+ 
+/*
+ * @brief          Set a protocol type of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct      Local data to be modified.
+ * @param[in]      protocol  IP protocol ID
+ *                           See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ */
+void demo_ct_ld_set_protocol(fpp_ct_cmd_t* p_ct, uint16_t protocol)
+{
+    assert(NULL != p_ct);
+    p_ct->protocol = htons(protocol);
+}
+ 
+ 
+/*
+ * @brief          Set a ttl decrement flag of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ *                 If set, then the TTL value of a packet is decremented when
+ *                 the packet is routed by the IPv4 conntrack.
+ * @param[in,out]  p_ct  Local data to be modified.
+ * @param[in]      set   Request to enable/disable the ttl decrement.
+ */
+void demo_ct_ld_set_ttl_decr(fpp_ct_cmd_t* p_ct, bool set)
+{
+    assert(NULL != p_ct);
+    
+    if (set)
+    {
+        p_ct->flags |= htons(CTCMD_FLAGS_TTL_DECREMENT);
+    }
+    else
+    {
+        p_ct->flags &= htons((uint16_t)(~CTCMD_FLAGS_TTL_DECREMENT));
+    }
+}
+ 
+ 
+/*
+ * @brief          Set "orig direction" data of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct      Local data to be modified.
+ * @param[in]      saddr     IPv4 source address.
+ * @param[in]      daddr     IPv4 destination address.
+ * @param[in]      sport     Source port.
+ * @param[in]      dport     Destination port.
+ * @param[in]      vlan      VLAN tag.
+ *                             ZERO     : No VLAN tag modifications in this direction.
+ *                             non ZERO : --> If a packet is not tagged, 
+ *                                            then a VLAN tag is added.
+ *                                        --> If a packet is already tagged, 
+ *                                            then the VLAN tag is replaced.
+ * @param[in]      route_id  ID of a route for the orig direction.
+ *                           The route must already exist in PFE.
+ *                           See demo_rt_add().
+ * @param[in]      unidir_orig_only  Request to make the conntrack unidirectional
+ *                                   (orig direction only).
+ *                                   If true and the conntrack was previously 
+ *                                   configured as "reply direction only",
+ *                                   it gets newly reconfigured as "orig direction only".
+ */
+void demo_ct_ld_set_orig_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr, uint32_t daddr,
+                             uint16_t sport, uint16_t dport, uint16_t vlan, 
+                             uint32_t route_id, bool unidir_orig_only)
+{
+    assert(NULL != p_ct);
+    
+    p_ct->saddr = htonl(saddr);
+    p_ct->daddr = htonl(daddr);
+    p_ct->sport = htons(sport);
+    p_ct->dport = htons(dport);
+    p_ct->vlan  = htons(vlan);
+    p_ct->route_id = htonl(route_id);
+    
+    if (unidir_orig_only)
+    {
+        p_ct->route_id_reply = htonl(0u);
+        p_ct->flags |= htons(CTCMD_FLAGS_REP_DISABLED);
+        p_ct->flags &= htons((uint16_t)(~CTCMD_FLAGS_ORIG_DISABLED));
+    }
+}
+ 
+ 
+/*
+ * @brief          Set "reply direction" data of an IPv4 conntrack.
+ * @details        [localdata_ct]
+ * @param[in,out]  p_ct               Local data to be modified.
+ * @param[in]      saddr_reply        IPv4 source address (reply direction).
+ * @param[in]      daddr_reply        IPv4 destination address (reply direction).
+ * @param[in]      sport_reply        Source port (reply direction).
+ * @param[in]      dport_reply        Destination port (reply direction).
+ * @param[in]      vlan_reply         VLAN tag (reply direction).
+ *                                      ZERO     : No VLAN tag modifications in this direction
+ *                                      non ZERO : --> If a packet is not tagged, 
+ *                                                     then a VLAN tag is added.
+ *                                                 --> If a packet is already tagged, 
+ *                                                     then the VLAN tag is replaced.
+ * @param[in]      route_id_reply     ID of a route for the reply direction.
+ *                                    The route must already exist in PFE.
+ *                                    See demo_rt_add().
+ * @param[in]      unidir_reply_only  Request to make the conntrack unidirectional 
+ *                                    (reply direction only).
+ *                                    If true and the conntrack was previously 
+ *                                    configured as "orig direction only", 
+ *                                    it gets newly reconfigured as "reply direction only".
+ */
+void demo_ct_ld_set_reply_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr_reply, uint32_t daddr_reply,
+                              uint16_t sport_reply, uint16_t dport_reply, uint16_t vlan_reply,
+                              uint32_t route_id_reply, bool unidir_reply_only)
+{
+    assert(NULL != p_ct);
+    
+    p_ct->saddr_reply = htonl(saddr_reply);
+    p_ct->daddr_reply = htonl(daddr_reply);
+    p_ct->sport_reply = htons(sport_reply);
+    p_ct->dport_reply = htons(dport_reply);
+    p_ct->vlan_reply  = htons(vlan_reply);
+    p_ct->route_id_reply = htonl(route_id_reply);
+    
+    if (unidir_reply_only)
+    {
+        p_ct->route_id = htonl(0u);
+        p_ct->flags |= htons(CTCMD_FLAGS_ORIG_DISABLED);
+        p_ct->flags &= htons((uint16_t)(~CTCMD_FLAGS_REP_DISABLED));
+    }
+}
+ 
+ 
+ 
+ 
+/*
+ * @defgroup    localdata_ct6  [localdata_ct6]
+ * @brief:      Functions marked as [localdata_ct6] access only local data. 
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_ct6 (a struct with configuration data).
+ *              When adding a new IPv6 conntrack, there are no "initial data" to be obtained 
+ *              from PFE. Simply declare a local data struct and configure it.
+ *              Then, after all modifications are done and finished,
+ *              call demo_ct6_add() to create a new IPv6 conntrack in PFE. 
+ */
+ 
+ 
+/*
+ * @brief          Set a protocol type of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct6     Local data to be modified.
+ * @param[in]      protocol  IP protocol ID
+ *                           See "IANA Assigned Internet Protocol Number":
+ *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
+ */
+void demo_ct6_ld_set_protocol(fpp_ct6_cmd_t* p_ct6, uint16_t protocol)
+{
+    assert(NULL != p_ct6);
+    p_ct6->protocol = htons(protocol);
+}
+ 
+ 
+/*
+ * @brief          Set a ttl decrement flag of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ *                 If set, then the TTL value of a packet is decremented when
+ *                 the packet is routed by the IPv6 conntrack.
+ * @param[in,out]  p_ct6  Local data to be modified.
+ * @param[in]      set    Request to enable/disable the ttl decrement.
+ */
+void demo_ct6_ld_set_ttl_decr(fpp_ct6_cmd_t* p_ct6, bool set)
+{
+    assert(NULL != p_ct6);
+    
+    if (set)
+    {
+        p_ct6->flags |= htons(CTCMD_FLAGS_TTL_DECREMENT);
+    }
+    else
+    {
+        p_ct6->flags &= htons((uint16_t)(~CTCMD_FLAGS_TTL_DECREMENT));
+    }
+}
+ 
+ 
+/*
+ * @brief          Set "orig direction" data of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct6     Local data to be modified.
+ * @param[in]      p_saddr   IPv6 source address.
+ * @param[in]      p_daddr   IPv6 destination address.
+ * @param[in]      sport     Source port.
+ * @param[in]      dport     Destination port.
+ * @param[in]      vlan      VLAN tag
+ *                             ZERO     : No VLAN tag modifications in this direction.
+ *                             non ZERO : --> If a packet is not tagged, 
+ *                                            then a VLAN tag is added.
+ *                                        --> If a packet is already tagged, 
+ *                                            then the VLAN tag is replaced.
+ * @param[in]      route_id  ID of a route for the orig direction.
+ *                           The route must already exist in PFE.
+ *                           See demo_rt_add().
+ * @param[in]      unidir_orig_only  Request to make the conntrack unidirectional
+ *                                   (orig direction only).
+ *                                   If true and the conntrack was previously 
+ *                                   configured as "reply direction only",
+ *                                   it gets newly reconfigured as "orig direction only".
+ */
+void demo_ct6_ld_set_orig_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr[4],
+                              const uint32_t p_daddr[4],
+                              uint16_t sport, uint16_t dport, uint16_t vlan,
+                              uint32_t route_id, bool unidir_orig_only)
+{
+    assert(NULL != p_ct6);
+    assert(NULL != p_saddr);
+    assert(NULL != p_daddr);
+    
+    p_ct6->saddr[0] = htonl(p_saddr[0]);
+    p_ct6->saddr[1] = htonl(p_saddr[1]);
+    p_ct6->saddr[2] = htonl(p_saddr[2]);
+    p_ct6->saddr[3] = htonl(p_saddr[3]);
+    
+    p_ct6->daddr[0] = htonl(p_daddr[0]);
+    p_ct6->daddr[1] = htonl(p_daddr[1]);
+    p_ct6->daddr[2] = htonl(p_daddr[2]);
+    p_ct6->daddr[3] = htonl(p_daddr[3]);
+    
+    p_ct6->sport = htons(sport);
+    p_ct6->dport = htons(dport);
+    p_ct6->vlan  = htons(vlan);
+    p_ct6->route_id = htonl(route_id);
+    
+    if (unidir_orig_only)
+    {
+        p_ct6->route_id_reply = htonl(0u);
+        p_ct6->flags |= htons(CTCMD_FLAGS_REP_DISABLED);
+        p_ct6->flags &= htons((uint16_t)(~CTCMD_FLAGS_ORIG_DISABLED));
+    }
+}
+ 
+ 
+/*
+ * @brief          Set "reply direction" data of an IPv6 conntrack.
+ * @details        [localdata_ct6]
+ * @param[in,out]  p_ct6              Local data to be modified.
+ * @param[in]      p_saddr_reply      IPv6 source address (reply direction).
+ * @param[in]      p_daddr_reply      IPv6 destination address (reply direction).
+ * @param[in]      sport_reply        Source port (reply direction).
+ * @param[in]      dport_reply        Destination port (reply direction).
+ * @param[in]      vlan_reply         VLAN tag (reply direction).
+ *                                      ZERO     : No VLAN tag modifications in this direction
+ *                                      non ZERO : --> If a packet is not tagged, 
+ *                                                     then a VLAN tag is added.
+ *                                                 --> If a packet is already tagged, 
+ *                                                     then the VLAN tag is replaced.
+ * @param[in]      route_id_reply     ID of a route for the reply direction.
+ * @param[in]      unidir_reply_only  Request to make the conntrack unidirectional 
+ *                                    (reply direction only).
+ *                                    If true and the conntrack was previously 
+ *                                    configured as "orig direction only", 
+ *                                    it gets newly reconfigured as "reply direction only".
+ */
+void demo_ct6_ld_set_reply_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr_reply[4],
+                               const uint32_t p_daddr_reply[4],
+                               uint16_t sport_reply, uint16_t dport_reply,uint16_t vlan_reply,
+                               uint32_t route_id_reply, bool unidir_reply_only)
+{
+    assert(NULL != p_ct6);
+    assert(NULL != p_saddr_reply);
+    assert(NULL != p_daddr_reply);
+    
+    p_ct6->saddr_reply[0] = htonl(p_saddr_reply[0]);
+    p_ct6->saddr_reply[1] = htonl(p_saddr_reply[1]);
+    p_ct6->saddr_reply[2] = htonl(p_saddr_reply[2]);
+    p_ct6->saddr_reply[3] = htonl(p_saddr_reply[3]);
+    
+    p_ct6->daddr_reply[0] = htonl(p_daddr_reply[0]);
+    p_ct6->daddr_reply[1] = htonl(p_daddr_reply[1]);
+    p_ct6->daddr_reply[2] = htonl(p_daddr_reply[2]);
+    p_ct6->daddr_reply[3] = htonl(p_daddr_reply[3]);
+    
+    p_ct6->sport_reply = htons(sport_reply);
+    p_ct6->dport_reply = htons(dport_reply);
+    p_ct6->vlan_reply  = htons(vlan_reply);
+    p_ct6->route_id_reply = htonl(route_id_reply);
+    
+    if (unidir_reply_only)
+    {
+        p_ct6->route_id = htonl(0u);
+        p_ct6->flags |= htons(CTCMD_FLAGS_ORIG_DISABLED);
+        p_ct6->flags &= htons((uint16_t)(~CTCMD_FLAGS_REP_DISABLED));
+    }
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+ 
+ 
+/*
+ * @brief      Query whether a route is an IPv4 route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     The route:
+ *             true  : is an IPv4 route.
+ *             false : is NOT an IPv4 route.
+ */
+bool demo_rt_ld_is_ip4(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (bool)(ntohl(p_rt->flags) & FPP_IP_ROUTE_6o4);
+}
+ 
+ 
+/*
+ * @brief      Query whether a route is an IPv6 route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     The route:
+ *             true  : is an IPv6 route.
+ *             false : is NOT an IPv6 route.
+ */
+bool demo_rt_ld_is_ip6(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (bool)(ntohl(p_rt->flags) & FPP_IP_ROUTE_4o6);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of a route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     ID of the route.
+ */
+uint32_t demo_rt_ld_get_route_id(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return ntohl(p_rt->id);
+}
+ 
+ 
+/*
+ * @brief      Query the source MAC of a route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     Source MAC which shall be set in the routed traffic.
+ */
+const uint8_t* demo_rt_ld_get_src_mac(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (p_rt->src_mac);
+}
+ 
+ 
+/*
+ * @brief      Query the destination MAC of a route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     Destination MAC which shall be set in the routed traffic.
+ */
+const uint8_t* demo_rt_ld_get_dst_mac(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (p_rt->dst_mac);
+}
+ 
+ 
+/*
+ * @brief      Query the egress interface of a route.
+ * @details    [localdata_rt]
+ * @param[in]  p_rt  Local data to be queried.
+ * @return     Name of a physical interface whish shall be used as an egress interface.
+ */
+const char* demo_rt_ld_get_egress_phyif(const fpp_rt_cmd_t* p_rt)
+{
+    assert(NULL != p_rt);
+    return (p_rt->output_device);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query whether an IPv4 conntrack serves as a NAT.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : does serve as a NAT.
+ *             false : does NOT serve as a NAT.
+ */
+bool demo_ct_ld_is_nat(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    /* no need to transform byte order when comparing members of one struct */
+    return (bool)(((p_ct->daddr_reply) != (p_ct->saddr)) || 
+                  ((p_ct->saddr_reply) != (p_ct->daddr)));
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv4 conntrack serves as a PAT.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : does serve as a PAT.
+ *             false : does NOT serve as a PAT.
+ */
+bool demo_ct_ld_is_pat(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    /* no need to transform byte order when comparing members of one struct */
+    return (bool)(((p_ct->dport_reply) != (p_ct->sport)) || 
+                  ((p_ct->sport_reply) != (p_ct->dport)));
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv4 conntrack modifies VLAN tags.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : does modify VLAN tags of serviced packets.
+ *             false : does NOT modify VLAN tags of serviced packets.
+ */
+bool demo_ct_ld_is_vlan_tagging(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    /* no need to transform byte order when comparing with ZERO */
+    return (bool)((0u != p_ct->vlan) || (0u != p_ct->vlan_reply));
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv4 conntrack decrements packet's TTL counter or not.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPV4 conntrack:
+ *             true  : does decrement TTL counter.
+ *             false : does NOT decrement TTL counter.
+ */
+bool demo_ct_ld_is_ttl_decr(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(ntohs(p_ct->flags) & CTCMD_FLAGS_TTL_DECREMENT);
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv4 conntrack is orig direction only.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : is orig direction only.
+ *             false : is NOT orig direction only.
+ */
+bool demo_ct_ld_is_orig_only(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(ntohs(p_ct->flags) & CTCMD_FLAGS_REP_DISABLED);
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv4 conntrack is reply direction only.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     The IPv4 conntrack:
+ *             true  : is reply direction only.
+ *             false : is NOT reply direction only.
+ */
+bool demo_ct_ld_is_reply_only(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return (bool)(ntohs(p_ct->flags) & CTCMD_FLAGS_ORIG_DISABLED);
+}
+ 
+ 
+/*
+ * @brief      Query the protocol of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     IP Protocol ID
+ */
+uint16_t demo_ct_ld_get_protocol(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->protocol);
+}
+ 
+ 
+/*
+ * @brief      Query the source address of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Source IPv4 address.
+ */
+uint32_t demo_ct_ld_get_saddr(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->saddr);
+}
+ 
+ 
+/*
+ * @brief      Query the destination address of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Destination IPv4 address.
+ */
+uint32_t demo_ct_ld_get_daddr(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->daddr);
+}
+ 
+ 
+/*
+ * @brief      Query the source port of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Source port.
+ */
+uint16_t demo_ct_ld_get_sport(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->sport);
+}
+ 
+ 
+/*
+ * @brief      Query the destination port of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Destination port.
+ */
+uint16_t demo_ct_ld_get_dport(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->dport);
+}
+ 
+ 
+/*
+ * @brief      Query the used VLAN tag of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     VLAN tag. 0 == no VLAN tagging in this direction.
+ */
+uint16_t demo_ct_ld_get_vlan(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->vlan);
+}
+ 
+ 
+/*
+ * @brief      Query the route ID of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Route ID.
+ */
+uint32_t demo_ct_ld_get_route_id(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->route_id);
+}
+ 
+ 
+/*
+ * @brief      Query the source address of an IPv4 conntrack (reply direction).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Source IPv4 address (reply direction).
+ */
+uint32_t demo_ct_ld_get_saddr_reply(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->saddr_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the destination address of an IPv4 conntrack (reply direction).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Destination IPv4 address (reply direction).
+ */
+uint32_t demo_ct_ld_get_daddr_reply(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->daddr_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the source port of an IPv4 conntrack (reply direction).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Source port (reply direction).
+ */
+uint16_t demo_ct_ld_get_sport_reply(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->sport_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the destination port of an IPv4 conntrack (reply direction).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Destination port (reply direction).
+ */
+uint16_t demo_ct_ld_get_dport_reply(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->dport_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the used VLAN tag of an IPv4 conntrack (reply direction).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     VLAN tag (reply direction). 0 == no VLAN tagging in this direction.
+ */
+uint16_t demo_ct_ld_get_vlan_reply(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->vlan_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the route ID of an IPv4 conntrack (reply direction).
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Route ID (reply direction).
+ */
+uint32_t demo_ct_ld_get_route_id_reply(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohl(p_ct->route_id_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the flags of an IPv4 conntrack.
+ * @details    [localdata_ct]
+ * @param[in]  p_ct  Local data to be queried.
+ * @return     Flags bitset at time when the data was obtained from PFE.
+ */
+uint16_t demo_ct_ld_get_flags(const fpp_ct_cmd_t* p_ct)
+{
+    assert(NULL != p_ct);
+    return ntohs(p_ct->flags);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query whether an IPv6 conntrack serves as a NAT.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : does serve as a NAT.
+ *             false : does NOT serve as a NAT.
+ */
+bool demo_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    /* no need to transform byte order when comparing members of one struct */
+    return (bool)((0 != memcmp(p_ct6->daddr_reply, p_ct6->saddr, (4 * sizeof(uint32_t)))) ||
+                  (0 != memcmp(p_ct6->saddr_reply, p_ct6->daddr, (4 * sizeof(uint32_t)))));
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv6 conntrack serves as a PAT.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : does serve as a PAT.
+ *             false : does NOT serve as a PAT.
+ */
+bool demo_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    /* no need to transform byte order when comparing members of one struct */
+    return (bool)(((p_ct6->dport_reply) != (p_ct6->sport)) || 
+                  ((p_ct6->sport_reply) != (p_ct6->dport)));
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv6 conntrack modifies VLAN tags.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : does modify VLAN tags of serviced packets.
+ *             false : does NOT modify VLAN tags of serviced packets.
+ */
+bool demo_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    /* no need to transform byte order when comparing with ZERO */
+    return (bool)((0u != p_ct6->vlan) || (0u != p_ct6->vlan_reply));
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv6 conntrack decrements packet's TTL counter or not.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPV6 conntrack:
+ *             true  : does decrement TTL counter.
+ *             false : does NOT decrement TTL counter.
+ */
+bool demo_ct6_ld_is_ttl_decr(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(ntohs(p_ct6->flags) & CTCMD_FLAGS_TTL_DECREMENT);
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv6 conntrack is orig direction only.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : is orig direction only.
+ *             false : is NOT orig direction only.
+ */
+bool demo_ct6_ld_is_orig_only(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(ntohs(p_ct6->flags) & CTCMD_FLAGS_REP_DISABLED);
+}
+ 
+ 
+/*
+ * @brief      Query whether an IPv6 conntrack is reply direction only.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     The IPv6 conntrack:
+ *             true  : is reply direction only.
+ *             false : is NOT reply direction only.
+ */
+bool demo_ct6_ld_is_reply_only(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return (bool)(ntohs(p_ct6->flags) & CTCMD_FLAGS_ORIG_DISABLED);
+}
+ 
+ 
+/*
+ * @brief      Query the protocol of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     IP Protocol ID.
+ */
+uint16_t demo_ct6_ld_get_protocol(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->protocol);
+}
+ 
+ 
+/*
+ * @brief      Query the source address of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Source IPv6 address.
+ */
+const uint32_t* demo_ct6_ld_get_saddr(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    static uint32_t rtn_saddr[4] = {0u};
+    
+    rtn_saddr[0] = ntohl(p_ct6->saddr[0]);
+    rtn_saddr[1] = ntohl(p_ct6->saddr[1]);
+    rtn_saddr[2] = ntohl(p_ct6->saddr[2]);
+    rtn_saddr[3] = ntohl(p_ct6->saddr[3]);
+    
+    return (rtn_saddr);
+}
+ 
+ 
+/*
+ * @brief      Query the destination address of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Destination IPv4 address.
+ */
+const uint32_t* demo_ct6_ld_get_daddr(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    static uint32_t rtn_daddr[4] = {0u};
+    
+    rtn_daddr[0] = ntohl(p_ct6->daddr[0]);
+    rtn_daddr[1] = ntohl(p_ct6->daddr[1]);
+    rtn_daddr[2] = ntohl(p_ct6->daddr[2]);
+    rtn_daddr[3] = ntohl(p_ct6->daddr[3]);
+    
+    return (rtn_daddr);
+}
+ 
+ 
+/*
+ * @brief      Query the source port of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Source port.
+ */
+uint16_t demo_ct6_ld_get_sport(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->sport);
+}
+ 
+ 
+/*
+ * @brief      Query the destination port of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Destination port.
+ */
+uint16_t demo_ct6_ld_get_dport(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->dport);
+}
+ 
+ 
+/*
+ * @brief      Query the used VLAN tag of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     VLAN tag. 0 == no VLAN tagging in this direction.
+ */
+uint16_t demo_ct6_ld_get_vlan(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->vlan);
+}
+ 
+ 
+/*
+ * @brief      Query the route ID of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Route ID
+ */
+uint32_t demo_ct6_ld_get_route_id(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohl(p_ct6->route_id);
+}
+ 
+ 
+/*
+ * @brief      Query the source address of an IPv6 conntrack (reply direction).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Source IPv6 address (reply direction).
+ */
+const uint32_t* demo_ct6_ld_get_saddr_reply(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    static uint32_t rtn_saddr_reply[4] = {0u};
+    
+    rtn_saddr_reply[0] = ntohl(p_ct6->saddr_reply[0]);
+    rtn_saddr_reply[1] = ntohl(p_ct6->saddr_reply[1]);
+    rtn_saddr_reply[2] = ntohl(p_ct6->saddr_reply[2]);
+    rtn_saddr_reply[3] = ntohl(p_ct6->saddr_reply[3]);
+    
+    return (rtn_saddr_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the destination address of an IPv6 conntrack (reply direction).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Destination IPv6 address (reply direction).
+ */
+const uint32_t* demo_ct6_ld_get_daddr_reply(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    static uint32_t rtn_daddr_reply[4] = {0u};
+    
+    rtn_daddr_reply[0] = ntohl(p_ct6->daddr_reply[0]);
+    rtn_daddr_reply[1] = ntohl(p_ct6->daddr_reply[1]);
+    rtn_daddr_reply[2] = ntohl(p_ct6->daddr_reply[2]);
+    rtn_daddr_reply[3] = ntohl(p_ct6->daddr_reply[3]);
+    
+    return (rtn_daddr_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the source port of an IPv6 conntrack (reply direction).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Source port (reply direction).
+ */
+uint16_t demo_ct6_ld_get_sport_reply(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->sport_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the destination port of an IPv6 conntrack (reply direction).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Destination port (reply direction).
+ */
+uint16_t demo_ct6_ld_get_dport_reply(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->dport_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the used VLAN tag of an IPv6 conntrack (reply direction).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     VLAN tag (reply direction). 0 == no VLAN tagging in this direction.
+ */
+uint16_t demo_ct6_ld_get_vlan_reply(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->vlan_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the route ID of an IPv6 conntrack (reply direction).
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Route ID (reply direction).
+ */
+uint32_t demo_ct6_ld_get_route_id_reply(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohl(p_ct6->route_id_reply);
+}
+ 
+ 
+/*
+ * @brief      Query the flags of an IPv6 conntrack.
+ * @details    [localdata_ct6]
+ * @param[in]  p_ct6  Local data to be queried.
+ * @return     Flags bitset at time when the data was obtained from PFE.
+ */
+uint16_t demo_ct6_ld_get_flags(const fpp_ct6_cmd_t* p_ct6)
+{
+    assert(NULL != p_ct6);
+    return ntohs(p_ct6->flags);
+}
+ 
+ 
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available routes in PFE and
+ *             execute a callback print function for each applicable route.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next route is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @param[in]  print_ip4   Set true to print IPv4 routes.
+ * @param[in]  print_ip6   Set true to print IPv6 routes.
+ * @return     FPP_ERR_OK : Successfully iterated through all applicable routes.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_rt_print_all(FCI_CLIENT* p_cl, demo_rt_cb_print_t p_cb_print, 
+                      bool print_ip4, bool print_ip6)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    fpp_rt_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        if ((print_ip4) && demo_rt_ld_is_ip4(&reply_from_fci))
+        {
+            rtn = p_cb_print(&reply_from_fci);  /* print IPv4 route */
+        }
+        if ((print_ip6) && demo_rt_ld_is_ip6(&reply_from_fci))
+        {
+            rtn = p_cb_print(&reply_from_fci);  /* print IPv6 route */
+        }
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                            sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more routes to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_RT_ENTRY_NOT_FOUND == rtn) 
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_rt_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available routes in PFE.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_count  Space to store the count of routes.
+ * @return      FPP_ERR_OK : Successfully counted all available routes.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_rt_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_rt_cmd_t cmd_to_fci = {0};
+    fpp_rt_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /*  query loop  */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
+                        sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more routes to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_RT_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_rt_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available IPv4 conntracks in PFE and
+ *             execute a callback print function for each reported IPv4 conntrack.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next IPv4 conntrack is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all available IPv4 conntracks.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct_print_all(FCI_CLIENT* p_cl, demo_ct_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    fpp_ct_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                            sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more IPv4 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_ct_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available IPv4 conntracks in PFE.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_count  Space to store the count of IPv4 conntracks.
+ * @return      FPP_ERR_OK : Successfully counted all available IPv4 conntracks.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_ct_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_ct_cmd_t cmd_to_fci = {0};
+    fpp_ct_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
+                        sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more IPv4 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_ct_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Use FCI calls to iterate through all available IPv6 conntracks in PFE and
+ *             execute a callback print function for each reported IPv6 conntrack.
+ * @param[in]  p_cl        FCI client
+ * @param[in]  p_cb_print  Callback print function.
+ *                         --> If the callback returns ZERO, then all is OK and 
+ *                             a next IPv6 conntrack is picked for a print process.
+ *                         --> If the callback returns NON-ZERO, then some problem is 
+ *                             assumed and this function terminates prematurely.
+ * @return     FPP_ERR_OK : Successfully iterated through all available IPv6 conntracks.
+ *             other      : Some error occurred (represented by the respective error code).
+ */
+int demo_ct6_print_all(FCI_CLIENT* p_cl, demo_ct6_cb_print_t p_cb_print)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_cb_print);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    fpp_ct6_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        rtn = p_cb_print(&reply_from_fci);
+        
+        if (FPP_ERR_OK == rtn)
+        {
+            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+            rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                            sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                            &reply_length, (unsigned short*)(&reply_from_fci));
+        }
+    }
+    
+    /* query loop runs till there are no more IPv6 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_ct6_print_all() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/*
+ * @brief       Use FCI calls to get a count of all available IPv6 conntracks in PFE.
+ * @param[in]   p_cl         FCI client
+ * @param[out]  p_rtn_count  Space to store the count of IPv6 conntracks.
+ * @return      FPP_ERR_OK : Successfully counted all available IPv6 conntracks.
+ *                           Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
+ *                           No count was stored.
+ */
+int demo_ct6_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
+{
+    assert(NULL != p_cl);
+    assert(NULL != p_rtn_count);
+    
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
+    
+    fpp_ct6_cmd_t cmd_to_fci = {0};
+    fpp_ct6_cmd_t reply_from_fci = {0};
+    unsigned short reply_length = 0u;
+    uint32_t count = 0u;
+        
+    /* start query process */
+    cmd_to_fci.action = FPP_ACTION_QUERY;
+    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                    &reply_length, (unsigned short*)(&reply_from_fci));
+    
+    /* query loop */
+    while (FPP_ERR_OK == rtn)
+    {
+        count++;
+        
+        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+        rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
+                        sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+                        &reply_length, (unsigned short*)(&reply_from_fci));
+    }
+    
+    /* query loop runs till there are no more IPv6 conntracks to report */
+    /* the following error is therefore OK and expected (it ends the query loop) */
+    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
+    {
+        *p_rtn_count = count;
+        rtn = FPP_ERR_OK;
+    }
+    
+    print_if_error(rtn, "demo_ct6_get_count() failed!");
+    
+    return (rtn);
+}
+ 
+ 
+/* ========================================================================= */
+ 
diff --git a/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h
new file mode 100644
index 0000000..85d6341
--- /dev/null
+++ b/sw/libfci_cli/src/libfci_demo/demo_rt_ct.h
@@ -0,0 +1,170 @@
+/* =========================================================================
+ *  Copyright 2020-2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ========================================================================= */
+
+#ifndef DEMO_RT_CT_H_
+#define DEMO_RT_CT_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
+#include "fpp_ext.h"
+#include "libfci.h"
+
+/* ==== TYPEDEFS & DATA ==================================================== */
+
+typedef int (*demo_rt_cb_print_t)(const fpp_rt_cmd_t* p_rt);
+typedef int (*demo_ct_cb_print_t)(const fpp_ct_cmd_t* p_ct);
+typedef int (*demo_ct6_cb_print_t)(const fpp_ct6_cmd_t* p_ct6);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
+
+int demo_rt_get_by_id(FCI_CLIENT* p_cl, fpp_rt_cmd_t* p_rtn_rt, uint32_t id);
+int demo_ct_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct_cmd_t* p_rtn_ct, const fpp_ct_cmd_t* p_ct_data);
+int demo_ct6_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct6_cmd_t* p_rtn_ct6, const fpp_ct6_cmd_t* p_ct6_data);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in PFE ============= */
+
+int demo_ct_update(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
+int demo_ct6_update(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
+
+int demo_ct_timeout_tcp(FCI_CLIENT* p_cl, uint32_t timeout);
+int demo_ct_timeout_udp(FCI_CLIENT* p_cl, uint32_t timeout);
+int demo_ct_timeout_others(FCI_CLIENT* p_cl, uint32_t timeout);
+
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
+
+int demo_rt_add(FCI_CLIENT* p_cl, uint32_t id, const fpp_rt_cmd_t* p_rt_data);
+int demo_rt_del(FCI_CLIENT* p_cl, uint32_t id);
+
+int demo_ct_add(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
+int demo_ct_del(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
+
+int demo_ct6_add(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
+int demo_ct6_del(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
+
+int demo_rtct_reset_ip4(FCI_CLIENT* p_cl);
+int demo_rtct_reset_ip6(FCI_CLIENT* p_cl);
+
+/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
+
+void demo_rt_ld_set_as_ip4(fpp_rt_cmd_t* p_rt);
+void demo_rt_ld_set_as_ip6(fpp_rt_cmd_t* p_rt);
+void demo_rt_ld_set_src_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_src_mac[6]);
+void demo_rt_ld_set_dst_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_dst_mac[6]);
+void demo_rt_ld_set_egress_phyif(fpp_rt_cmd_t* p_rt, const char* p_phyif_name);
+
+void demo_ct_ld_set_protocol(fpp_ct_cmd_t* p_ct, uint16_t protocol);
+void demo_ct_ld_set_ttl_decr(fpp_ct_cmd_t* p_ct, bool set);
+void demo_ct_ld_set_orig_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr, uint32_t daddr,
+                             uint16_t sport, uint16_t dport, uint16_t vlan,
+                             uint32_t route_id, bool unidir_orig_only);
+void demo_ct_ld_set_reply_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr_reply, uint32_t daddr_reply,
+                              uint16_t sport_reply, uint16_t dport_reply, uint16_t vlan_reply,
+                              uint32_t route_id_reply, bool unidir_reply_only);
+                            
+void demo_ct6_ld_set_protocol(fpp_ct6_cmd_t* p_ct6, uint16_t protocol);
+void demo_ct6_ld_set_ttl_decr(fpp_ct6_cmd_t* p_ct6, bool set);
+void demo_ct6_ld_set_orig_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr[4], const uint32_t p_daddr[4],
+                              uint16_t sport, uint16_t dport, uint16_t vlan,
+                              uint32_t route_id, bool unidir_orig_only);
+void demo_ct6_ld_set_reply_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr_reply[4], const uint32_t p_daddr_reply[4],
+                               uint16_t sport_reply, uint16_t dport_reply, uint16_t vlan_reply,
+                               uint32_t route_id_reply, bool unidir_reply_only);
+
+/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
+
+bool demo_rt_ld_is_ip4(const fpp_rt_cmd_t* p_rt);
+bool demo_rt_ld_is_ip6(const fpp_rt_cmd_t* p_rt);
+
+uint32_t       demo_rt_ld_get_route_id(const fpp_rt_cmd_t* p_rt);
+const uint8_t* demo_rt_ld_get_src_mac(const fpp_rt_cmd_t* p_rt);
+const uint8_t* demo_rt_ld_get_dst_mac(const fpp_rt_cmd_t* p_rt);
+const char*    demo_rt_ld_get_egress_phyif(const fpp_rt_cmd_t* p_rt);
+
+
+bool demo_ct_ld_is_nat(const fpp_ct_cmd_t* p_ct);
+bool demo_ct_ld_is_pat(const fpp_ct_cmd_t* p_ct);
+bool demo_ct_ld_is_vlan_tagging(const fpp_ct_cmd_t* p_ct);
+bool demo_ct_ld_is_ttl_decr(const fpp_ct_cmd_t* p_ct);
+bool demo_ct_ld_is_orig_only(const fpp_ct_cmd_t* p_ct);
+bool demo_ct_ld_is_reply_only(const fpp_ct_cmd_t* p_ct);
+
+uint16_t demo_ct_ld_get_protocol(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_saddr(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_daddr(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_sport(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_dport(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_vlan(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_route_id(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_saddr_reply(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_daddr_reply(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_sport_reply(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_dport_reply(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_vlan_reply(const fpp_ct_cmd_t* p_ct);
+uint32_t demo_ct_ld_get_route_id_reply(const fpp_ct_cmd_t* p_ct);
+uint16_t demo_ct_ld_get_flags(const fpp_ct_cmd_t* p_ct);
+
+
+bool demo_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6);
+bool demo_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6);
+bool demo_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6);
+bool demo_ct6_ld_is_ttl_decr(const fpp_ct6_cmd_t* p_ct6);
+bool demo_ct6_ld_is_orig_only(const fpp_ct6_cmd_t* p_ct6);
+bool demo_ct6_ld_is_reply_only(const fpp_ct6_cmd_t* p_ct6);
+
+uint16_t        demo_ct6_ld_get_protocol(const fpp_ct6_cmd_t* p_ct6);
+const uint32_t* demo_ct6_ld_get_saddr(const fpp_ct6_cmd_t* p_ct6);
+const uint32_t* demo_ct6_ld_get_daddr(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_sport(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_dport(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_vlan(const fpp_ct6_cmd_t* p_ct6);
+uint32_t        demo_ct6_ld_get_route_id(const fpp_ct6_cmd_t* p_ct6);
+const uint32_t* demo_ct6_ld_get_saddr_reply(const fpp_ct6_cmd_t* p_ct6);
+const uint32_t* demo_ct6_ld_get_daddr_reply(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_sport_reply(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_dport_reply(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_vlan_reply(const fpp_ct6_cmd_t* p_ct6);
+uint32_t        demo_ct6_ld_get_route_id_reply(const fpp_ct6_cmd_t* p_ct6);
+uint16_t        demo_ct6_ld_get_flags(const fpp_ct6_cmd_t* p_ct6);
+
+/* ==== PUBLIC FUNCTIONS : misc ============================================ */
+
+int demo_rt_print_all(FCI_CLIENT* p_cl, demo_rt_cb_print_t p_cb_print, bool print_ip4, bool print_ip6);
+int demo_rt_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+int demo_ct_print_all(FCI_CLIENT* p_cl, demo_ct_cb_print_t p_cb_print);
+int demo_ct_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+int demo_ct6_print_all(FCI_CLIENT* p_cl, demo_ct6_cb_print_t p_cb_print);
+int demo_ct6_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
+
+/* ========================================================================= */
+
+#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_spd.c b/sw/libfci_cli/src/libfci_demo/demo_spd.c
similarity index 53%
rename from sw/libfci_cli/src/libfci_interface/fci_spd.c
rename to sw/libfci_cli/src/libfci_demo/demo_spd.c
index 8223146..da37221 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_spd.c
+++ b/sw/libfci_cli/src/libfci_demo/demo_spd.c
@@ -30,84 +30,33 @@
  
  
 #include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
 #include <string.h>
 #include <arpa/inet.h>
+ 
+#include <stdint.h>
+#include <stdbool.h>
 #include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
-#include "fci_common.h"
-#include "fci_spd.h"
  
- 
-/* ==== PRIVATE FUNCTIONS ================================================== */
+#include "demo_common.h"
+#include "demo_spd.h"
  
  
-/*
- * @brief          Network-to-host (ntoh) function for a SecurityPolicy struct.
- * @param[in,out]  p_rtn_spd  The SecurityPolicy struct to be converted.
- */
-static void ntoh_spd(fpp_spd_cmd_t* p_rtn_spd)
-{
-    assert(NULL != p_rtn_spd);
-    
-    
-    ntoh_enum(&(p_rtn_spd->flags), sizeof(fpp_spd_flags_t));
-    p_rtn_spd->position = ntohs(p_rtn_spd->position);
-    p_rtn_spd->saddr[0] = ntohl(p_rtn_spd->saddr[0]);
-    p_rtn_spd->saddr[1] = ntohl(p_rtn_spd->saddr[1]);
-    p_rtn_spd->saddr[2] = ntohl(p_rtn_spd->saddr[2]);
-    p_rtn_spd->saddr[3] = ntohl(p_rtn_spd->saddr[3]);
-    p_rtn_spd->daddr[0] = ntohl(p_rtn_spd->daddr[0]);
-    p_rtn_spd->daddr[1] = ntohl(p_rtn_spd->daddr[1]);
-    p_rtn_spd->daddr[2] = ntohl(p_rtn_spd->daddr[2]);
-    p_rtn_spd->daddr[3] = ntohl(p_rtn_spd->daddr[3]);
-    p_rtn_spd->sport = ntohs(p_rtn_spd->sport);
-    p_rtn_spd->dport = ntohs(p_rtn_spd->dport);
-    p_rtn_spd->sa_id = ntohl(p_rtn_spd->sa_id);
-    p_rtn_spd->spi = ntohl(p_rtn_spd->spi);
-    ntoh_enum(&(p_rtn_spd->spd_action), sizeof(fpp_spd_action_t));
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a SecurityPolicy struct.
- * @param[in,out]  p_rtn_spd  The SecurityPolicy struct to be converted.
- */
-static void hton_spd(fpp_spd_cmd_t* p_rtn_spd)
-{
-    assert(NULL != p_rtn_spd);
-    
-    
-    hton_enum(&(p_rtn_spd->flags), sizeof(fpp_spd_flags_t));
-    p_rtn_spd->position = htons(p_rtn_spd->position);
-    p_rtn_spd->saddr[0] = htonl(p_rtn_spd->saddr[0]);
-    p_rtn_spd->saddr[1] = htonl(p_rtn_spd->saddr[1]);
-    p_rtn_spd->saddr[2] = htonl(p_rtn_spd->saddr[2]);
-    p_rtn_spd->saddr[3] = htonl(p_rtn_spd->saddr[3]);
-    p_rtn_spd->daddr[0] = htonl(p_rtn_spd->daddr[0]);
-    p_rtn_spd->daddr[1] = htonl(p_rtn_spd->daddr[1]);
-    p_rtn_spd->daddr[2] = htonl(p_rtn_spd->daddr[2]);
-    p_rtn_spd->daddr[3] = htonl(p_rtn_spd->daddr[3]);
-    p_rtn_spd->sport = htons(p_rtn_spd->sport);
-    p_rtn_spd->dport = htons(p_rtn_spd->dport);
-    p_rtn_spd->sa_id = htonl(p_rtn_spd->sa_id);
-    p_rtn_spd->spi = htonl(p_rtn_spd->spi);
-    hton_enum(&(p_rtn_spd->spd_action), sizeof(fpp_spd_action_t));
-}
+/* ==== PRIVATE FUNCTIONS ================================================== */
  
  
 /*
- * @brief       Set/unset a bitflag in a SecurityPolicy struct.
- * @param[out]  p_rtn_spd  The SecurityPolicy struct to be modified.
- * @param[in]   enable     New state of the bitflag.
- * @param[in]   flag       The bitflag.
+ * @brief       Set/unset a flag in a SecurityPolicy struct.
+ * @param[out]  p_rtn_spd  Struct to be modified.
+ * @param[in]   enable     New state of a flag.
+ * @param[in]   flag       The flag.
  */
-static void set_flag(fpp_spd_cmd_t* p_rtn_spd, bool enable, fpp_spd_flags_t flag)
+static void set_spd_flag(fpp_spd_cmd_t* p_rtn_spd, bool enable, fpp_spd_flags_t flag)
 {
     assert(NULL != p_rtn_spd);
     
+    hton_enum(&flag, sizeof(fpp_spd_flags_t));
     
     if (enable)
     {
@@ -120,34 +69,33 @@ static void set_flag(fpp_spd_cmd_t* p_rtn_spd, bool enable, fpp_spd_flags_t flag
 }
  
  
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
  
  
 /*
  * @brief       Use FCI calls to get configuration data of a requested SecurityPolicy
- *              from the PFE. Identify the SecurityPolicy by name of the parent 
+ *              from PFE. Identify the SecurityPolicy by a name of the parent 
  *              physical interface (each physical interface has its own SPD) and by
- *              position of the policy in the SPD.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_spd     Space for data from the PFE.
+ *              a position of the policy in the SPD.
+ * @param[in]   p_cl          FCI client
+ * @param[out]  p_rtn_spd     Space for data from PFE.
  * @param[in]   p_phyif_name  Name of a parent physical interface.
  *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
+ *                            See FCI API Reference, chapter Interface Management.
  *              position      Position of the requested SecurityPolicy in the SPD.
- * @return      FPP_ERR_OK : Requested SecurityPolicy was found.
- *                           A copy of its configuration was stored into p_rtn_spd.
- *              other      : Some error occured (represented by the respective error code).
+ * @return      FPP_ERR_OK : The requested SecurityPolicy was found.
+ *                           A copy of its configuration data was stored into p_rtn_spd.
+ *              other      : Some error occurred (represented by the respective error code).
  *                           No data copied.
  */
-int fci_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd, 
-                            const char* p_phyif_name, uint16_t position)
+int demo_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd, 
+                             const char* p_phyif_name, uint16_t position)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_spd);
     assert(NULL != p_phyif_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_spd_cmd_t cmd_to_fci = {0};
     fpp_spd_cmd_t reply_from_fci = {0};
@@ -164,103 +112,105 @@ int fci_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd,
         rtn = fci_query(p_cl, FPP_CMD_SPD,
                         sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_spd(&reply_from_fci);  /* set correct byte order */
         
-        /* query loop (with the search condition) */
-        while ((FPP_ERR_OK == rtn) && (position != (reply_from_fci.position)))
+        /* query loop (with a search condition) */
+        while ((FPP_ERR_OK == rtn) && (ntohs(reply_from_fci.position) != position))
         {
             cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
             rtn = fci_query(p_cl, FPP_CMD_SPD,
                             sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
                             &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_spd(&reply_from_fci);  /* set correct byte order */
         }
     }
     
-    /* if search successful, then assign the data */
+    /* if a query is successful, then assign the data */
     if (FPP_ERR_OK == rtn)
     {
         *p_rtn_spd = reply_from_fci;
     }
     
+    print_if_error(rtn, "demo_spd_get_by_position() failed!");
+    
     return (rtn);
 }
  
  
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
  
  
 /*
- * @brief       Use FCI calls to create a new SecurityPolicy in the PFE.
+ * @brief       Use FCI calls to create a new SecurityPolicy in PFE.
  *              The new policy is added into SPD of a provided parent physical interface.
  * @param[in]   p_cl          FCI client instance
  * @param[in]   p_phyif_name  Name of a parent physical interface.
  *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
+ *                            See FCI API Reference, chapter Interface Management.
  * @param[in]   position      Position of the new SecurityPolicy in the SPD.
  * @param[in]   p_spd_data    Configuration data for the new SecurityPolicy.
  *                            To create a new SecurityPolicy, a local data struct must be
  *                            created, configured and then passed to this function.
- *                            See [localdata_spd] functions to learn more.
+ *                            See [localdata_spd] to learn more.
  * @return      FPP_ERR_OK : New SecurityPolicy was created.
- *              other      : Some error occured (represented by the respective error code).
+ *              other      : Some error occurred (represented by the respective error code).
  */
-int fci_spd_add(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position, 
-                const fpp_spd_cmd_t* p_spd_data)
+int demo_spd_add(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position, 
+                 const fpp_spd_cmd_t* p_spd_data)
 {
     assert(NULL != p_cl);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_spd_cmd_t cmd_to_fci = {0};
     
     /* prepare data */
     cmd_to_fci = (*p_spd_data);
-    cmd_to_fci.position = position;
+    cmd_to_fci.position = htons(position);
     rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
     
     /* send data */
     if (FPP_ERR_OK == rtn)
     {
-        hton_spd(&cmd_to_fci);  /* set correct byte order */
         cmd_to_fci.action = FPP_ACTION_REGISTER;
         rtn = fci_write(p_cl, FPP_CMD_SPD, sizeof(fpp_spd_cmd_t), 
                                           (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_spd_add() failed!");
+    
     return (rtn);
 }
  
  
 /*
- * @brief       Use FCI calls to destroy the target SecurityPolicy in the PFE.
+ * @brief       Use FCI calls to destroy the target SecurityPolicy in PFE.
  * @param[in]   p_cl          FCI client instance
  * @param[in]   p_phyif_name  Name of a parent physical interface.
+ *                            Names of physical interfaces are hardcoded.
+ *                            See FCI API Reference, chapter Interface Management.
  * @param[in]   position      Position of the target SecurityPolicy in the SPD.
- * @return      FPP_ERR_OK : SecurityPolicy was destroyed.
- *              other      : Some error occured (represented by the respective error code).
+ * @return      FPP_ERR_OK : The SecurityPolicy was destroyed.
+ *              other      : Some error occurred (represented by the respective error code).
  */
-int fci_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position)
+int demo_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position)
 {
     assert(NULL != p_cl);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     fpp_spd_cmd_t cmd_to_fci = {0};
     
     /*  prepare data  */
-    cmd_to_fci.position = position;
+    cmd_to_fci.position = htons(position);
     rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
     
     /*  send data  */
     if (FPP_ERR_OK == rtn)
     {
-        hton_spd(&cmd_to_fci);  /*  set correct byte order  */
         cmd_to_fci.action = FPP_ACTION_DEREGISTER;
         rtn = fci_write(p_cl, FPP_CMD_SPD, sizeof(fpp_spd_cmd_t), 
                                           (unsigned short*)(&cmd_to_fci));
     }
     
+    print_if_error(rtn, "demo_spd_del() failed!");
+    
     return (rtn);
 }
  
@@ -268,73 +218,80 @@ int fci_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position)
 /* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
 /*
  * @defgroup    localdata_spd  [localdata_spd]
- * @brief:      Functions marked as [localdata_spd] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_spd_add() to 
- *              create a new SecurityPolicy with given configuration in the PFE.
+ * @brief:      Functions marked as [localdata_spd] access only local data. 
+ *              No FCI calls are made.
+ * @details:    These functions have a parameter p_spd (a struct with configuration data).
+ *              When adding a new SecurityPolicy, there are no "initial data" 
+ *              to be obtained from PFE. Simply declare a local data struct and configure it.
+ *              Then, after all modifications are done and finished,
+ *              call demo_spd_add() to create a new SecurityPolicy in PFE.
  */
  
  
 /*
- * @brief          Set protocol type of a SecurityPolicy.
+ * @brief          Set a protocol type of a SecurityPolicy.
  * @details        [localdata_spd]
- * @param[in,out]  p_spd  Local data to be modified.
- *                        For SecurityPolicy, there are no "initial data" to be obtained
- *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in,out]  p_spd     Local data to be modified.
  * @param[in]      protocol  IP protocol ID
  *                           See "IANA Assigned Internet Protocol Number":
  *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
  */
-int fci_spd_ld_set_protocol(fpp_spd_cmd_t* p_spd, uint8_t protocol)
+void demo_spd_ld_set_protocol(fpp_spd_cmd_t* p_spd, uint8_t protocol)
 {
     assert(NULL != p_spd);
     p_spd->protocol = protocol;
-    return (FPP_ERR_OK);
 }
  
  
 /*
- * @brief          Set source/destination IP address of a SecurityPolicy.
+ * @brief          Set a source/destination IP address of a SecurityPolicy.
  * @details        [localdata_spd]
- *                 BEWARE: Address type of 'p_saddr' and 'p_daddr' must be the same!
- * @param[in,out]  p_spd  Local data to be modified.
- *                        For SecurityPolicy, there are no "initial data" to be obtained
- *                        from the PFE. Simply declare a local data struct and configure it.
+ *                 BEWARE: Address type (IPv4/IPv6) of p_saddr and p_daddr must be the same!
+ * @param[in,out]  p_spd    Local data to be modified.
  * @param[in]      p_saddr  Source IP address (IPv4 or IPv6).
  * @param[in]      p_daddr  Destination IP address (IP4 or IP6).
  * @param[in]      is_ip6   Set if provided addresses are IPv6 type addresses.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
  */
-int fci_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4], 
-                      const uint32_t p_daddr[4], bool is_ip6)
+void demo_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4], 
+                        const uint32_t p_daddr[4], bool is_ip6)
 {
     assert(NULL != p_spd);
     assert(NULL != p_saddr);
     assert(NULL != p_daddr);
     
-    
-    const uint16_t cnt = ((is_ip6) ? (4u) : (1u));
-    memcpy((p_spd->saddr), p_saddr, (cnt * sizeof(uint32_t)));
-    memcpy((p_spd->daddr), p_daddr, (cnt * sizeof(uint32_t)));
-    set_flag(p_spd, is_ip6, FPP_SPD_FLAG_IPv6);
-    
-    return (FPP_ERR_OK);
+    if (is_ip6)
+    {
+        p_spd->saddr[0] = htonl(p_saddr[0]);
+        p_spd->saddr[1] = htonl(p_saddr[1]);
+        p_spd->saddr[2] = htonl(p_saddr[2]);
+        p_spd->saddr[3] = htonl(p_saddr[3]);
+        
+        p_spd->daddr[0] = htonl(p_daddr[0]);
+        p_spd->daddr[1] = htonl(p_daddr[1]);
+        p_spd->daddr[2] = htonl(p_daddr[2]);
+        p_spd->daddr[3] = htonl(p_daddr[3]);
+    }
+    else
+    {
+        p_spd->saddr[0] = htonl(p_saddr[0]);
+        p_spd->saddr[1] = 0u;
+        p_spd->saddr[2] = 0u;
+        p_spd->saddr[3] = 0u;
+        
+        p_spd->daddr[0] = htonl(p_daddr[0]);
+        p_spd->daddr[1] = 0u;
+        p_spd->daddr[2] = 0u;
+        p_spd->daddr[3] = 0u;
+    }
+
+    set_spd_flag(p_spd, is_ip6, FPP_SPD_FLAG_IPv6);
 }
  
  
 /*
- * @brief          Set source/destination port of the SecurityPolicy.
+ * @brief          Set a source/destination port of a SecurityPolicy.
  * @details        [localdata_spd]
- * @param[in,out]  p_spd  Local data to be modified.
- *                        For SecurityPolicy, there are no "initial data" to be obtained
- *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in,out]  p_spd      Local data to be modified.
  * @param[in]      use_sport  Prompt to use the source port value of this SecurityPolicy
  *                            during SPD matching process (evaluation which policy to use).
  *                            If false, then source port of the given SecurityPolicy is
@@ -345,54 +302,45 @@ int fci_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4],
  *                            If false, then destination port of the given SecurityPolicy is
  *                            ignored (not tested) when the policy is evaluated.
  * @param[in]      dport      Destination port
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
  */
-int fci_spd_ld_set_port(fpp_spd_cmd_t* p_spd, bool use_sport, uint16_t sport, 
-                        bool use_dport, uint16_t dport)
+void demo_spd_ld_set_port(fpp_spd_cmd_t* p_spd, bool use_sport, uint16_t sport, 
+                          bool use_dport, uint16_t dport)
 {
     assert(NULL != p_spd);
     
-    
-    p_spd->sport = ((use_sport) ? (sport) : (0u));
-    p_spd->dport = ((use_dport) ? (dport) : (0u));
-    set_flag(p_spd, (!use_sport), FPP_SPD_FLAG_SPORT_OPAQUE);  /* flag has inverted logic */
-    set_flag(p_spd, (!use_dport), FPP_SPD_FLAG_DPORT_OPAQUE);  /* flag has inverted logic */
-    
-    return (FPP_ERR_OK);
+    p_spd->sport = ((use_sport) ? htons(sport) : (0u));
+    p_spd->dport = ((use_dport) ? htons(dport) : (0u));
+    set_spd_flag(p_spd, (!use_sport), FPP_SPD_FLAG_SPORT_OPAQUE);  /* inverted logic */
+    set_spd_flag(p_spd, (!use_dport), FPP_SPD_FLAG_DPORT_OPAQUE);  /* inverted logic */
 }
  
  
 /*
- * @brief          Set action of the SecurityPolicy.
+ * @brief          Set action of a SecurityPolicy.
  * @details        [localdata_spd]
- * @param[in,out]  p_spd  Local data to be modified.
- *                        For SecurityPolicy, there are no "initial data" to be obtained
- *                        from the PFE. Simply declare a local data struct and configure it.
+ * @param[in,out]  p_spd       Local data to be modified.
  * @param[in]      spd_action  Action to do if traffic matches this SecurityPolicy.
- *                             See description of fpp_spd_action_t type in 
- *                             the FCI API Reference.
+ *                             See description of the fpp_spd_action_t type in 
+ *                             FCI API Reference.
  * @param[in]      sa_id  Meaningful ONLY if the action is FPP_SPD_ACTION_PROCESS_ENCODE.
  *                        ID of an item in the SAD (Security Association Database).
- *                        SAD is stored in the HSE FW (High Speed Encryption).
+ *                        SAD is stored in the HSE FW (Hardware Security Engine).
  * @param[in]      spi    Meaningful ONLY if the action is FPP_SPD_ACTION_PROCESS_DECODE.
- *                        Security Parameter Index (will be looked for in the traffic data)
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
+ *                        Security Parameter Index (will be looked for in the traffic data).
  */
-int fci_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action, 
-                          uint32_t sa_id, uint32_t spi)
+void demo_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action, 
+                            uint32_t sa_id, uint32_t spi)
 {
     assert(NULL != p_spd);
     
+    {
+        fpp_spd_action_t tmp_action = spd_action;
+        hton_enum(&tmp_action, sizeof(fpp_spd_action_t));
+        p_spd->spd_action = tmp_action;
+    }
     
-    p_spd->spd_action = spd_action;
-    p_spd->sa_id = ((FPP_SPD_ACTION_PROCESS_ENCODE == spd_action) ? (sa_id) : (0uL));
-    p_spd->spi = ((FPP_SPD_ACTION_PROCESS_DECODE == spd_action) ? (spi) : (0uL));
-    
-    return (FPP_ERR_OK);
+    p_spd->sa_id = ((FPP_SPD_ACTION_PROCESS_ENCODE == spd_action) ? htonl(sa_id) : (0uL));
+    p_spd->spi   = ((FPP_SPD_ACTION_PROCESS_DECODE == spd_action) ? htonl(spi)   : (0uL));
 }
  
  
@@ -400,17 +348,21 @@ int fci_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action,
  
  
 /*
- * @brief      Query address type of the given SecurityPolicy.
+ * @brief      Query address type of a SecurityPolicy.
  * @details    [localdata_spd]
  * @param[in]  p_spd  Local data to be queried.
  * @return     IP address of the policy:
  *             true  : is IPv6 type.
  *             false : is NOT IPv6 type.
  */
-bool fci_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd)
+bool demo_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd)
 {
     assert(NULL != p_spd);
-    return (bool)(FPP_SPD_FLAG_IPv6 & (p_spd->flags));
+    
+    fpp_spd_flags_t tmp_flags = (p_spd->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_spd_flags_t));
+    
+    return (bool)(tmp_flags & FPP_SPD_FLAG_IPv6);
 }
  
  
@@ -422,10 +374,14 @@ bool fci_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd)
  *             true  : is used in a matching process.
  *             false : is NOT used in a matching process.
  */
-bool fci_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd)
+bool demo_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd)
 {
     assert(NULL != p_spd);
-    return !(FPP_SPD_FLAG_SPORT_OPAQUE & (p_spd->flags));  /* flag has inverted logic */
+    
+    fpp_spd_flags_t tmp_flags = (p_spd->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_spd_flags_t));
+    
+    return !(tmp_flags & FPP_SPD_FLAG_SPORT_OPAQUE);  /* the flag has inverted logic */
 }
  
  
@@ -437,10 +393,155 @@ bool fci_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd)
  *             true  : is used in a matching process.
  *             false : is NOT used in a matching process.
  */
-bool fci_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd)
+bool demo_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    
+    fpp_spd_flags_t tmp_flags = (p_spd->flags);
+    ntoh_enum(&tmp_flags, sizeof(fpp_spd_flags_t));
+    
+    return !(tmp_flags & FPP_SPD_FLAG_DPORT_OPAQUE);  /* the flag has inverted logic */
+}
+ 
+ 
+ 
+ 
+/*
+ * @brief      Query the position of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Position of the Security Policy within the SPD.
+ */
+uint16_t demo_spd_ld_get_position(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return ntohs(p_spd->position);
+}
+ 
+ 
+/*
+ * @brief      Query the source IP address of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Source IP address.
+ *             Use demo_spd_ld_is_ip6() to distinguish between IPv4 and IPv6.
+ */
+const uint32_t* demo_spd_ld_get_saddr(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    static uint32_t rtn_saddr[4] = {0u};
+    
+    rtn_saddr[0] = htonl(p_spd->saddr[0]);
+    rtn_saddr[1] = htonl(p_spd->saddr[1]);
+    rtn_saddr[2] = htonl(p_spd->saddr[2]);
+    rtn_saddr[3] = htonl(p_spd->saddr[3]);
+    
+    return (rtn_saddr);
+}
+ 
+ 
+/*
+ * @brief      Query the destination IP address of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Destination IP address.
+ *             Use demo_spd_ld_is_ip6() to distinguish between IPv4 and IPv6.
+ */
+const uint32_t* demo_spd_ld_get_daddr(const fpp_spd_cmd_t* p_spd)
 {
     assert(NULL != p_spd);
-    return !(FPP_SPD_FLAG_DPORT_OPAQUE & (p_spd->flags));  /* flag has inverted logic */
+    static uint32_t rtn_daddr[4] = {0u};
+    
+    rtn_daddr[0] = htonl(p_spd->daddr[0]);
+    rtn_daddr[1] = htonl(p_spd->daddr[1]);
+    rtn_daddr[2] = htonl(p_spd->daddr[2]);
+    rtn_daddr[3] = htonl(p_spd->daddr[3]);
+    
+    return (rtn_daddr);
+}
+ 
+ 
+/*
+ * @brief      Query the source port of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Source port.
+ */
+uint16_t demo_spd_ld_get_sport(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return ntohs(p_spd->sport);
+}
+ 
+ 
+/*
+ * @brief      Query the destination port of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Destination port.
+ */
+uint16_t demo_spd_ld_get_dport(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return ntohs(p_spd->dport);
+}
+ 
+ 
+/*
+ * @brief      Query the destination port of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     IP Protocol ID
+ */
+uint8_t demo_spd_ld_get_protocol(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return (p_spd->protocol);
+}
+ 
+ 
+/*
+ * @brief      Query the ID of an item in the SAD (Security Association Database).
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     ID of an associated item in the SAD.
+ *             Meaningful ONLY if the action is FPP_SPD_ACTION_PROCESS_ENCODE.
+ */
+uint32_t demo_spd_ld_get_sa_id(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return ntohl(p_spd->sa_id);
+}
+ 
+ 
+/*
+ * @brief      Query the SPI tag of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     SPI tag associated with the SecurityPolicy.
+ *             Meaningful ONLY if the action is FPP_SPD_ACTION_PROCESS_DECODE.
+ */
+uint32_t demo_spd_ld_get_spi(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    return ntohl(p_spd->spi);
+}
+ 
+ 
+/*
+ * @brief      Query the action of a SecurityPolicy.
+ * @details    [localdata_spd]
+ * @param[in]  p_spd  Local data to be queried.
+ * @return     Action to be done if this SecurityPolicy is utilized.
+ */
+fpp_spd_action_t demo_spd_ld_get_action(const fpp_spd_cmd_t* p_spd)
+{
+    assert(NULL != p_spd);
+    
+    fpp_spd_action_t tmp_action = (p_spd->spd_action);
+    ntoh_enum(&tmp_action, sizeof(fpp_spd_action_t));
+    
+    return (tmp_action);
 }
  
  
@@ -448,35 +549,34 @@ bool fci_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd)
  
  
 /*
- * @brief      Use FCI calls to iterate through SecurityPolicies of the given physical
+ * @brief      Use FCI calls to iterate through all SecurityPolicies of a given physical
  *             interface and execute a callback print function for each SecurityPolicy.
- * @param[in]  p_cl           FCI client instance
+ * @param[in]  p_cl           FCI client
  * @param[in]  p_cb_print     Callback print function.
- *                            --> If the callback returns zero, then all is OK and 
- *                                the next physical interface is picked for a print process.
- *                            --> If the callback returns non-zero, then some problem is 
+ *                            --> If the callback returns ZERO, then all is OK and 
+ *                                a next SecurityPolicy is picked for a print process.
+ *                            --> If the callback returns NON-ZERO, then some problem is 
  *                                assumed and this function terminates prematurely.
  * @param[in]  p_phyif_name   Name of a parent physical interface.
  *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @param[in]  position_init  Start invoking callback print function from 
+ *                            See FCI API Reference, chapter Interface Management.
+ * @param[in]  position_init  Start invoking a callback print function from 
  *                            this position in the SPD.
  *                            If 0, start from the very first SecurityPolicy in the SPD.
- * @param[in]  count          Print only this count of SecurityPolicies, then stop.
+ * @param[in]  count          Print only this count of SecurityPolicies, then end.
  *                            If 0, keep printing SecurityPolicies till the end of the SPD.
- * @return     FPP_ERR_OK : Successfully iterated through SecrityPolicies of 
+ * @return     FPP_ERR_OK : Successfully iterated through all SecrityPolicies of 
  *                          the given physical interface.
- *             other      : Some error occured (represented by the respective error code).
+ *             other      : Some error occurred (represented by the respective error code).
  */
-int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print, 
-                           const char* p_phyif_name, uint16_t position_init, uint16_t count)
+int demo_spd_print_by_phyif(FCI_CLIENT* p_cl, demo_spd_cb_print_t p_cb_print, 
+                            const char* p_phyif_name, uint16_t position_init, uint16_t count)
 {
     assert(NULL != p_cl);
     assert(NULL != p_cb_print);
     assert(NULL != p_phyif_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_spd_cmd_t cmd_to_fci = {0};
     fpp_spd_cmd_t reply_from_fci = {0};
@@ -486,7 +586,7 @@ int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print,
     rtn = set_text((cmd_to_fci.name), p_phyif_name, IFNAMSIZ);
     if (0u == count)  /* if 0, set max possible count of items */ 
     {
-        count--;  /*  WARNING: intentional use of owf behavior */
+        count--;  /* WARNING: intentional use of owf behavior */
     }
     
     /* do the query */
@@ -497,7 +597,6 @@ int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print,
         rtn = fci_query(p_cl, FPP_CMD_SPD,
                         sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_spd(&reply_from_fci);  /* set correct byte order */
     
         /* query loop */
         uint16_t position = 0u;
@@ -517,7 +616,6 @@ int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print,
                 rtn = fci_query(p_cl, FPP_CMD_SPD,
                                 sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
                                 &reply_length, (unsigned short*)(&reply_from_fci));
-                ntoh_spd(&reply_from_fci);  /* set correct byte order */
             }
         }
         
@@ -529,32 +627,33 @@ int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print,
         }
     }
     
+    print_if_error(rtn, "demo_spd_print_by_phyif() failed!");
+    
     return (rtn);
 } 
  
  
 /*
- * @brief       Use FCI calls to get a count of all SecurityPolicies in the PFE which are
+ * @brief       Use FCI calls to get a count of all SecurityPolicies in PFE which are
  *              associated with the given physical interface.
- * @param[in]   p_cl          FCI client instance
+ * @param[in]   p_cl          FCI client
  * @param[out]  p_rtn_count   Space to store the count of SecurityPolicies.
  * @param[in]   p_phyif_name  Name of a parent physical interface.
  *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Successfully counted SecurityPolicies.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
+ *                            See FCI API Reference, chapter Interface Management.
+ * @return      FPP_ERR_OK : Successfully counted all available SecurityPolicies of
+ *                           the given physical interface. Count was stored into p_rtn_count.
+ *              other      : Some error occurred (represented by the respective error code).
  *                           No count was stored.
  */
-int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
-                               const char* p_phyif_name)
+int demo_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, 
+                                const char* p_phyif_name)
 {
     assert(NULL != p_cl);
     assert(NULL != p_rtn_count);
     assert(NULL != p_phyif_name);
     
-    
-    int rtn = FPP_ERR_FCI;
+    int rtn = FPP_ERR_INTERNAL_FAILURE;
     
     fpp_spd_cmd_t cmd_to_fci = {0};
     fpp_spd_cmd_t reply_from_fci = {0};
@@ -572,7 +671,6 @@ int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count,
         rtn = fci_query(p_cl, FPP_CMD_SPD,
                         sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
                         &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting policies) */
         
         /*  query loop  */
         while (FPP_ERR_OK == rtn)
@@ -583,7 +681,6 @@ int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count,
             rtn = fci_query(p_cl, FPP_CMD_SPD,
                             sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
                             &reply_length, (unsigned short*)(&reply_from_fci));
-            /* no need to set correct byte order (we are just counting policies) */
         }
         
         /* query loop runs till there are no more SecurityPolicies to report */
@@ -595,6 +692,8 @@ int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count,
         }
     }
     
+    print_if_error(rtn, "demo_spd_get_count_by_phyif() failed!");
+    
     return (rtn);
 }
  
diff --git a/sw/libfci_cli/src/libfci_interface/fci_spd.h b/sw/libfci_cli/src/libfci_demo/demo_spd.h
similarity index 50%
rename from sw/libfci_cli/src/libfci_interface/fci_spd.h
rename to sw/libfci_cli/src/libfci_demo/demo_spd.h
index 796d4d6..123e1fb 100644
--- a/sw/libfci_cli/src/libfci_interface/fci_spd.h
+++ b/sw/libfci_cli/src/libfci_demo/demo_spd.h
@@ -28,43 +28,56 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * ========================================================================= */
 
-#ifndef FCI_SPD_H_
-#define FCI_SPD_H_
+#ifndef DEMO_SPD_H_
+#define DEMO_SPD_H_
 
+#include <stdint.h>
+#include <stdbool.h>
+#include "fpp.h"
 #include "fpp_ext.h"
 #include "libfci.h"
 
 /* ==== TYPEDEFS & DATA ==================================================== */
 
-typedef int (*fci_spd_cb_print_t)(const fpp_spd_cmd_t* p_spd);
+typedef int (*demo_spd_cb_print_t)(const fpp_spd_cmd_t* p_spd);
 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from PFE ============== */
 
-int fci_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd, const char* p_phyif_name, uint16_t position);
+int demo_spd_get_by_position(FCI_CLIENT* p_cl, fpp_spd_cmd_t* p_rtn_spd, const char* p_phyif_name, uint16_t position);
 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
+/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in PFE =========== */
 
-int fci_spd_add(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position, const fpp_spd_cmd_t* p_spd_data);
-int fci_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position);
+int demo_spd_add(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position, const fpp_spd_cmd_t* p_spd_data);
+int demo_spd_del(FCI_CLIENT* p_cl, const char* p_phyif_name, uint16_t position);
 
 /* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
 
-int fci_spd_ld_set_protocol(fpp_spd_cmd_t* p_spd, uint8_t protocol);
-int fci_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4], const uint32_t p_daddr[4], bool is_ip6);
-int fci_spd_ld_set_port(fpp_spd_cmd_t* p_spd, bool use_sport, uint16_t sport, bool use_dport, uint16_t dport);
-int fci_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action, uint32_t sa_id, uint32_t spi);
+void demo_spd_ld_set_protocol(fpp_spd_cmd_t* p_spd, uint8_t protocol);
+void demo_spd_ld_set_ip(fpp_spd_cmd_t* p_spd, const uint32_t p_saddr[4], const uint32_t p_daddr[4], bool is_ip6);
+void demo_spd_ld_set_port(fpp_spd_cmd_t* p_spd, bool use_sport, uint16_t sport, bool use_dport, uint16_t dport);
+void demo_spd_ld_set_action(fpp_spd_cmd_t* p_spd, fpp_spd_action_t spd_action, uint32_t sa_id, uint32_t spi);
 
 /* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
 
-bool fci_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd);
-bool fci_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd);
-bool fci_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd);
+bool demo_spd_ld_is_ip6(const fpp_spd_cmd_t* p_spd);
+bool demo_spd_ld_is_used_sport(const fpp_spd_cmd_t* p_spd);
+bool demo_spd_ld_is_used_dport(const fpp_spd_cmd_t* p_spd);
+
+uint16_t         demo_spd_ld_get_position(const fpp_spd_cmd_t* p_spd);
+const uint32_t*  demo_spd_ld_get_saddr(const fpp_spd_cmd_t* p_spd);
+const uint32_t*  demo_spd_ld_get_daddr(const fpp_spd_cmd_t* p_spd);
+uint16_t         demo_spd_ld_get_sport(const fpp_spd_cmd_t* p_spd);
+uint16_t         demo_spd_ld_get_dport(const fpp_spd_cmd_t* p_spd);
+uint8_t          demo_spd_ld_get_protocol(const fpp_spd_cmd_t* p_spd);
+uint32_t         demo_spd_ld_get_sa_id(const fpp_spd_cmd_t* p_spd);
+uint32_t         demo_spd_ld_get_spi(const fpp_spd_cmd_t* p_spd);
+fpp_spd_action_t demo_spd_ld_get_action(const fpp_spd_cmd_t* p_spd);
 
 /* ==== PUBLIC FUNCTIONS : misc ============================================ */
 
-int fci_spd_print_by_phyif(FCI_CLIENT* p_cl, fci_spd_cb_print_t p_cb_print, const char* p_phyif_name,
-                           uint16_t position_init, uint16_t count);
-int fci_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_phyif_name);
+int demo_spd_print_by_phyif(FCI_CLIENT* p_cl, demo_spd_cb_print_t p_cb_print, const char* p_phyif_name,
+                            uint16_t position_init, uint16_t count);
+int demo_spd_get_count_by_phyif(FCI_CLIENT* p_cl, uint32_t* p_rtn_count, const char* p_phyif_name);
 
 /* ========================================================================= */
 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_ep.c b/sw/libfci_cli/src/libfci_interface/fci_ep.c
deleted file mode 100644
index a7fbc61..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_ep.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
- 
- 
-#include <assert.h>
-#include <string.h>
-#include "fpp.h"
-#include "fpp_ext.h"
-#include "libfci.h"
-#include "fci_common.h"
-#include "fci_ep.h"
- 
- 
-/* ==== PUBLIC FUNCTIONS =================================================== */
- 
- 
-/*
- * @brief       Open connection to an FCI endpoint as a command-mode FCI client.
- * @details     Command-mode client can send FCI commands.
- * @param[out]  pp_rtn_cl  The newly created FCI client.
- * @return      FPP_ERR_OK : The FCI client was successfully created.
- *              other      : Failed to create the FCI client.
- */
-int fci_ep_open_in_cmd_mode(FCI_CLIENT** pp_rtn_cl)
-{  
-    assert(NULL != pp_rtn_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    FCI_CLIENT* p_cl = fci_open(FCI_CLIENT_DEFAULT, FCI_GROUP_NONE);
-    if (NULL == p_cl)
-    {
-        rtn = FPP_ERR_FCI;
-    }
-    else
-    {
-        *pp_rtn_cl = p_cl;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Close connection to the FCI endpoint and destroy the FCI client.
- * @param[in]  p_cl  The FCI client to be destroyed.
- * @return     FPP_ERR_OK : The FCI client was successfully destroyed.
- *             other      : Failed to destroy the FCI client instance.
- */
-int fci_ep_close(FCI_CLIENT* p_cl)
-{
-    assert(NULL != p_cl);
-    return fci_close(p_cl);
-}
- 
- 
-/* ========================================================================= */
- 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_fp.h b/sw/libfci_cli/src/libfci_interface/fci_fp.h
deleted file mode 100644
index 8fcf181..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_fp.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
-
-#ifndef FCI_FP_H_
-#define FCI_FP_H_
-
-#include "fpp_ext.h"
-#include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-typedef int (*fci_fp_rule_cb_print_t)(const fpp_fp_rule_props_t* p_rule_props, uint16_t position);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
-
-int fci_fp_rule_get_by_name(FCI_CLIENT* p_cl, fpp_fp_rule_cmd_t* p_rtn_rule, uint16_t* p_rtn_idx, const char* p_rule_name);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
-
-int fci_fp_rule_add(FCI_CLIENT* p_cl, const char* p_rule_name, const fpp_fp_rule_cmd_t* p_rule_data);
-int fci_fp_rule_del(FCI_CLIENT* p_cl, const char* p_rule_name);
-
-int fci_fp_table_add(FCI_CLIENT* p_cl, const char* p_table_name);
-int fci_fp_table_del(FCI_CLIENT* p_cl, const char* p_table_name);
-int fci_fp_table_insert_rule(FCI_CLIENT* p_cl, const char* p_table_name, const char* p_rule_name, uint16_t position);
-int fci_fp_table_remove_rule(FCI_CLIENT* p_cl, const char* p_table_name, const char* p_rule_name);
-
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-
-int fci_fp_rule_ld_set_data(fpp_fp_rule_cmd_t* p_rule, uint32_t data);
-int fci_fp_rule_ld_set_mask(fpp_fp_rule_cmd_t* p_rule, uint32_t mask);
-int fci_fp_rule_ld_set_offset(fpp_fp_rule_cmd_t* p_rule, uint16_t offset, fpp_fp_offset_from_t offset_from);
-int fci_fp_rule_ld_set_invert(fpp_fp_rule_cmd_t* p_rule, bool invert);
-int fci_fp_rule_ld_set_match_action(fpp_fp_rule_cmd_t* p_rule, fpp_fp_rule_match_action_t match_action,
-                                    const char* p_next_rule_name);
-
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
-
-int fci_fp_table_print(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, const char* p_table_name,
-                       uint16_t position_init, uint16_t count);
-int fci_fp_rule_print_all(FCI_CLIENT* p_cl, fci_fp_rule_cb_print_t p_cb_print, uint16_t idx_init, uint16_t count);
-int fci_fp_rule_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
-
-/* ========================================================================= */
-
-#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_l2_bd.c b/sw/libfci_cli/src/libfci_interface/fci_l2_bd.c
deleted file mode 100644
index a73c54a..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_l2_bd.c
+++ /dev/null
@@ -1,1208 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
- 
- 
-#include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include "fpp.h"
-#include "fpp_ext.h"
-#include "libfci.h"
-#include "fci_common.h"
-#include "fci_l2_bd.h"
- 
- 
-/* ==== PRIVATE FUNCTIONS ================================================== */
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a bridge domain struct.
- * @param[in,out]  p_rtn_bd  The bridge domain struct to be converted.
- */
-static void ntoh_bd(fpp_l2_bd_cmd_t* p_rtn_bd)
-{
-    assert(NULL != p_rtn_bd);
-    
-    
-    p_rtn_bd->vlan = ntohs(p_rtn_bd->vlan);
-    p_rtn_bd->if_list = ntohl(p_rtn_bd->if_list);
-    p_rtn_bd->untag_if_list = ntohl(p_rtn_bd->untag_if_list);
-    ntoh_enum(&(p_rtn_bd->flags), sizeof(fpp_l2_bd_flags_t));
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a bridge domain struct.
- * @param[in,out]  p_rtn_bd  The bridge domain struct to be converted.
- */
-static void hton_bd(fpp_l2_bd_cmd_t* p_rtn_bd)
-{
-    assert(NULL != p_rtn_bd);
-    
-    
-    p_rtn_bd->vlan = htons(p_rtn_bd->vlan);
-    p_rtn_bd->if_list = htonl(p_rtn_bd->if_list);
-    p_rtn_bd->untag_if_list = htonl(p_rtn_bd->untag_if_list);
-    hton_enum(&(p_rtn_bd->flags), sizeof(fpp_l2_bd_flags_t));
-}
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a static entry struct.
- * @param[in,out]  p_rtn_stent  The static entry struct to be converted.
- */
-static void ntoh_stent(fpp_l2_static_ent_cmd_t* p_rtn_stent)
-{
-    assert(NULL != p_rtn_stent);
-    
-    
-    p_rtn_stent->vlan = ntohs(p_rtn_stent->vlan);
-    p_rtn_stent->forward_list = ntohl(p_rtn_stent->forward_list);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a static entry struct.
- * @param[in,out]  p_rtn_bd  The static entry struct to be converted.
- */
-static void hton_stent(fpp_l2_static_ent_cmd_t* p_rtn_stent)
-{
-    assert(NULL != p_rtn_stent);
-    
-    
-    p_rtn_stent->vlan = htons(p_rtn_stent->vlan);
-    p_rtn_stent->forward_list = htonl(p_rtn_stent->forward_list);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested bridge domain
- *              from the PFE. Identify the domain by its VLAN ID.
- * @param[in]   p_cl      FCI client instance
- * @param[out]  p_rtn_bd  Space for data from the PFE.
- * @param[in]   vlan      VLAN ID of the requested bridge domain.
- * @return      FPP_ERR_OK : Requested bridge domain was found.
- *                           A copy of its configuration was stored into p_rtn_bd.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_l2_bd_get_by_vlan(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_bd);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_bd_cmd_t cmd_to_fci = {0};
-    fpp_l2_bd_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
-                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_bd(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) && (vlan != (reply_from_fci.vlan)))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_L2_BD,
-                        sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_bd(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_bd = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested static entry
- *              from the PFE. Identify the entry by VLAN ID of the parent bridge domain and
- *              by MAC address of the entry.
- * @param[in]   p_cl      FCI client instance
- * @param[out]  p_rtn_stent  Space for data from the PFE.
- * @param[in]   vlan         VLAN ID of the parent bridge domain.
- * @param[in]   p_mac        MAC address of the requested static entry.
- * @return      FPP_ERR_OK : Requested static entry was found.
- *                           A copy of its configuration was stored into p_rtn_stent.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_l2_stent_get_by_vlanmac(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
-                                uint16_t vlan, const uint8_t p_mac[6])
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_stent);
-    assert(NULL != p_mac);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_stent(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) &&
-          !((vlan == reply_from_fci.vlan) && (0 == memcmp(p_mac, reply_from_fci.mac, 6))))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                        sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_stent(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_stent = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target bridge domain
- *                 in the PFE.
- * @param[in]      p_cl  FCI client instance
- * @param[in,out]  p_bd  Data struct which represents a new configuration of 
- *                       the target bridge domain.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @return         FPP_ERR_OK : Configuration of the target bridge domain was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_l2_bd_update(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_bd)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_bd);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_l2_bd_cmd_t cmd_to_fci = (*p_bd);
-    
-    /* send data */
-    hton_bd(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
-                                        (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_l2_bd_get_by_vlan(p_cl, p_bd, (p_bd->vlan));
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target static entry
- *                 in the PFE.
- * @param[in]      p_cl  FCI client instance
- * @param[in,out]  p_stent  Data struct which represents a new configuration of 
- *                          the target static entry.
- *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
- * @return         FPP_ERR_OK : Configuration of the target static entry was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_l2_stent_update(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_stent)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_stent);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_l2_static_ent_cmd_t cmd_to_fci = (*p_stent);
-    
-    /* send data */
-    hton_stent(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t), 
-                                                (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_l2_stent_get_by_vlanmac(p_cl, p_stent, (p_stent->vlan), (p_stent->mac));
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Use FCI calls to flush static entries from MAC tables of 
- *                 all bridge domains in the PFE.
- * @param[in]      p_cl  FCI client instance
- * @return         FPP_ERR_OK : Static entries of all bridge domains were 
- *                              successfully flushed in the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_flush_static(FCI_CLIENT* p_cl)
-{
-    assert(NULL != p_cl);
-    return fci_write(p_cl, FPP_CMD_L2_FLUSH_STATIC, 0u, NULL);
-}
- 
- 
-/*
- * @brief          Use FCI calls to flush dynamically learned entries from MAC tables of
- *                 all bridge domains in the PFE.
- * @param[in]      p_cl  FCI client instance
- * @return         FPP_ERR_OK : Learned entries of all bridge domains were
- *                              successfully flushed in the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_flush_learned(FCI_CLIENT* p_cl)
-{
-    assert(NULL != p_cl);
-    return fci_write(p_cl, FPP_CMD_L2_FLUSH_LEARNED, 0u, NULL);
-}
- 
- 
-/*
- * @brief          Use FCI calls to flush all entries from MAC tables of 
- *                 all bridge domains in the PFE.
- * @param[in]      p_cl  FCI client instance
- * @return         FPP_ERR_OK : All entries of all bridge domains were
- *                              successfully flushed in the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_flush_all(FCI_CLIENT* p_cl)
-{
-    assert(NULL != p_cl);
-    return fci_write(p_cl, FPP_CMD_L2_FLUSH_ALL, 0u, NULL);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
- 
- 
-/*
- * @brief       Use FCI calls to create a new bridge domain in the PFE.
- * @param[in]   p_cl      FCI client instance
- * @param[out]  p_rtn_if  Space for data from the PFE.
- *                        Will contain a copy of configuration data of 
- *                        the newly created bridge domain.
- *                        Can be NULL. If NULL, then there is no local data to fill.
- * @param[in]   vlan      VLAN ID of the new bridge domain.
- * @return      FPP_ERR_OK : New bridge domain was created.
- *                           If applicable, then its configuration data were 
- *                           copied into p_rtn_bd.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_l2_bd_add(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan)
-{
-    assert(NULL != p_cl);
-    /* 'p_rtn_bd' is allowed to be NULL */
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_l2_bd_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.vlan = vlan;
-    cmd_to_fci.ucast_hit  = 3u;  /* 3 == discard */
-    cmd_to_fci.ucast_miss = 3u;  /* 3 == discard */
-    cmd_to_fci.mcast_hit  = 3u;  /* 3 == discard */
-    cmd_to_fci.mcast_miss = 3u;  /* 3 == discard */
-    
-    /* send data */
-    hton_bd(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_REGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
-                                        (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data (if applicable) */
-    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_bd))
-    {
-        rtn = fci_l2_bd_get_by_vlan(p_cl, p_rtn_bd, vlan);
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to destroy the target bridge domain in the PFE.
- * @param[in]  p_cl    FCI client instance
- * @param[in]  vlan    VLAN ID of the bridge domain to destroy.
- * @return     FPP_ERR_OK : Bridge domain was destroyed.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_bd_del(FCI_CLIENT* p_cl, uint16_t vlan)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_l2_bd_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.vlan = vlan;
-    
-    /* send data */
-    hton_bd(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
-                                        (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to create a new static entry in the PFE.
- *              The new entry is associated with a provided parent bridge domain.
- * @param[in]   p_cl      FCI client instance
- * @param[out]  p_rtn_stent  Space for data from the PFE.
- *                           Will contain a copy of configuration data of 
- *                           the newly created static entry.
- *                           Can be NULL. If NULL, then there is no local data to fill.
- * @param[in]   vlan         VLAN ID of the parent bridge domain.
- * @param[in]   p_mac        MAC address of the new static entry.
- * @return      FPP_ERR_OK : New static entry was created.
- *                           If applicable, then its configuration data were 
- *                           copied into p_rtn_stent.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_l2_stent_add(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
-                     uint16_t vlan, const uint8_t p_mac[6])
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_mac);
-    /* 'p_rtn_stent' is allowed to be NULL */
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.vlan  = vlan;
-    memcpy(cmd_to_fci.mac, p_mac, 6);
-    
-    /* send data */
-    hton_stent(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_REGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t),
-                                                (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data (if applicable) */
-    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_stent))
-    {
-        rtn = fci_l2_stent_get_by_vlanmac(p_cl, p_rtn_stent, vlan, p_mac);
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to destroy the target static entry in the PFE.
- * @param[in]  p_cl    FCI client instance
- * @param[in]  vlan    VLAN ID of the parent bridge domain.
- * @param[in]  p_mac   MAC address of the static entry to be destroyed.
- * @return     FPP_ERR_OK : Static entry was destroyed.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_stent_del(FCI_CLIENT* p_cl, uint16_t vlan, const uint8_t p_mac[6])
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_mac);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.vlan = vlan;
-    memcpy(cmd_to_fci.mac, p_mac, 6);
-    
-    /* send data */
-    hton_stent(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t),
-                                                (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-/*
- * @defgroup    localdata_bd  [localdata_bd]
- * @brief:      Functions marked as [localdata_bd] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_l2_bd_update() to
- *              update configuration of the real bridge domain in the PFE.
- */
- 
- 
-/*
- * @brief          Set action to be done if unicast packet's destination MAC is
- *                 found (hit) in a bridge domain's MAC table.
- * @details        [localdata_bd]
- * @param[in,out]  p_bd  Local data to be modified.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]      hit_action   New action.
- *                              For details about bridge domain hit/miss actions, see
- *                              description of ucast_hit in the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_bd_ld_set_ucast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t hit_action)
-{
-    assert(NULL != p_bd);
-    p_bd->ucast_hit = hit_action;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set action to be done if unicast packet's destination MAC is NOT
- *                 found (miss) in a bridge domain's MAC table.
- * @details        [localdata_bd]
- * @param[in,out]  p_bd  Local data to be modified.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]      miss_action  New action.
- *                              For details about bridge domain hit/miss actions, see
- *                              description of ucast_hit in the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_bd_ld_set_ucast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t miss_action)
-{
-    assert(NULL != p_bd);
-    p_bd->ucast_miss = miss_action;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set action to be done if multicast packet's destination MAC is 
- *                 found (hit) in a bridge domain's MAC table.
- * @details        [localdata_bd]
- * @param[in,out]  p_bd  Local data to be modified.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]      hit_action   New action.
- *                              For details about bridge domain hit/miss actions, see
- *                              description of ucast_hit in the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_bd_ld_set_mcast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t hit_action)
-{
-    assert(NULL != p_bd);
-    p_bd->mcast_hit = hit_action;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set action to be done if multicast packet's destination MAC is NOT
- *                 found (miss) in a bridge domain's MAC table.
- * @details        [localdata_bd]
- * @param[in,out]  p_bd  Local data to be modified.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]      hit_action   New action.
- *                              For details about bridge domain hit/miss actions, see
- *                              description of ucast_hit in the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_bd_ld_set_mcast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t miss_action)
-{
-    assert(NULL != p_bd);
-    p_bd->mcast_miss = miss_action;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Insert a physical interface into a bridge domain.
- * @details        [localdata_bd]
- * @param[in,out]  p_bd  Local data to be modified.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]      phyif_id  Physical interface ID
- *                           IDs of physical interfaces are hardcoded.
- *                           See the FCI API Reference, chapter Interface Management.
- * @param[in]      add_vlan_tag  A request to tag (true) or untag (false) a traffic from 
- *                               the given physical interface.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_bd_ld_insert_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id, bool add_vlan_tag)
-{
-    assert(NULL != p_bd);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    if (32uL > phyif_id)  /* a check to prevent undefined behavior */
-    {
-        const uint32_t phyif_bitmask = (1uL << phyif_id);
-        p_bd->if_list |= phyif_bitmask;
-        if (add_vlan_tag)  
-        {
-            /* VLAN TAG is desired == physical interface must NOT be on the untag list. */
-            p_bd->untag_if_list &= ~phyif_bitmask;
-        }
-        else
-        {
-            /* VLAN TAG is NOT desired == physical interface must be on the untag list. */
-            p_bd->untag_if_list |= phyif_bitmask;
-        }
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Remove given physical interface from a bridge domain.
- * @details        [localdata_bd]
- * @param[in,out]  p_bd  Local data to be modified.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]      phyif_id  Physical interface ID
- *                           IDs of physical interfaces are hardcoded.
- *                           See the FCI API Reference, chapter Interface Management.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_bd_ld_remove_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
-{
-    assert(NULL != p_bd);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    if (32uL > phyif_id)  /* a check to prevent undefined behavior */
-    {
-        p_bd->if_list &= (uint32_t)(~(1uL << phyif_id));
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @defgroup    localdata_stent  [localdata_stent]
- * @brief:      Functions marked as [localdata_stent] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_l2_stent_update() to
- *              update configuration of the real static entry in the PFE.
- */
- 
- 
-/*
- * @brief          Set target physical interfaces (forwarding list) which 
- *                 shall receive a copy of the accepted traffic.
- * @details        [localdata_stent]
- *                 New forwarding list fully replaces the old one.
- * @param[in,out]  p_stent  Local data to be modified.
- *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
- * @param[in]      fwlist   Target physical interfaces (forwarding list). A bitset.
- *                          Each physical interface is represented by one bit.
- *                          Conversion between physical interface ID and a corresponding
- *                          egress vector bit is (1u << "physical interface ID").
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_stent_ld_set_fwlist(fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist)
-{
-    assert(NULL != p_stent);
-    p_stent->forward_list = fwlist;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set flag 'local' in a static entry.
- * @details        [localdata_stent]
- * @param[in,out]  p_stent  Local data to be modified.
- *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
- * @param[in]      local    A request to set/unset the flag.
- *                          See description of fpp_l2_static_ent_cmd_t type in 
- *                          the FCI API reference.
- *                          Related topic: L2L3 Bridge mode of a physical interface.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_stent_ld_set_local(fpp_l2_static_ent_cmd_t* p_stent, bool local)
-{
-    assert(NULL != p_stent);
-    p_stent->local = local;  /* NOTE: Implicit cast from bool to uintX_t */
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set flag 'discard on source MAC match' in a static entry.
- * @details        [localdata_stent]
- * @param[in,out]  p_stent  Local data to be modified.
- *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
- * @param[in]      src_discard  A request to set/unset the flag.
- *                              See description of fpp_l2_static_ent_cmd_t type in 
- *                              the FCI API reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_stent_ld_set_src_discard(fpp_l2_static_ent_cmd_t* p_stent, bool src_discard)
-{
-    assert(NULL != p_stent);
-    p_stent->src_discard = src_discard;  /* NOTE: Implicit cast from bool to uintX_t */
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set flag 'discard on destination MAC match' in a static entry.
- * @details        [localdata_stent]
- * @param[in,out]  p_stent  Local data to be modified.
- *                          Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
- * @param[in]      dst_discard  A request to set/unset the flag.
- *                              See description of fpp_l2_static_ent_cmd_t type in 
- *                              the FCI API reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_l2_stent_ld_set_dst_discard(fpp_l2_static_ent_cmd_t* p_stent, bool dst_discard)
-{
-    assert(NULL != p_stent);
-    p_stent->dst_discard = dst_discard;  /* NOTE: Implicit cast from bool to uintX_t */
-    return (FPP_ERR_OK);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
- 
- 
-/*
- * @brief      Query status of a "default" flag.
- * @details    [localdata_bd]
- * @param[in]  p_bd  Local data to be queried.
- *                   Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @return     At time when the data was obtained, the bridge domain:
- *             true  : was set as a default domain.
- *             false : was NOT set as a default domain.
- */
-bool fci_l2_bd_ld_is_default(const fpp_l2_bd_cmd_t* p_bd)
-{
-    assert(NULL != p_bd);
-    return (bool)(FPP_L2_BD_DEFAULT & (p_bd->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "fallback" flag.
- * @details    [localdata_bd]
- * @param[in]  p_bd  Local data to be queried.
- *                   Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @return     At time when the data was obtained, the bridge domain:
- *             true  : was set as a fallback domain.
- *             false : was NOT set as a fallback domain.
- */
-bool fci_l2_bd_ld_is_fallback(const fpp_l2_bd_cmd_t* p_bd)
-{
-    assert(NULL != p_bd);
-    return (bool)(FPP_L2_BD_FALLBACK & (p_bd->flags));
-}
- 
- 
-/*
- * @brief      Query whether the given physical interface is a member of a bridge domain.
- * @details    [localdata_bd]
- * @param[in]  p_bd      Local data to be queried.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]  phyif_id  phyif_id  Physical interface ID
- *                       IDs of physical interfaces are hardcoded.
- *                       See the FCI API Reference, chapter Interface Management.
- * @return     At time when the data was obtained, the given physical interface:
- *             true  : was a member of the given bridge domain.
- *             false : was NOT a member of the given bridge domain.
- */
-bool fci_l2_bd_ld_is_phyif(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
-{
-    assert(NULL != p_bd);
-    bool rtn = false;
-    if (32uL > phyif_id)
-    {
-        rtn = (bool)((1uL << phyif_id) & (p_bd->if_list));
-    }
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Query whether the requested physical interface is 
- *             tagged by the bridge domain (or not).
- * @details    [localdata_bd]
- * @param[in]  p_bd      Local data to be queried.
- *                       Initial data can be obtained via fci_l2_bd_get_by_vlan().
- * @param[in]  phyif_id  Physical interface ID
- *                       IDs of physical interfaces are hardcoded.
- *                       See the FCI API Reference, chapter Interface Management.
- * @return     At time when the data was obtained, the requested physical interface:
- *             true  : was being tagged by the given bridge domain.
- *             false : was NOT being tagged by the given bridge domain.
- */
-bool fci_l2_bd_ld_is_tagged(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id)
-{
-    assert(NULL != p_bd);
-    bool rtn = false;
-    if (32uL > phyif_id)
-    {
-        rtn = (bool)(!((1uL << phyif_id) & (p_bd->untag_if_list)));
-    }
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Query whether a physical interface is a member of 
- *             the static entry's forwarding list or not.
- * @details    [localdata_stent]
- * @param[in]  p_stent  Local data to be queried.
- *                      Initial data can be obtained via fci_l2_stent_get_by_vlanmac().
- * @param[in]  fwlist_bitflag  Queried physical interface. A bitflag.
- *                             Each physical interface is represented by one bit.
- *                             Conversion between physical interface ID and a corresponding
- *                             fwlist bit is (1u << "physical interface ID").
- *                             Hint: It is recommended to always query only a single bitflag.
- * @return     At time when the data was obtained, the logical interface:
- *             true  : had at least one queried forward list bitflag set
- *             false : had none of the queried forward list bitflags set
- */
-bool fci_l2_stent_ld_is_fwlist_phyifs(const fpp_l2_static_ent_cmd_t* p_stent,
-                                      uint32_t fwlist_bitflag)
-{
-    assert(NULL != p_stent);
-    return (bool)(fwlist_bitflag & (p_stent->forward_list));
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all bridge domains in the PFE and
- *             execute a callback print function for each reported bridge domain.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next bridge domain is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all bridge domains.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_bd_print_all(FCI_CLIENT* p_cl, fci_l2_bd_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_bd_cmd_t cmd_to_fci = {0};
-    fpp_l2_bd_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
-                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_bd(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        rtn = p_cb_print(&reply_from_fci);
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_L2_BD,
-                            sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_bd(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more bridge domains to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_L2_BD_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all available bridge domains in the PFE.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of bridge domains.
- * @return      FPP_ERR_OK : Successfully counted bridge domains.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No value copied.
- */
-int fci_l2_bd_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_bd_cmd_t cmd_to_fci = {0};
-    fpp_l2_bd_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint16_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_BD,
-                    sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting bridge domains) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_L2_BD,
-                        sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting bridge domains) */
-    }
-    
-    /* query loop runs till there are no more bridge domains to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_L2_BD_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all static entries in the PFE and
- *             execute a callback print function for each reported static entry.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next static entry is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all static entries.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_stent_print_all(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_stent(&reply_from_fci);  /* set correct byte order */
-    
-    /*  query loop  */
-    while (FPP_ERR_OK == rtn)
-    {
-        rtn = p_cb_print(&reply_from_fci);
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_stent(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more sttic entries to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all static entries in the PFE which
- *             are children of a given bridge domain. Execute a print function
- *             for each reported static entry.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next static entry is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @param[in]  vlan        VLAN ID of the parent bridge domain.
- * @return     FPP_ERR_OK : Successfully iterated through all suitable static entries.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_l2_stent_print_by_vlan(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print, 
-                               uint16_t vlan)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_stent(&reply_from_fci);  /* set correct byte order */
-    
-    /*  query loop  */
-    while (FPP_ERR_OK == rtn)
-    {
-        if (vlan == (reply_from_fci.vlan))
-        {
-            rtn = p_cb_print(&reply_from_fci);
-        }
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_stent(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more sttic entries to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all available static entries in the PFE.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of static entries.
- * @return      FPP_ERR_OK : Successfully counted static entries.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No value copied.
- */
-int fci_l2_stent_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint16_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting static entries) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting static entries) */
-    }
-    
-    /* query loop runs till there are no more sttic entries to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all available static entries in the PFE which
- *              are children of a given parent bridge domain.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of static entries.
- * @param[in]   vlan         VLAN ID of the parent bridge domain.
- * @return      FPP_ERR_OK : Successfully counted static entries.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No value copied.
- */
-int fci_l2_stent_get_count_by_vlan(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, uint16_t vlan)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_l2_static_ent_cmd_t cmd_to_fci = {0};
-    fpp_l2_static_ent_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint16_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting static entries) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        if (vlan == ntohs(reply_from_fci.vlan))  /* NOTE: vlan needs correct byte order */
-        {
-            count++;
-        }
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_L2_STATIC_ENT,
-                    sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting static entries) */
-    }
-    
-    /* query loop runs till there are no more sttic entries to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_L2_STATIC_EN_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ========================================================================= */
- 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_l2_bd.h b/sw/libfci_cli/src/libfci_interface/fci_l2_bd.h
deleted file mode 100644
index 5a32016..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_l2_bd.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
-
-#ifndef FCI_L2_BD_H_
-#define FCI_L2_BD_H_
-
-#include "fpp_ext.h"
-#include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-typedef int (*fci_l2_bd_cb_print_t)(const fpp_l2_bd_cmd_t* p_bd);
-typedef int (*fci_l2_stent_cb_print_t)(const fpp_l2_static_ent_cmd_t* p_stent);
-
-#define FCI_L2_BD_ACTION_FORWARD  (0u)
-#define FCI_L2_BD_ACTION_FLOOD    (1u)
-#define FCI_L2_BD_ACTION_PUNT     (2u)
-#define FCI_L2_BD_ACTION_DISCARD  (3u)
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
-
-int fci_l2_bd_get_by_vlan(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan);
-
-int fci_l2_stent_get_by_vlanmac(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent,
-                                uint16_t vlan, const uint8_t p_mac[6]);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
-
-int fci_l2_bd_update(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_bd);
-
-int fci_l2_stent_update(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_stent);
-
-int fci_l2_flush_static(FCI_CLIENT* p_cl);
-int fci_l2_flush_learned(FCI_CLIENT* p_cl);
-int fci_l2_flush_all(FCI_CLIENT* p_cl);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
-
-int fci_l2_bd_add(FCI_CLIENT* p_cl, fpp_l2_bd_cmd_t* p_rtn_bd, uint16_t vlan);
-int fci_l2_bd_del(FCI_CLIENT* p_cl, uint16_t vlan);
-
-int fci_l2_stent_add(FCI_CLIENT* p_cl, fpp_l2_static_ent_cmd_t* p_rtn_stent, uint16_t vlan, const uint8_t p_mac[6]);
-int fci_l2_stent_del(FCI_CLIENT* p_cl, uint16_t vlan, const uint8_t p_mac[6]);
-
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-
-int fci_l2_bd_ld_set_ucast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
-int fci_l2_bd_ld_set_ucast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
-int fci_l2_bd_ld_set_mcast_hit(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
-int fci_l2_bd_ld_set_mcast_miss(fpp_l2_bd_cmd_t* p_bd, uint8_t action);
-int fci_l2_bd_ld_insert_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id, bool add_vlan_tag);
-int fci_l2_bd_ld_remove_phyif(fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
-
-int fci_l2_stent_ld_set_fwlist(fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist);
-int fci_l2_stent_ld_set_local(fpp_l2_static_ent_cmd_t* p_stent, bool local);
-int fci_l2_stent_ld_set_src_discard(fpp_l2_static_ent_cmd_t* p_stent, bool src_discard);
-int fci_l2_stent_ld_set_dst_discard(fpp_l2_static_ent_cmd_t* p_stent, bool dst_discard);
-
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
-
-bool fci_l2_bd_ld_is_default(const fpp_l2_bd_cmd_t* p_bd);
-bool fci_l2_bd_ld_is_fallback(const fpp_l2_bd_cmd_t* p_bd);
-bool fci_l2_bd_ld_is_phyif(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
-bool fci_l2_bd_ld_is_tagged(const fpp_l2_bd_cmd_t* p_bd, uint32_t phyif_id);
-
-bool fci_l2_stent_ld_is_fwlist_phyifs(const fpp_l2_static_ent_cmd_t* p_stent, uint32_t fwlist_bitflag);
-
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
-
-int fci_l2_bd_print_all(FCI_CLIENT* p_cl, fci_l2_bd_cb_print_t p_cb_print);
-int fci_l2_bd_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
-
-int fci_l2_stent_print_all(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print);
-int fci_l2_stent_print_by_vlan(FCI_CLIENT* p_cl, fci_l2_stent_cb_print_t p_cb_print, uint16_t vlan);
-int fci_l2_stent_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
-int fci_l2_stent_get_count_by_vlan(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, uint16_t vlan);
-
-/* ========================================================================= */
-
-#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_log_if.c b/sw/libfci_cli/src/libfci_interface/fci_log_if.c
deleted file mode 100644
index 78a470b..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_log_if.c
+++ /dev/null
@@ -1,1730 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
- 
- 
-#include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include "fpp.h"
-#include "fpp_ext.h"
-#include "libfci.h"
-#include "fci_common.h"
-#include "fci_log_if.h"
- 
- 
-/* ==== PRIVATE FUNCTIONS ================================================== */
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a logical interface struct.
- * @param[in,out]  p_rtn_logif  The logical interface struct to be converted.
- */
-static void ntoh_logif(fpp_log_if_cmd_t* p_rtn_logif)
-{
-    assert(NULL != p_rtn_logif);
-    
-    
-    p_rtn_logif->id = ntohl(p_rtn_logif->id);
-    p_rtn_logif->parent_id = ntohl(p_rtn_logif->parent_id);
-    p_rtn_logif->egress = ntohl(p_rtn_logif->egress);
-    ntoh_enum(&(p_rtn_logif->flags), sizeof(fpp_if_flags_t));
-    ntoh_enum(&(p_rtn_logif->match), sizeof(fpp_if_m_rules_t));
-    
-    p_rtn_logif->arguments.vlan = ntohs(p_rtn_logif->arguments.vlan);
-    p_rtn_logif->arguments.ethtype = ntohs(p_rtn_logif->arguments.ethtype);
-    p_rtn_logif->arguments.sport = ntohs(p_rtn_logif->arguments.sport);
-    p_rtn_logif->arguments.dport = ntohs(p_rtn_logif->arguments.dport);
-    p_rtn_logif->arguments.ipv.v4.sip = ntohl(p_rtn_logif->arguments.ipv.v4.sip);
-    p_rtn_logif->arguments.ipv.v4.dip = ntohl(p_rtn_logif->arguments.ipv.v4.dip);
-    p_rtn_logif->arguments.ipv.v6.sip[0] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[0]);
-    p_rtn_logif->arguments.ipv.v6.sip[1] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[1]);
-    p_rtn_logif->arguments.ipv.v6.sip[2] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[2]);
-    p_rtn_logif->arguments.ipv.v6.sip[3] = ntohl(p_rtn_logif->arguments.ipv.v6.sip[3]);
-    p_rtn_logif->arguments.ipv.v6.dip[0] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[0]);
-    p_rtn_logif->arguments.ipv.v6.dip[1] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[1]);
-    p_rtn_logif->arguments.ipv.v6.dip[2] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[2]);
-    p_rtn_logif->arguments.ipv.v6.dip[3] = ntohl(p_rtn_logif->arguments.ipv.v6.dip[3]);
-    p_rtn_logif->arguments.hif_cookie = ntohl(p_rtn_logif->arguments.hif_cookie);
-    
-    p_rtn_logif->stats.processed = ntohl(p_rtn_logif->stats.processed);
-    p_rtn_logif->stats.accepted = ntohl(p_rtn_logif->stats.accepted);
-    p_rtn_logif->stats.rejected = ntohl(p_rtn_logif->stats.rejected);
-    p_rtn_logif->stats.discarded = ntohl(p_rtn_logif->stats.discarded);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a logical interface struct.
- * @param[in,out]  p_rtn_logif  The logical interface struct to be converted.
- */
-static void hton_logif(fpp_log_if_cmd_t* p_rtn_logif)
-{
-    assert(NULL != p_rtn_logif);
-    
-    
-    p_rtn_logif->id = htonl(p_rtn_logif->id);
-    p_rtn_logif->parent_id = htonl(p_rtn_logif->parent_id);
-    p_rtn_logif->egress = htonl(p_rtn_logif->egress);
-    hton_enum(&(p_rtn_logif->flags), sizeof(fpp_if_flags_t));
-    hton_enum(&(p_rtn_logif->match), sizeof(fpp_if_m_rules_t));
-    
-    p_rtn_logif->arguments.vlan = htons(p_rtn_logif->arguments.vlan);
-    p_rtn_logif->arguments.ethtype = htons(p_rtn_logif->arguments.ethtype);
-    p_rtn_logif->arguments.sport = htons(p_rtn_logif->arguments.sport);
-    p_rtn_logif->arguments.dport = htons(p_rtn_logif->arguments.dport);
-    p_rtn_logif->arguments.ipv.v4.sip = htonl(p_rtn_logif->arguments.ipv.v4.sip);
-    p_rtn_logif->arguments.ipv.v4.dip = htonl(p_rtn_logif->arguments.ipv.v4.dip);
-    p_rtn_logif->arguments.ipv.v6.sip[0] = htonl(p_rtn_logif->arguments.ipv.v6.sip[0]);
-    p_rtn_logif->arguments.ipv.v6.sip[1] = htonl(p_rtn_logif->arguments.ipv.v6.sip[1]);
-    p_rtn_logif->arguments.ipv.v6.sip[2] = htonl(p_rtn_logif->arguments.ipv.v6.sip[2]);
-    p_rtn_logif->arguments.ipv.v6.sip[3] = htonl(p_rtn_logif->arguments.ipv.v6.sip[3]);
-    p_rtn_logif->arguments.ipv.v6.dip[0] = htonl(p_rtn_logif->arguments.ipv.v6.dip[0]);
-    p_rtn_logif->arguments.ipv.v6.dip[1] = htonl(p_rtn_logif->arguments.ipv.v6.dip[1]);
-    p_rtn_logif->arguments.ipv.v6.dip[2] = htonl(p_rtn_logif->arguments.ipv.v6.dip[2]);
-    p_rtn_logif->arguments.ipv.v6.dip[3] = htonl(p_rtn_logif->arguments.ipv.v6.dip[3]);
-    p_rtn_logif->arguments.hif_cookie = htonl(p_rtn_logif->arguments.hif_cookie);
-    
-    p_rtn_logif->stats.processed = htonl(p_rtn_logif->stats.processed);
-    p_rtn_logif->stats.accepted = htonl(p_rtn_logif->stats.accepted);
-    p_rtn_logif->stats.rejected = htonl(p_rtn_logif->stats.rejected);
-    p_rtn_logif->stats.discarded = htonl(p_rtn_logif->stats.discarded);
-}
- 
- 
-/*
- * @brief       Set/unset a bitflag in a logical interface struct.
- * @param[out]  p_rtn_logif  The logical interface struct to be modified.
- * @param[in]   enable  New state of the bitflag.
- * @param[in]   flag    The bitflag.
- */
-static void set_flag(fpp_log_if_cmd_t* p_rtn_logif, bool enable,
-                     fpp_if_flags_t flag)
-{
-    assert(NULL != p_rtn_logif);
-    
-    
-    if (enable)
-    {
-        p_rtn_logif->flags |= flag;
-    }
-    else
-    {
-        p_rtn_logif->flags &= (fpp_if_flags_t)(~flag);
-    }
-}
- 
- 
-/*
- * @brief       Set/unset a match rule bitflag in a logical interface stuct.
- * @param[out]  p_rtn_logif  The logical interface struct to be modified.
- * @param[in]   enable       New state of the bitflag.
- * @param[in]   match_rule   The match rule bitflag.
- */
-static void set_mr_flag(fpp_log_if_cmd_t* p_rtn_logif, bool enable,
-                        fpp_if_m_rules_t match_rule)
-{
-    assert(NULL != p_rtn_logif);
-    
-    
-    if (enable)
-    {
-        p_rtn_logif->match |= match_rule;
-    }
-    else
-    {
-        p_rtn_logif->match &= (fpp_if_flags_t)(~match_rule);
-    }
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested logical interface
- *              from the PFE. Identify the interface by its name.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_log_if_get_by_name_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_logif  Space for data from the PFE.
- * @param[in]   p_name       Name of the requested logical interface.
- *                           Names of logical interfaces are user-defined.
- *                           See fci_log_if_add().
- * @return      FPP_ERR_OK : Requested logical interface was found.
- *                           A copy of its configuration was stored into p_rtn_logif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_log_if_get_by_name(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, 
-                           const char* p_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_logif);
-    assert(NULL != p_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    fpp_log_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_logif(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_logif(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_logif = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested logical interface
- *              from the PFE. Identify the interface by its name.
- * @details     This is a standalone (_sa) function.
- *              It shows how to properly access a logical interface. Namely:
- *              1. Lock the interface database for exclusive access by this FCI client.
- *              2. Execute one or more FCI calls which access 
- *                 physical or logical interfaces.
- *              3. Unlock the interface database's exclusive access lock.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_logif  Space for data from the PFE.
- * @param[in]   p_name       Name of the requested logical interface.
- *                           Names of logical interfaces are user-defined.
- *                           See fci_log_if_add().
- * @return      FPP_ERR_OK : Requested logical interface was found.
- *                           A copy of its configuration was stored into p_rtn_logif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-inline int fci_log_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, 
-                                     const char* p_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_logif);
-    assert(NULL != p_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* lock the interface database for exclusive access by this FCI client */
-    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
-    
-    /* execute "payload" - FCI calls which access physical or logical interfaces */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_log_if_get_by_name(p_cl, p_rtn_logif, p_name);
-    }
-    
-    /* unlock the interface database's exclusive access lock */
-    /* result of the unlock action is returned only if previous "payload" actions were OK */
-    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
-    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested logical interface
- *              from the PFE. Identify the interface by its ID.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_log_if_get_by_name_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_logif  Space for data from the PFE.
- * @param[in]   id           ID of the requested logical interface.
- *                           IDs of logical interfaces are assigned automatically.
- *                           Hint: It is better to identify logical interfaces by 
- *                                 their interface names.
- * @return      FPP_ERR_OK : Requested logical interface was found.
- *                           A copy of its configuration was stored into p_rtn_logif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_log_if_get_by_id(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, uint32_t id)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_logif);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    fpp_log_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_logif(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while ((FPP_ERR_OK == rtn) && (id != (reply_from_fci.id)))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_logif(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_logif = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target logical interface 
- *                 in the PFE.
- * @details        To use this function properly, the PFE interface database must be
- *                 locked for exclusive access. See fci_log_if_update_sa() for 
- *                 an example how to lock the database.
- * @param[in]      p_cl     FCI client instance
- * @param[in,out]  p_logif  Data struct which represents a new configuration of
- *                          the target logical interface.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the target logical interface was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_log_if_update(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_logif);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_log_if_cmd_t cmd_to_fci = (*p_logif);
-    
-    /* send data */
-    hton_logif(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
-                                         (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_log_if_get_by_id(p_cl, p_logif, (p_logif->id));
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target logical interface 
- *                 in the PFE.
- * @details        This is a standalone (_sa) function.
- *                 It shows how to properly access a logical interface. Namely:
- *                 1. Lock the interface database for exclusive access by this FCI client.
- *                 2. Execute one or more FCI calls which access 
- *                    physical or logical interfaces.
- *                 3. Unlock the interface database's exclusive access lock.
- * @param[in]      p_cl     FCI client instance
- * @param[in,out]  p_logif  Data struct which represents a new configuration of
- *                          the target logical interface.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the target logical interface was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-inline int fci_log_if_update_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_logif);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* lock the interface database for exclusive access by this FCI client */
-    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
-    
-    /* execute "payload" - FCI calls which access physical or logical interfaces */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_log_if_update(p_cl, p_logif);
-    }
-    
-    /* unlock the interface database's exclusive access lock */
-    /* result of the unlock action is returned only if previous "payload" actions were OK */
-    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
-    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
- 
- 
-/*
- * @brief       Use FCI calls to create a new logical interface in the PFE.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_log_if_update_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl           FCI client instance
- * @param[out]  p_rtn_logif    Space for data from the PFE.
- *                             Will contain a copy of configuration data of 
- *                             the newly created logical interface.
- *                             Can be NULL. If NULL, then there is no local data to fill.
- * @param[in]   p_name         Name of the new logical interface.
- *                             The name is user-defined.
- * @param[in]   p_parent_name  Name of a parent physical interface.
- *                             Names of physical interfaces are hardcoded.
- *                             See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : New logical interface was created.
- *                           If applicable, then its configuration data were 
- *                           copied into p_rtn_logif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_log_if_add(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name, 
-                   const char* p_parent_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_name);
-    assert(NULL != p_parent_name);
-    /* 'p_rtn_logif' is allowed to be NULL */
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.name), p_name, IFNAMSIZ);
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = set_text((cmd_to_fci.parent_name), p_parent_name, IFNAMSIZ);
-    }
-    
-    /* send data */
-    if (FPP_ERR_OK == rtn)
-    {
-        hton_logif(&cmd_to_fci);  /* set correct byte order */
-        cmd_to_fci.action = FPP_ACTION_REGISTER;
-        rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
-                                             (unsigned short*)(&cmd_to_fci));
-    }
-    
-    /* read back and update caller data (if applicable) */
-    if ((FPP_ERR_OK == rtn) && (NULL != p_rtn_logif))
-    {
-        rtn = fci_log_if_get_by_name(p_cl, p_rtn_logif, p_name);
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to destroy the target logical interface in the PFE.
- * @details    To use this function properly, the PFE interface database must be
- *             locked for exclusive access. See fci_log_if_update_sa() for 
- *             an example how to lock the database.
- * @param[in]  p_cl    FCI client instance
- * @param[in]  p_name  Name of the logical interface to destroy.
- * @return     FPP_ERR_OK : Logical interface was destroyed.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_log_if_del(FCI_CLIENT* p_cl, const char* p_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.name), p_name, IFNAMSIZ);
-    
-    /* send data */
-    if (FPP_ERR_OK == rtn)
-    {
-        hton_logif(&cmd_to_fci);  /* set correct byte order */
-        cmd_to_fci.action = FPP_ACTION_DEREGISTER;
-        rtn = fci_write(p_cl, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci));
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-/*
- * @defgroup    localdata_logif  [localdata_logif]
- * @brief:      Functions marked as [localdata_logif] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_log_if_update() or fci_log_if_update_sa() to
- *              update configuration of the real logical interface in the PFE.
- */
- 
- 
-/*
- * @brief          Enable ("up") a logical interface.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or 
- *                          fci_log_if_get_by_id().
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_enable(fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    p_logif->flags |= FPP_IF_ENABLED;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Disable ("down") a logical interface.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or 
- *                          fci_log_if_get_by_id().
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_disable(fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    p_logif->flags &= (fpp_if_flags_t)(~FPP_IF_ENABLED);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset promiscuous mode of a logical interface.
- * @details        [localdata_logif]
- *                 Promiscuous mode of a logical interface means the interface
- *                 will accept all incoming traffic, regardless of active match rules.
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or 
- *                          fci_log_if_get_by_id().
- * @param[in]      promisc  A request to set/unset the promiscuous mode.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_promisc(fpp_log_if_cmd_t* p_logif, bool promisc)
-{
-    assert(NULL != p_logif);
-    set_flag(p_logif, promisc, FPP_IF_PROMISC);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset loopback mode of a logical interface.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif   Local data to be modified.
- *                           Initial data can be obtained via fci_log_if_get_by_name() or 
- *                           fci_log_if_get_by_id().
- * @param[in]      loopback  A request to set/unset the loopback mode.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_loopback(fpp_log_if_cmd_t* p_logif, bool loopback)
-{
-    assert(NULL != p_logif);
-    set_flag(p_logif, loopback, FPP_IF_LOOPBACK);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set match mode (chaining mode of match rules).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      match_mode_is_or  A request to set match mode.
- *                                   For details about logical interface match modes, see
- *                                   description of a fpp_if_flags_t type in
- *                                   the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_match_mode_or(fpp_log_if_cmd_t* p_logif, bool match_mode_is_or)
-{
-    assert(NULL != p_logif);
-    set_flag(p_logif, match_mode_is_or, FPP_IF_MATCH_OR);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset inverted mode of traffic acceptance.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      discard_on_match  A request to set/unset inverted mode.
- *                                   For details about logical interface inverted mode, see
- *                                   description of a fpp_if_flags_t type in
- *                                   the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_discard_on_m(fpp_log_if_cmd_t* p_logif, bool discard_on_match)
-{
-    assert(NULL != p_logif);
-    set_flag(p_logif, discard_on_match, FPP_IF_DISCARD);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set target physical interfaces (egress vector) which 
- *                 shall receive a copy of the accepted traffic.
- * @details        [localdata_logif]
- *                 New egress vector fully replaces the old one.
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      egress   Target physical interfaces (egress vector). A bitset.
- *                          Each physical interface is represented by one bit.
- *                          Conversion between physical interface ID and a corresponding
- *                          egress vector bit is (1u << "physical interface ID").
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_egress_phyifs(fpp_log_if_cmd_t* p_logif, uint32_t egress)
-{
-    assert(NULL != p_logif);
-    p_logif->egress = egress;
-    return (FPP_ERR_OK);
-}
- 
- 
- 
- 
-/*
- * @brief          Clear all match rules and zeroify all match rule arguments.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_clear_all_mr(fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    p_logif->match = 0u;
-    memset(&(p_logif->arguments), 0, sizeof(fpp_if_m_args_t));
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_eth(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_ETH);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_vlan(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_VLAN);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_pppoe(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_PPPOE);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_arp(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_ARP);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_mcast(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_MCAST);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_ip4(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IPV4);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_ip6(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IPV6);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_ipx(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IPX);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_bcast(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_BCAST);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_udp(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_UDP);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_tcp(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_TCP);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_icmp(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_ICMP);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule.
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_type_igmp(fpp_log_if_cmd_t* p_logif, bool do_set)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_TYPE_IGMP);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      vlan     New VLAN ID for this match rule.
- *                          When this match rule is active, is compares value of its
- *                          'vlan' argument with value of the traffic's 'VID' field.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_vlan(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t vlan)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_VLAN);
-    p_logif->arguments.vlan = vlan;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      proto    New IP Protocol Number for this match rule.
- *                          When this match rule is active, is compares value of its
- *                          'proto' argument with value of the traffic's 'Protocol' field.
- *                          See "IANA Assigned Internet Protocol Number":
- *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_proto(fpp_log_if_cmd_t* p_logif, bool do_set, uint8_t proto)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_PROTO);
-    p_logif->arguments.proto = proto;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      sport    New source port value for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'sport' argument with value of the traffic's 'source port' field.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_sport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t sport)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SPORT);
-    p_logif->arguments.sport = sport;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      dport    New destination port value for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'dport' argument with value of the traffic's 
- *                          'destination port' field.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_dport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t dport)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DPORT);
-    p_logif->arguments.dport = dport;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      p_sip6   New source IPv6 address for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'sip' argument with value of the traffic's 
- *                          'source address' (applicable on IPv6 traffic only).
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_sip6(fpp_log_if_cmd_t* p_logif, bool do_set, 
-                              const uint32_t p_sip6[4])
-{
-    assert(NULL != p_logif);
-    assert(NULL != p_sip6);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SIP6);
-    memcpy((p_logif->arguments.ipv.v6.sip), p_sip6, (4 * sizeof(uint32_t)));
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      p_dip6   New destination IPv6 address for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'dip' argument with value of the traffic's 
- *                          'destination address' (applicable on IPv6 traffic only).
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_dip6(fpp_log_if_cmd_t* p_logif, bool do_set, 
-                              const uint32_t p_dip6[4])
-{
-    assert(NULL != p_logif);
-    assert(NULL != p_dip6);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DIP6);
-    memcpy((p_logif->arguments.ipv.v6.dip), p_dip6, (4 * sizeof(uint32_t)));
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      sip      New source IPv4 address for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'sip' argument with value of the traffic's 
- *                          'source address' (applicable on IPv4 traffic only).
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_sip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t sip)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SIP);
-    p_logif->arguments.ipv.v4.sip = sip;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      dip      New destination IPv4 address for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'dip' argument with value of the traffic's 
- *                          'destination address' (applicable on IPv4 traffic only).
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_dip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t dip)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DIP);
-    p_logif->arguments.ipv.v4.dip = dip;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      ethtype  New EtherType number for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'ethtype' argument with value of the traffic's 'EtherType' field.
- *                          See "IANA EtherType number (IEEE 802)":
- *                https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_ethtype(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t ethtype)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_ETHTYPE);
-    p_logif->arguments.ethtype = ethtype;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      fp_table0_name  Name of a new FlexibleParser table for this match rule.
- *                                 When this match rule is active, it inspects the traffic
- *                                 according to rules listed in the referenced
- *                                 FlexibleParser table.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_fp0(fpp_log_if_cmd_t* p_logif, bool do_set, 
-                             const char* fp_table0_name)
-{
-    assert(NULL != p_logif);
-    /* 'fp_table0_name' is allowed to be NULL */
-    
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_FP0);
-    return set_text((p_logif->arguments.fp_table0), fp_table0_name, IFNAMSIZ);
-}
-
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      fp_table0_name  Name of a new FlexibleParser table for this match rule.
- *                                 When this match rule is active, it inspects the traffic
- *                                 according to rules listed in the referenced
- *                                 FlexibleParser table.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_fp1(fpp_log_if_cmd_t* p_logif, bool do_set, 
-                             const char* fp_table1_name)
-{
-    assert(NULL != p_logif);
-    /* 'fp_table1_name' is allowed to be NULL */
-    
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_FP1);
-    return set_text((p_logif->arguments.fp_table1), fp_table1_name, IFNAMSIZ);
-}
-
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      p_smac   New source MAC address for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'smac' argument with value of the traffic's 'source MAC' field.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_smac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_smac[6])
-{
-    assert(NULL != p_logif);
-    assert(NULL != p_smac);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_SMAC);
-    memcpy((p_logif->arguments.smac), p_smac, (6 * sizeof(uint8_t)));
-    return (FPP_ERR_OK);
-}
-
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      p_dmac   New destination MAC address for this match rule.
- *                          When this match rule is active, it compares value of its
- *                          'dmac' argument with value of the traffic's 
- *                          'destination MAC' field.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_dmac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_dmac[6])
-{
-    assert(NULL != p_logif);
-    assert(NULL != p_dmac);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_DMAC);
-    memcpy((p_logif->arguments.dmac), p_dmac, (6 * sizeof(uint8_t)));
-    return (FPP_ERR_OK);
-}
-
-/*
- * @brief          Set/unset the given match rule (and its argument).
- * @details        [localdata_logif]
- * @param[in,out]  p_logif  Local data to be modified.
- *                          Initial data can be obtained via fci_log_if_get_by_name() or
- *                          fci_log_if_get_by_id().
- * @param[in]      do_set   Request to set or unset the given match rule.
- * @param[in]      hif_cookie  New hif cookiee value for this match rule.
- *                             When this match rule is active, it compares value of its
- *                            'hif_cookiee' argument with value of the hif_cookie tag.
- *                             Hif_cookie tag is a part of internal overhead data, attached
- *                             to the traffic by the host's driver.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_log_if_ld_set_mr_hif_cookie(fpp_log_if_cmd_t* p_logif, bool do_set, 
-                                    uint32_t hif_cookie)
-{
-    assert(NULL != p_logif);
-    set_mr_flag(p_logif, do_set, FPP_IF_MATCH_HIF_COOKIE);
-    p_logif->arguments.hif_cookie = hif_cookie;
-    return (FPP_ERR_OK);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
- 
- 
-/*
- * @brief      Query status of an "enable" flag.
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @return     At time when the data was obtained, the logical interface:
- *             true  : was enabled ("up")
- *             false : was disabled ("down")
- */
-bool fci_log_if_ld_is_enabled(const fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    return (bool)(FPP_IF_ENABLED & (p_logif->flags));
-}
- 
- 
-/*
- * @brief      Query status of an "enable" flag (inverted logic).
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @return     At time when the data was obtained, the logical interface:
- *             true  : was disabled ("down")
- *             false : was enabled ("up")
- */
-bool fci_log_if_ld_is_disabled(const fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    return !fci_log_if_ld_is_enabled(p_logif);
-}
- 
- 
-/*
- * @brief      Query status of a "promiscuous mode" flag.
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @return     At time when the data was obtained, the logical interface:
- *             true  : was in a promiscuous mode
- *             false : was NOT in a promiscuous mode
- */
-bool fci_log_if_ld_is_promisc(const fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    return (bool)(FPP_IF_PROMISC & (p_logif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "loopback" flag.
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @return     At time when the data was obtained, the logical interface:
- *             true  : was in a loopback mode
- *             false : was NOT in a loopback mode
- */
-bool fci_log_if_ld_is_loopback(const fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    return (bool)(FPP_IF_LOOPBACK & (p_logif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "match mode" flag (chaining mode of match rules).
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @return     At time when the data was obtained, the logical interface:
- *             true  : was using OR match mode
- *             false : was using AND match mode
- */
-bool fci_log_if_ld_is_match_mode_or(const fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    return (bool)(FPP_IF_MATCH_OR & (p_logif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "discard on match" flag.
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @return     At time when the data was obtained, the logical interface:
- *             true  : was discarding traffic that passed matching process
- *             false : was NOT discarding traffic that passed matching process
- */
-bool fci_log_if_ld_is_discard_on_m(const fpp_log_if_cmd_t* p_logif)
-{
-    assert(NULL != p_logif);
-    return (bool)(FPP_IF_DISCARD & (p_logif->flags));
-}
- 
- 
-/*
- * @brief      Query whether a physical interface is a member of the egress vector or not.
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @param[in]  egress_bitflag  Queried physical interface. A bitflag.
- *                             Each physical interface is represented by one bit.
- *                             Conversion between physical interface ID and a corresponding
- *                             egress vector bit is (1u << "physical interface ID").
- *                             Hint: It is recommended to always query only a single bitflag.
- * @return     At time when the data was obtained, the logical interface:
- *             true  : had at least one queried egress bitflag set
- *             false : had none of the queried egress bitflags set
- */
-bool fci_log_if_ld_is_egress_phyifs(const fpp_log_if_cmd_t* p_logif, uint32_t egress_bitflag)
-{
-    assert(NULL != p_logif);
-    return (bool)(egress_bitflag & (p_logif->match));
-}
- 
- 
-/*
- * @brief      Query whether a match rule is active or not.
- * @details    [localdata_logif]
- * @param[in]  p_logif  Local data to be queried.
- *                      Initial data can be obtained via fci_log_if_get_by_name() or 
- *                      fci_log_if_get_by_id().
- * @param[in]  match_rule  Queried match rule.
- *                         Hint: It is recommended to always query only a single match rule.
- * @return     At time when the data was obtained, the logical interface:
- *             true  : had at least one queried match rule set
- *             false : had none of the queried match rules set
- */
-bool fci_log_if_ld_is_match_rule(const fpp_log_if_cmd_t* p_logif, fpp_if_m_rules_t match_rule)
-{
-    assert(NULL != p_logif);
-    return (bool)(match_rule & (p_logif->match));
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all logical interfaces in the PFE and
- *             execute a callback print function for each reported logical interface.
- * @details    To use this function properly, the PFE interface database must be
- *             locked for exclusive access. See fci_log_if_print_all_sa() for 
- *             an example how to lock the database.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next logical interface is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all logical interfaces.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_log_if_print_all(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    fpp_log_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_logif(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        rtn = p_cb_print(&reply_from_fci);
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                            sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_logif(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more logical interfaces to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all logical interfaces in the PFE and
- *             execute a callback print function for each reported logical interface.
- * @details    This is a standalone (_sa) function.
- *             It shows how to properly access a logical interface. Namely:
- *             1. Lock the interface database for exclusive access by this FCI client.
- *             2. Execute one or more FCI calls which access 
- *                physical or logical interfaces.
- *             3. Unlock the interface database's exclusive access lock.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next logical interface is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all logical interfaces.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_log_if_print_all_sa(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* lock the interface database for exclusive access by this FCI client */
-    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
-    
-    /* execute "payload" - FCI calls which access physical or logical interfaces */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_log_if_print_all(p_cl, p_cb_print);
-    }
-    
-    /* unlock the interface database's exclusive access lock */
-    /* result of the unlock action is returned only if previous "payload" actions were OK */
-    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
-    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all logical interfaces in the PFE which
- *             are children of a given parent physical interface. Execute a print function
- *             for each reported logical interface.
- * @details    To use this function properly, the PFE interface database must be
- *             locked for exclusive access. See fci_log_if_print_all_sa() for 
- *             an example how to lock the database.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next logical interface is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @param[in]   p_parent_name  Name of a parent physical interface.
- *                             Names of physical interfaces are hardcoded.
- *                             See the FCI API Reference, chapter Interface Management.
- * @return     FPP_ERR_OK : Successfully iterated through all suitable logical interfaces.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_log_if_print_by_parent(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print, 
-                               const char* p_parent_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    assert(NULL != p_parent_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    fpp_log_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_logif(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        if (0 == strcmp((reply_from_fci.parent_name), p_parent_name))
-        {
-            rtn = p_cb_print(&reply_from_fci);
-        }
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                            sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_logif(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more logical interfaces to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all logical interfaces in the PFE.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_log_if_print_all_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of logical interfaces.
- * @return      FPP_ERR_OK : Successfully counted logical interfaces.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_log_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    fpp_log_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint16_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting interfaces) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting interfaces) */
-    }
-    
-    /* query loop runs till there are no more logical interfaces to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all logical interfaces in the PFE which
- *              are children of a given parent physical interface.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_log_if_print_all_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl           FCI client instance
- * @param[out]  p_rtn_count    Space to store the count of logical interfaces.
- * @param[in]   p_parent_name  Name of a parent physical interface.
- *                             Names of physical interfaces are hardcoded.
- *                             See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Successfully counted logical interfaces.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_log_if_get_count_by_parent(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
-                                   const char* p_parent_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_log_if_cmd_t cmd_to_fci = {0};
-    fpp_log_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint16_t count = 0u;
-    
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                    sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting interfaces) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        if (0 == strcmp((reply_from_fci.parent_name), p_parent_name))
-        {
-            count++;
-        }
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_LOG_IF,
-                        sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting interfaces) */
-    }
-    
-    /* query loop runs till there are no more logical interfaces to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ========================================================================= */
- 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_log_if.h b/sw/libfci_cli/src/libfci_interface/fci_log_if.h
deleted file mode 100644
index f31552c..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_log_if.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
-
-#ifndef FCI_LOG_IF_H_
-#define FCI_LOG_IF_H_
-
-#include "fpp_ext.h"
-#include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-typedef int (*fci_log_if_cb_print_t)(const fpp_log_if_cmd_t* p_logif);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
-
-int fci_log_if_get_by_name(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name);
-int fci_log_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name);
-int fci_log_if_get_by_id(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, uint32_t id);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
-
-int fci_log_if_update(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif);
-int fci_log_if_update_sa(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_logif);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
-
-int fci_log_if_add(FCI_CLIENT* p_cl, fpp_log_if_cmd_t* p_rtn_logif, const char* p_name, const char* p_parent_name);
-int fci_log_if_del(FCI_CLIENT* p_cl, const char* p_name);
-
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-
-int fci_log_if_ld_enable(fpp_log_if_cmd_t* p_logif);
-int fci_log_if_ld_disable(fpp_log_if_cmd_t* p_logif);
-int fci_log_if_ld_set_promisc(fpp_log_if_cmd_t* p_logif, bool promisc);
-int fci_log_if_ld_set_loopback(fpp_log_if_cmd_t* p_logif, bool loopback);
-int fci_log_if_ld_set_match_mode_or(fpp_log_if_cmd_t* p_logif, bool match_mode_is_or);
-int fci_log_if_ld_set_discard_on_m(fpp_log_if_cmd_t* p_logif, bool discard_on_match);
-int fci_log_if_ld_set_egress_phyifs(fpp_log_if_cmd_t* p_logif, uint32_t egress);
-
-int fci_log_if_ld_clear_all_mr(fpp_log_if_cmd_t* p_logif);
-int fci_log_if_ld_set_mr_type_eth(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_vlan(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_pppoe(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_arp(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_mcast(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_ip4(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_ip6(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_ipx(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_bcast(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_udp(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_tcp(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_icmp(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_type_igmp(fpp_log_if_cmd_t* p_logif, bool do_set);
-int fci_log_if_ld_set_mr_vlan(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t vlan);
-int fci_log_if_ld_set_mr_proto(fpp_log_if_cmd_t* p_logif, bool do_set, uint8_t proto);
-int fci_log_if_ld_set_mr_sport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t sport);
-int fci_log_if_ld_set_mr_dport(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t dport);
-int fci_log_if_ld_set_mr_sip6(fpp_log_if_cmd_t* p_logif, bool do_set, const uint32_t p_sip6[4]);
-int fci_log_if_ld_set_mr_dip6(fpp_log_if_cmd_t* p_logif, bool do_set, const uint32_t p_sip6[4]);
-int fci_log_if_ld_set_mr_sip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t sip);
-int fci_log_if_ld_set_mr_dip(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t dip);
-int fci_log_if_ld_set_mr_ethtype(fpp_log_if_cmd_t* p_logif, bool do_set, uint16_t ethtype);
-int fci_log_if_ld_set_mr_fp0(fpp_log_if_cmd_t* p_logif, bool do_set, const char* fp_table0_name);
-int fci_log_if_ld_set_mr_fp1(fpp_log_if_cmd_t* p_logif, bool do_set, const char* fp_table1_name);
-int fci_log_if_ld_set_mr_smac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_smac[6]);
-int fci_log_if_ld_set_mr_dmac(fpp_log_if_cmd_t* p_logif, bool do_set, const uint8_t p_dmac[6]);
-int fci_log_if_ld_set_mr_hif_cookie(fpp_log_if_cmd_t* p_logif, bool do_set, uint32_t hif_cookie);
-
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
-
-bool fci_log_if_ld_is_enabled(const fpp_log_if_cmd_t* p_logif);
-bool fci_log_if_ld_is_disabled(const fpp_log_if_cmd_t* p_logif);
-bool fci_log_if_ld_is_promisc(const fpp_log_if_cmd_t* p_logif);
-bool fci_log_if_ld_is_loopback(const fpp_log_if_cmd_t* p_logif);
-bool fci_log_if_ld_is_match_mode_or(const fpp_log_if_cmd_t* p_logif);
-bool fci_log_if_ld_is_discard_on_m(const fpp_log_if_cmd_t* p_logif);
-bool fci_log_if_ld_is_egress_phyifs(const fpp_log_if_cmd_t* p_logif, uint32_t phyif_bitflag);
-bool fci_log_if_ld_is_mr(const fpp_log_if_cmd_t* p_logif, fpp_if_m_rules_t match_rule);
-
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
-
-int fci_log_if_print_all(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print);
-int fci_log_if_print_all_sa(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print);
-int fci_log_if_print_by_parent(FCI_CLIENT* p_cl, fci_log_if_cb_print_t p_cb_print, const char* p_parent_name);
-int fci_log_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
-int fci_log_if_get_count_by_parent(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
-
-/* ========================================================================= */
-
-#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_phy_if.c b/sw/libfci_cli/src/libfci_interface/fci_phy_if.c
deleted file mode 100644
index fa4b6bf..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_phy_if.c
+++ /dev/null
@@ -1,994 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
- 
- 
-#include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include "fpp.h"
-#include "fpp_ext.h"
-#include "libfci.h"
-#include "fci_common.h"
-#include "fci_phy_if.h"
- 
- 
-/* ==== PRIVATE FUNCTIONS ================================================== */
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a physical interface struct.
- * @param[in,out]  p_rtn_phyif  The physical interface struct to be converted.
- */
-static void ntoh_phyif(fpp_phy_if_cmd_t* p_rtn_phyif)
-{
-    assert(NULL != p_rtn_phyif);
-    
-    
-    p_rtn_phyif->id = ntohl(p_rtn_phyif->id);
-    ntoh_enum(&(p_rtn_phyif->flags), sizeof(fpp_if_flags_t));
-    ntoh_enum(&(p_rtn_phyif->mode), sizeof(fpp_phy_if_op_mode_t));
-    ntoh_enum(&(p_rtn_phyif->block_state), sizeof(fpp_phy_if_block_state_t));
-    p_rtn_phyif->stats.ingress = ntohl(p_rtn_phyif->stats.ingress);
-    p_rtn_phyif->stats.egress = ntohl(p_rtn_phyif->stats.egress);
-    p_rtn_phyif->stats.malformed = ntohl(p_rtn_phyif->stats.malformed);
-    p_rtn_phyif->stats.discarded = ntohl(p_rtn_phyif->stats.discarded);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a physical interface struct.
- * @param[in,out]  p_rtn_phyif  The physical interface struct to be converted.
- */
-static void hton_phyif(fpp_phy_if_cmd_t* p_rtn_phyif)
-{
-    assert(NULL != p_rtn_phyif);
-    
-    
-    p_rtn_phyif->id = htonl(p_rtn_phyif->id);
-    hton_enum(&(p_rtn_phyif->flags), sizeof(fpp_if_flags_t));
-    hton_enum(&(p_rtn_phyif->mode), sizeof(fpp_phy_if_op_mode_t));
-    hton_enum(&(p_rtn_phyif->block_state), sizeof(fpp_phy_if_block_state_t));
-    p_rtn_phyif->stats.ingress = htonl(p_rtn_phyif->stats.ingress);
-    p_rtn_phyif->stats.egress = htonl(p_rtn_phyif->stats.egress);
-    p_rtn_phyif->stats.malformed = htonl(p_rtn_phyif->stats.malformed);
-    p_rtn_phyif->stats.discarded = htonl(p_rtn_phyif->stats.discarded);
-}
- 
- 
-/*
- * @brief       Set/unset a bitflag in a physical interface struct.
- * @param[out]  p_rtn_phyif  The physical interface struct to be modified.
- * @param[in]   enable       New state of the bitflag.
- * @param[in]   flag         The bitflag.
- */
-static void set_flag(fpp_phy_if_cmd_t* p_rtn_phyif, bool enable, fpp_if_flags_t flag)
-{
-    assert(NULL != p_rtn_phyif);
-    
-    
-    if (enable)
-    {
-        p_rtn_phyif->flags |= flag;
-    }
-    else
-    {
-        p_rtn_phyif->flags &= (fpp_if_flags_t)(~flag);
-    }
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested physical interface
- *              from the PFE. Identify the interface by its name.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_phy_if_get_by_name_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_phyif  Space for data from the PFE.
- * @param[in]   p_name       Name of the requested physical interface.
- *                           Names of physical interfaces are hardcoded.
- *                           See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Requested physical interface was found.
- *                           A copy of its configuration was stored into p_rtn_phyif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_phy_if_get_by_name(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif,
-                           const char* p_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_phyif);
-    assert(NULL != p_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_phy_if_cmd_t cmd_to_fci = {0};
-    fpp_phy_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_phyif(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) && (strcmp(p_name, reply_from_fci.name)))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_phyif(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_phyif = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested physical interface
- *              from the PFE. Identify the interface by its name.
- * @details     This is a standalone (_sa) function.
- *              It shows how to properly access a physical interface. Namely:
- *              1. Lock the interface database for exclusive access by this FCI client.
- *              2. Execute one or more FCI calls which access 
- *                 physical or logical interfaces.
- *              3. Unlock the interface database's exclusive access lock.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_phyif  Space for data from the PFE.
- * @param[in]   p_name       Name of the requested physical interface.
- *                           Names of physical interfaces are hardcoded.
- *                           See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Requested physical interface was found.
- *                           A copy of its configuration was stored into p_rtn_phyif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-inline int fci_phy_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif,
-                                     const char* p_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_phyif);
-    assert(NULL != p_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* lock the interface database for exclusive access by this FCI client */
-    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
-    
-    /* execute "payload" - FCI calls which access physical or logical interfaces */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_phy_if_get_by_name(p_cl, p_rtn_phyif, p_name);
-    }
-    
-    /* unlock the interface database's exclusive access lock */
-    /* result of the unlock action is returned only if previous "payload" actions were OK */
-    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
-    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));  
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested physical interface
- *              from the PFE. Identify the interface by its ID.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_phy_if_get_by_name_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_phyif  Space for data from the PFE.
- * @param[in]   p_id         ID of the requested physical interface.
- *                           IDs of physical interfaces are hardcoded.
- *                           See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Requested physical interface was found. 
- *                           A copy of its configuration was stored into p_rtn_phyif.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_phy_if_get_by_id(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, uint32_t id)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_phyif);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_phy_if_cmd_t cmd_to_fci = {0};
-    fpp_phy_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_phyif(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) && (id != (reply_from_fci.id)))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_phyif(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_phyif = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target physical interface 
- *                 in the PFE.
- * @details        To use this function properly, the PFE interface database must be
- *                 locked for exclusive access. See fci_phy_if_update_sa() for 
- *                 an example how to lock the database.
- * @param[in]      p_cl     FCI client instance
- * @param[in,out]  p_phyif  Data struct which represents a new configuration of
- *                          the target physical interface.
- *                          Initial data can be obtained via fci_phy_if_get_by_name() or
- *                          fci_phy_if_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the target physical interface was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_phy_if_update(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_phyif);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_phy_if_cmd_t cmd_to_fci = (*p_phyif);
-    
-    /* send data */
-    hton_phyif(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_PHY_IF, sizeof(fpp_phy_if_cmd_t), 
-                                         (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_phy_if_get_by_id(p_cl, p_phyif, (p_phyif->id));
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target physical interface 
- *                 in the PFE.
- * @details        This is a standalone (_sa) function.
- *                 It shows how to properly access a physical interface. Namely:
- *                 1. Lock the interface database for exclusive access by this FCI client.
- *                 2. Execute one or more FCI calls which access 
- *                    physical or logical interfaces.
- *                 3. Unlock the interface database's exclusive access lock.
- * @param[in]      p_cl     FCI client instance
- * @param[in,out]  p_phyif  Data struct which represents a new configuration of
- *                          the target physical interface.
- *                          Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                          fci_phy_if_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the target physical interface was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-inline int fci_phy_if_update_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_phyif);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* lock the interface database for exclusive access by this FCI client */
-    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
-    
-    /* execute "payload" - FCI calls which access physical or logical interfaces */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_phy_if_update(p_cl, p_phyif);
-    }
-    
-    /* unlock the interface database's exclusive access lock */
-    /* result of the unlock action is returned only if previous "payload" actions were OK */
-    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
-    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-/*
- * @defgroup    localdata_phyif  [localdata_phyif]
- * @brief:      Functions marked as [localdata_phyif] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_phy_if_update() or fci_phy_if_update_sa() to
- *              update configuration of the real physical interface in the PFE.
- */
- 
- 
-/*
- * @brief          Enable ("up") a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif  Local data to be modified.
- *                          Initial data can be obtained via fci_phy_if_get_by_name() or
- *                          fci_phy_if_get_by_id().
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_enable(fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    p_phyif->flags |= FPP_IF_ENABLED;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Disable ("down") a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif  Local data to be modified.
- *                          Initial data can be obtained via fci_phy_if_get_by_name() or
- *                          fci_phy_if_get_by_id().
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_disable(fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    p_phyif->flags &= (fpp_if_flags_t)(~FPP_IF_ENABLED);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset promiscuous mode of a physical interface.
- * @details        [localdata_phyif]
- *                 Promiscuous mode of a physical interface means the interface
- *                 will accept and process all incoming traffic, regardless of
- *                 the traffic's destination MAC.
- * @param[in,out]  p_phyif  Local data to be modified.
- *                          Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                          fci_phy_if_get_by_id().
- * @param[in]      promisc  A request to set/unset the promiscuous mode.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_promisc(fpp_phy_if_cmd_t* p_phyif, bool promisc)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, promisc, FPP_IF_PROMISC);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset this physical interface as a part of a loadbalancing bucket.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif      Local data to be modified.
- *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                              fci_phy_if_get_by_id().
- * @param[in]      loadbalance  A request to add/remove this interface to/from
- *                              a loadbalancing bucket.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_loadbalance(fpp_phy_if_cmd_t* p_phyif, bool loadbalance)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, loadbalance, FPP_IF_LOADBALANCE);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset VLAN conformance check in a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif    Local data to be modified.
- *                            Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                            fci_phy_if_get_by_id().
- * @param[in]      vlan_conf  A request to set/unset the VLAN conformance check.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_vlan_conf(fpp_phy_if_cmd_t* p_phyif, bool vlan_conf)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, vlan_conf, FPP_IF_VLAN_CONF_CHECK);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset PTP conformance check in a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif   Local data to be modified.
- *                           Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                           fci_phy_if_get_by_id().
- * @param[in]      ptp_conf  A request to set/unset the PTP conformance check.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_ptp_conf(fpp_phy_if_cmd_t* p_phyif, bool ptp_conf)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, ptp_conf, FPP_IF_PTP_CONF_CHECK);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset PTP promiscuous mode in a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif      Local data to be modified.
- *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                              fci_phy_if_get_by_id().
- * @param[in]      ptp_promisc  A request to set/unset the PTP promiscuous mode.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_ptp_promisc(fpp_phy_if_cmd_t* p_phyif, bool ptp_promisc)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, ptp_promisc, FPP_IF_PTP_PROMISC);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset Q-in-Q mode in a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif      Local data to be modified.
- *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                              fci_phy_if_get_by_id().
- * @param[in]      qinq         A request to set/unset the Q-in-Q mode.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_qinq(fpp_phy_if_cmd_t* p_phyif, bool qinq)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, qinq, FPP_IF_ALLOW_Q_IN_Q);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set/unset discarding of packets which have TTL<2.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif      Local data to be modified.
- *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                              fci_phy_if_get_by_id().
- * @param[in]      discard_ttl  A request to set/unset the Q-in-Q mode.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_discard_ttl(fpp_phy_if_cmd_t* p_phyif, bool discard_ttl)
-{
-    assert(NULL != p_phyif);
-    set_flag(p_phyif, discard_ttl, FPP_IF_DISCARD_TTL);
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set operation mode of a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif  Local data to be modified.
- *                          Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                          fci_phy_if_get_by_id().
- * @param[in]      mode     New operation mode
- *                          For details about physical interface operation modes, see
- *                          the description of a fpp_phy_if_op_mode_t type in
- *                          the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_mode(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_op_mode_t mode)
-{
-    assert(NULL != p_phyif);
-    p_phyif->mode = mode;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set blocking state of a physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif      Local data to be modified.
- *                              Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                              fci_phy_if_get_by_id().
- * @param[in]      block_state  New blocking state
- *                              For details about physical interface blocking states, see
- *                              description of a fpp_phy_if_block_state_t type in
- *                              the FCI API Reference.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_block_state(fpp_phy_if_cmd_t* p_phyif,
-                                  fpp_phy_if_block_state_t block_state)
-{
-    assert(NULL != p_phyif);
-    p_phyif->block_state = block_state;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set traffic mirroring from this physical interface to 
- *                 another physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif        Local data to be modified.
- *                                Initial data can be obtained via fci_phy_if_get_by_name() or
- *                                fci_phy_if_get_by_id().
- * @param[in]      p_mirror_name  Name of a physical interface which shall be receiving
- *                                a copy of traffic.
- *                                Names of physical interfaces are hardcoded.
- *                                See the FCI API Reference, chapter Interface Management.
- *                                Can be NULL. If NULL or "" (empty string), then
- *                                traffic mirorring is disabled.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_mirror(fpp_phy_if_cmd_t* p_phyif, const char* p_mirror_name)
-{
-    assert(NULL != p_phyif);
-    /* 'p_mirror_name' is allowed to be NULL */
-    
-    
-    int rtn = FPP_ERR_FCI;
-    rtn = set_text(p_phyif->mirror, p_mirror_name, IFNAMSIZ);
-    if (FPP_ERR_OK == rtn)
-    {
-        const bool enable_mirroring = ((NULL != p_mirror_name) && ('\0' != p_mirror_name[0]));
-        set_flag(p_phyif, enable_mirroring, FPP_IF_MIRROR);
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Set FlexibleParser table to act as a FlexibleFilter for 
- *                 this physical interface.
- * @details        [localdata_phyif]
- * @param[in,out]  p_phyif        Local data to be modified.
- *                                Initial data can be obtained via fci_phy_if_get_by_name() or
- *                                fci_phy_if_get_by_id().
- * @param[in]      p_table_name   Name of a FlexibleParser table.
- *                                Can be NULL. If NULL or "" (empty string), then
- *                                FlexibleFilter of this physical interface is disabled.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_phy_if_ld_set_flexifilter(fpp_phy_if_cmd_t* p_phyif, const char* p_table_name)
-{
-    assert(NULL != p_phyif);
-    /* 'p_table_name' is allowed to be NULL */
-    
-    int rtn = FPP_ERR_FCI;
-    rtn = set_text(p_phyif->ftable, p_table_name, IFNAMSIZ);
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
- 
- 
-/*
- * @brief      Query status of an "enable" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or 
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was enabled ("up")
- *             false : was disabled ("down")
- */
-bool fci_phy_if_ld_is_enabled(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_ENABLED & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of an "enable" flag (inverted logic).
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was disabled ("down")
- *             false : was enabled ("up")
- */
-bool fci_phy_if_ld_is_disabled(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return !fci_phy_if_ld_is_enabled(p_phyif);
-}
- 
- 
-/*
- * @brief      Query status of a "promiscuous mode" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was in a promiscuous mode
- *             false : was NOT in a promiscuous mode
- */
-bool fci_phy_if_ld_is_promisc(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_PROMISC & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "loadbalance" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was a part of a loadbalance bucket
- *             false : was NOT a part of a loadbalance bucket
- */
-bool fci_phy_if_ld_is_loadbalance(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_LOADBALANCE & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "VLAN conformance check" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was checking VLAN conformance
- *             false : was NOT checking VLAN conformance
- */
-bool fci_phy_if_ld_is_vlan_conf(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_VLAN_CONF_CHECK & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "PTP conformance check" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was checking PTP conformance
- *             false : was NOT checking PTP conformance
- */
-bool fci_phy_if_ld_is_ptp_conf(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_PTP_CONF_CHECK & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "PTP promisc" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was using PTP promiscuous mode
- *             false : was NOT using PTP promiscuous mode
- */
-bool fci_phy_if_ld_is_ptp_promisc(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_PTP_PROMISC & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "Q-in-Q" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was using Q-in-Q feature
- *             false : was NOT using Q-in-Q feature
- */
-bool fci_phy_if_ld_is_qinq(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_ALLOW_Q_IN_Q & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "Q-in-Q" flag.
- * @details    [localdata_phyif]
- *             This feature applies only if the physical interface is in a mode
- *             which decrements TTL of packets (e.g. L3 Router).
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : was discarding packets which have TTL<2 (only for some modes)
- *             false : was sending packets which have TTL<2 to a host (only for some modes)
- */
-bool fci_phy_if_ld_is_discard_ttl(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_DISCARD_TTL & (p_phyif->flags));
-}
- 
- 
-/*
- * @brief      Query status of a "mirror" flag.
- * @details    [localdata_phyif]
- * @param[in]  p_phyif  Local data to be queried.
- *                      Initial data can be obtained via fci_phy_if_get_by_name() or
- *                      fci_phy_if_get_by_id().
- * @return     At time when the data was obtained, the physical interface:
- *             true  : had the mirroring feature enabled
- *             false : had the mirroring feature disabled
- */
-bool fci_phy_if_ld_is_mirror(const fpp_phy_if_cmd_t* p_phyif)
-{
-    assert(NULL != p_phyif);
-    return (bool)(FPP_IF_MIRROR & (p_phyif->flags));
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all physical interfaces in the PFE and
- *             execute a callback print function for each reported physical interface.
- * @details    To use this function properly, the PFE interface database must be
- *             locked for exclusive access. See fci_phy_if_print_all_sa() for 
- *             an example how to lock the database.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next physical interface is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all physical interfaces.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_phy_if_print_all(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_phy_if_cmd_t cmd_to_fci = {0};
-    fpp_phy_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                    sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_phyif(&reply_from_fci);  /* set correct byte order */
-        
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        rtn = p_cb_print(&reply_from_fci);
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                            sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_phyif(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more physical interfaces to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all physical interfaces in the PFE and
- *             execute a callback print function for each reported physical interface.
- * @details    This is a standalone (_sa) function.
- *             It shows how to properly access a physical interface. Namely:
- *             1. Lock the interface database for exclusive access by this FCI client.
- *             2. Execute one or more FCI calls which access 
- *                physical or logical interfaces.
- *             3. Unlock the interface database's exclusive access lock.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next physical interface is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all physical interfaces.
- *             other      : Some error occured (represented by the respective error code).
- */
-inline int fci_phy_if_print_all_sa(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* lock the interface database for exclusive access by this FCI client */
-    rtn = fci_write(p_cl, FPP_CMD_IF_LOCK_SESSION, 0, NULL);
-    
-    /* execute "payload" - FCI calls which access physical or logical interfaces */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_phy_if_print_all(p_cl, p_cb_print);
-    }
-    
-    /* unlock the interface database's exclusive access lock */
-    /* result of the unlock action is returned only if previous "payload" actions were OK */
-    const int rtn_unlock = fci_write(p_cl, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL);
-    rtn = ((FPP_ERR_OK == rtn) ? (rtn_unlock) : (rtn));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all physical interfaces in the PFE.
- * @details     To use this function properly, the PFE interface database must be
- *              locked for exclusive access. See fci_phy_if_print_all_sa() for 
- *              an example how to lock the database.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of physical interfaces.
- * @return      FPP_ERR_OK : Successfully counted physical interfaces.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_phy_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_phy_if_cmd_t cmd_to_fci = {0};
-    fpp_phy_if_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint16_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                    sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting interfaces) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_PHY_IF,
-                        sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting interfaces) */
-    }
-    
-    /* query loop runs till there are no more physical interfaces to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_IF_ENTRY_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ========================================================================= */
- 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_phy_if.h b/sw/libfci_cli/src/libfci_interface/fci_phy_if.h
deleted file mode 100644
index ffdf4f4..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_phy_if.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
-
-#ifndef FCI_PHY_IF_H_
-#define FCI_PHY_IF_H_
-
-#include "fpp_ext.h"
-#include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-/* hardcoded PHY_IF names, IDs and bitflags (IDs 3 & 4 are reserved) */
-#define FCI_PHY_IF_EMAC0_ID  (0u)
-#define FCI_PHY_IF_EMAC1_ID  (1u)
-#define FCI_PHY_IF_EMAC2_ID  (2u)
-#define FCI_PHY_IF_UTIL_ID   (5u)
-#define FCI_PHY_IF_HIF0_ID   (6u)
-#define FCI_PHY_IF_HIF1_ID   (7u)
-#define FCI_PHY_IF_HIF2_ID   (8u)
-#define FCI_PHY_IF_HIF3_ID   (9u)
-
-#define FCI_PHY_IF_EMAC0_BITFLAG  (1uL << FCI_PHY_IF_EMAC0_ID)
-#define FCI_PHY_IF_EMAC1_BITFLAG  (1uL << FCI_PHY_IF_EMAC1_ID)
-#define FCI_PHY_IF_EMAC2_BITFLAG  (1uL << FCI_PHY_IF_EMAC2_ID)
-#define FCI_PHY_IF_UTIL_BITFLAG   (1uL << FCI_PHY_IF_UTIL_ID)
-#define FCI_PHY_IF_HIF0_BITFLAG   (1uL << FCI_PHY_IF_HIF0_ID)
-#define FCI_PHY_IF_HIF1_BITFLAG   (1uL << FCI_PHY_IF_HIF1_ID)
-#define FCI_PHY_IF_HIF2_BITFLAG   (1uL << FCI_PHY_IF_HIF2_ID)
-#define FCI_PHY_IF_HIF3_BITFLAG   (1uL << FCI_PHY_IF_HIF3_ID)
-
-typedef int (*fci_phy_if_cb_print_t)(const fpp_phy_if_cmd_t* p_phyif);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
-
-int fci_phy_if_get_by_name(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, const char* p_name);
-int fci_phy_if_get_by_name_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, const char* p_name);
-int fci_phy_if_get_by_id(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_rtn_phyif, uint32_t id);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
-
-int fci_phy_if_update(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif);
-int fci_phy_if_update_sa(FCI_CLIENT* p_cl, fpp_phy_if_cmd_t* p_phyif);
-
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-
-int fci_phy_if_ld_enable(fpp_phy_if_cmd_t* p_phyif);
-int fci_phy_if_ld_disable(fpp_phy_if_cmd_t* p_phyif);
-int fci_phy_if_ld_set_promisc(fpp_phy_if_cmd_t* p_phyif, bool promisc);
-int fci_phy_if_ld_set_loadbalance(fpp_phy_if_cmd_t* p_phyif, bool loadbalance);
-int fci_phy_if_ld_set_vlan_conf(fpp_phy_if_cmd_t* p_phyif, bool vlan_conf);
-int fci_phy_if_ld_set_ptp_conf(fpp_phy_if_cmd_t* p_phyif, bool ptp_conf);
-int fci_phy_if_ld_set_ptp_promisc(fpp_phy_if_cmd_t* p_phyif, bool ptp_promisc);
-int fci_phy_if_ld_set_qinq(fpp_phy_if_cmd_t* p_phyif, bool qinq);
-int fci_phy_if_ld_set_discard_ttl(fpp_phy_if_cmd_t* p_phyif, bool discard_ttl);
-int fci_phy_if_ld_set_mode(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_op_mode_t mode);
-int fci_phy_if_ld_set_block_state(fpp_phy_if_cmd_t* p_phyif, fpp_phy_if_block_state_t block_state);
-int fci_phy_if_ld_set_mirror(fpp_phy_if_cmd_t* p_phyif, const char* p_mirror_name);
-int fci_phy_if_ld_set_flexifilter(fpp_phy_if_cmd_t* p_phyif, const char* p_table_name);
-
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
-
-bool fci_phy_if_ld_is_enabled(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_disabled(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_promisc(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_loadbalance(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_vlan_conf(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_ptp_conf(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_ptp_promisc(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_qinq(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_discard_ttl(const fpp_phy_if_cmd_t* p_phyif);
-bool fci_phy_if_ld_is_mirror(const fpp_phy_if_cmd_t* p_phyif);
-
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
-
-int fci_phy_if_print_all(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print);
-int fci_phy_if_print_all_sa(FCI_CLIENT* p_cl, fci_phy_if_cb_print_t p_cb_print);
-int fci_phy_if_get_count(FCI_CLIENT* p_cl, uint16_t* p_rtn_count);
-
-/* ========================================================================= */
-
-#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_qos.c b/sw/libfci_cli/src/libfci_interface/fci_qos.c
deleted file mode 100644
index c2c39de..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_qos.c
+++ /dev/null
@@ -1,1134 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
- 
- 
-#include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include "fpp.h"
-#include "fpp_ext.h"
-#include "libfci.h"
-#include "fci_common.h"
-#include "fci_qos.h"
- 
- 
-/* ==== PRIVATE FUNCTIONS ================================================== */
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a queue struct.
- * @param[in,out]  p_rtn_que  The queue struct to be converted.
- */
-static void ntoh_que(fpp_qos_queue_cmd_t* p_rtn_que)
-{
-    assert(NULL != p_rtn_que);
-    
-    
-    p_rtn_que->min = ntohl(p_rtn_que->min);
-    p_rtn_que->max = ntohl(p_rtn_que->max);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a queue struct.
- * @param[in,out]  p_rtn_que  The queue struct to be converted.
- */
-static void hton_que(fpp_qos_queue_cmd_t* p_rtn_que)
-{
-    assert(NULL != p_rtn_que);
-    
-    
-    p_rtn_que->min = htonl(p_rtn_que->min);
-    p_rtn_que->max = htonl(p_rtn_que->max);
-}
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a scheduler struct.
- * @param[in,out]  p_rtn_sch  The scheduler struct to be converted.
- */
-static void ntoh_sch(fpp_qos_scheduler_cmd_t* p_rtn_sch)
-{
-    assert(NULL != p_rtn_sch);
-    
-    
-    p_rtn_sch->input_en = ntohl(p_rtn_sch->input_en);
-    for (uint8_t i = 0u; (32u > i); (++i))
-    {
-        p_rtn_sch->input_w[i] = ntohl(p_rtn_sch->input_w[i]);
-    }
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a scheduler struct.
- * @param[in,out]  p_rtn_sch  The scheduler struct to be converted.
- */
-static void hton_sch(fpp_qos_scheduler_cmd_t* p_rtn_sch)
-{
-    assert(NULL != p_rtn_sch);
-    
-    
-    p_rtn_sch->input_en = htonl(p_rtn_sch->input_en);
-    for (uint8_t i = 0u; (32u > i); (++i))
-    {
-        p_rtn_sch->input_w[i] = htonl(p_rtn_sch->input_w[i]);
-    }
-}
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a shaper struct.
- * @param[in,out]  p_rtn_shp  The shaper struct to be converted.
- */
-static void ntoh_shp(fpp_qos_shaper_cmd_t* p_rtn_shp)
-{
-    assert(NULL != p_rtn_shp);
-    
-    
-    p_rtn_shp->isl = ntohl(p_rtn_shp->isl);
-    p_rtn_shp->max_credit = (int32_t)(ntohl(p_rtn_shp->max_credit));
-    p_rtn_shp->min_credit = (int32_t)(ntohl(p_rtn_shp->min_credit));
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a shaper struct.
- * @param[in,out]  p_rtn_shp  The shaper struct to be converted.
- */
-static void hton_shp(fpp_qos_shaper_cmd_t* p_rtn_shp)
-{
-    assert(NULL != p_rtn_shp);
-    
-    
-    p_rtn_shp->isl = htonl(p_rtn_shp->isl);
-    p_rtn_shp->max_credit = (int32_t)(htonl(p_rtn_shp->max_credit));
-    p_rtn_shp->min_credit = (int32_t)(htonl(p_rtn_shp->min_credit));
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested QoS queue
- *              from the PFE. Identify the QoS queue by name of the parent 
- *              physical interface and by the queue's ID.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_que     Space for data from the PFE.
- * @param[in]   p_phyif_name  Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- *              que_id        ID of the requested QoS queue.
- * @return      FPP_ERR_OK : Requested QoS queue was found.
- *                           A copy of its configuration was stored into p_rtn_que.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_qos_que_get_by_id(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_rtn_que, 
-                          const char* p_phyif_name, uint8_t que_id)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_que);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_queue_cmd_t cmd_to_fci = {0};
-    fpp_qos_queue_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    cmd_to_fci.id = que_id;
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* start query process */
-        cmd_to_fci.action = FPP_ACTION_QUERY;
-        rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
-                        sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_que(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_que = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested QoS scheduler
- *              from the PFE. Identify the QoS scheduler by name of the parent 
- *              physical interface and by the scheduler's ID.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_que     Space for data from the PFE.
- * @param[in]   p_phyif_name  Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- *              sch_id        ID of the requested QoS scheduler.
- * @return      FPP_ERR_OK : Requested QoS scheduler was found.
- *                           A copy of its configuration was stored into p_rtn_sch.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_qos_sch_get_by_id(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_rtn_sch, 
-                          const char* p_phyif_name, uint8_t sch_id)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_sch);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
-    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    cmd_to_fci.id = sch_id;
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* start query process */
-        cmd_to_fci.action = FPP_ACTION_QUERY;
-        rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
-                        sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_sch(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_sch = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested QoS shaper
- *              from the PFE. Identify the QoS shaper by name of the parent 
- *              physical interface and by the shaper's ID.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_que     Space for data from the PFE.
- * @param[in]   p_phyif_name  Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- *              shp_id        ID of the requested QoS shaper.
- * @return      FPP_ERR_OK : Requested QoS shaper was found.
- *                           A copy of its configuration was stored into p_rtn_shp.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_qos_shp_get_by_id(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_rtn_shp, 
-                          const char* p_phyif_name, uint8_t shp_id)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_shp);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
-    fpp_qos_shaper_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    cmd_to_fci.id = shp_id;
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* start query process */
-        cmd_to_fci.action = FPP_ACTION_QUERY;
-        rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
-                        sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_shp(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_shp = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target QoS queue
- *                 in the PFE.
- * @param[in]      p_cl   FCI client instance
- * @param[in,out]  p_que  Data struct which represents a new configuration of 
- *                        the target QoS queue.
- *                        Initial data can be obtained via fci_qos_que_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the QoS queue was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_qos_que_update(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_que)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_que);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_qos_queue_cmd_t cmd_to_fci = (*p_que);
-    
-    /* send data */
-    hton_que(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_QOS_QUEUE, sizeof(fpp_qos_queue_cmd_t), 
-                                        (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_qos_que_get_by_id(p_cl, p_que, (p_que->if_name), (p_que->id));
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target QoS scheduler
- *                 in the PFE.
- * @param[in]      p_cl   FCI client instance
- * @param[in,out]  p_que  Data struct which represents a new configuration of 
- *                        the target QoS scheduler.
- *                        Initial data can be obtained via fci_qos_sch_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the QoS scheduler was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_qos_sch_update(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_sch)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_sch);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_qos_scheduler_cmd_t cmd_to_fci = (*p_sch);
-    
-    /* send data */
-    hton_sch(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_QOS_SCHEDULER, sizeof(fpp_qos_scheduler_cmd_t), 
-                                                (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_qos_sch_get_by_id(p_cl, p_sch, (p_sch->if_name), (p_sch->id));
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief          Use FCI calls to update configuration of a target QoS shaper
- *                 in the PFE.
- * @param[in]      p_cl   FCI client instance
- * @param[in,out]  p_que  Data struct which represents a new configuration of 
- *                        the target QoS shaper.
- *                        Initial data can be obtained via fci_qos_shp_get_by_id().
- * @return         FPP_ERR_OK : Configuration of the QoS shaper was
- *                              successfully updated in the PFE.
- *                              Local data struct was automatically updated with 
- *                              readback data from the PFE.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data struct not updated.
- */
-int fci_qos_shp_update(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_shp)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_shp);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_qos_shaper_cmd_t cmd_to_fci = (*p_shp);
-    
-    /* send data */
-    hton_shp(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_QOS_SHAPER, sizeof(fpp_qos_shaper_cmd_t), 
-                                             (unsigned short*)(&cmd_to_fci));
-    
-    /* read back and update caller data */
-    if (FPP_ERR_OK == rtn)
-    {
-        rtn = fci_qos_shp_get_by_id(p_cl, p_shp, (p_shp->if_name), (p_shp->id));
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-/*
- * @defgroup    localdata_que  [localdata_que]
- * @brief:      Functions marked as [localdata_que] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_qos_que_update() to 
- *              update the given QoS queue in the PFE.
- */
- 
- 
-/*
- * @brief          Set mode (queue discipline) of a QoS queue.
- * @details        [localdata_que]
- * @param[in,out]  p_que     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_que_get_by_id().
- * @param[in]      que_mode  queue mode (queue discipline)
- *                           For valid modes, see the FCI API Reference, 
- *                           chapter 'queue mode'.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_que_ld_set_mode(fpp_qos_queue_cmd_t* p_que, uint8_t que_mode)
-{
-    assert(NULL != p_que);
-    p_que->mode = que_mode;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set minimal threshold of a QoS queue.
- * @details        [localdata_que]
- *                 Meaning of minimal threshold depends on que mode.
- * @param[in,out]  p_que  Local data to be modified.
- *                        Initial data can be obtained via fci_qos_que_get_by_id().
- * @param[in]      min    minimal threshold
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_que_ld_set_min(fpp_qos_queue_cmd_t* p_que, uint32_t min)
-{
-    assert(NULL != p_que);
-    p_que->min = min;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set queue mode (queue discipline) of a QoS queue.
- * @details        [localdata_que]
- *                 Meaning of maximal threshold depends on que mode.
- * @param[in,out]  p_que  Local data to be modified.
- *                        Initial data can be obtained via fci_qos_que_get_by_id().
- * @param[in]      max    maximal threshold
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_que_ld_set_max(fpp_qos_queue_cmd_t* p_que, uint32_t max)
-{
-    assert(NULL != p_que);
-    p_que->max = max;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set packet drop probability of a particular QoS queue's zone.
- * @details        [localdata_que]
- *                 Meaningful only for que mode WRED.
- * @param[in,out]  p_que  Local data to be modified.
- *                        Initial data can be obtained via fci_qos_que_get_by_id().
- * @param[in]      zprob_id    id of a probability zone
- *                             There may be less than 32 zones actually implemented in PFE.
- *                             (32 is just the max array limit)
- *                             See the FCI API Reference, chapter Egress QoS.
- * @param[in]      percentage  drop probability in [%]
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_que_ld_set_zprob(fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id, 
-                             uint8_t percentage)
-{
-    assert(NULL != p_que);
-    int rtn = FPP_ERR_FCI;
-    if (32u > zprob_id)
-    {
-        p_que->zprob[zprob_id] = percentage;
-        rtn = FPP_ERR_OK;
-    }
-    return (rtn);
-}
- 
- 
-/*
- * @defgroup    localdata_sch  [localdata_sch]
- * @brief:      Functions marked as [localdata_sch] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_qos_sch_update() to 
- *              update the given QoS scheduler in the PFE.
- */
- 
- 
-/*
- * @brief          Set mode of a QoS scheduler.
- * @details        [localdata_sch]
- * @param[in,out]  p_sch     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_sch_get_by_id().
- * @param[in]      sch_mode  scheduler mode
- *                           For valid modes, see the FCI API Reference, 
- *                           chapter 'schedulermode'.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_sch_ld_set_mode(fpp_qos_scheduler_cmd_t* p_sch, uint8_t sch_mode)
-{
-    assert(NULL != p_sch);
-    p_sch->mode = sch_mode;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set selection algorithm of a QoS scheduler.
- * @details        [localdata_sch]
- * @param[in,out]  p_sch     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_sch_get_by_id().
- * @param[in]      algo      selection algorithm
- *                           For valid modes, see the FCI API Reference, 
- *                           chapter 'scheduler algorithm'.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_sch_ld_set_algo(fpp_qos_scheduler_cmd_t* p_sch, uint8_t algo)
-{
-    assert(NULL != p_sch);
-    p_sch->algo = algo;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set input of a QoS scheduler.
- * @details        [localdata_sch]
- * @param[in,out]  p_sch     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_sch_get_by_id().
- * @param[in]      input_id  ID of the scheduler's input.
- *                           There may be less than 32 inputs per scheduler 
- *                           actually implemented in PFE. (32 is just the max array limit)
- *                           See the FCI API Reference, chapter Egress QoS.
- *                 enable    A request to enable/disable the given scheduler input.
- *                 src       Data source which is connected to the given sscheduler input.
- *                           See the FCI API Reference, chapter Egress QoS.
- *                 weight    Weight ("importance") of the given scheduler input.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_sch_ld_set_input(fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id, 
-                             bool enable, uint8_t src, uint32_t weight)
-{
-    assert(NULL != p_sch);
-    
-    int rtn = FPP_ERR_FCI;
-    if (32u > input_id)
-    {
-        if (enable)
-        {
-            p_sch->input_en |= (1uL << input_id);
-        }
-        else
-        {
-            p_sch->input_en &= ~(1uL << input_id);
-        }
-        
-        p_sch->input_src[input_id] = src;
-        p_sch->input_w[input_id] = weight;
-        
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @defgroup    localdata_shp  [localdata_shp]
- * @brief:      Functions marked as [localdata_shp] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_qos_shp_update() to 
- *              update the given QoS shaper in the PFE.
- */
- 
- 
-/*
- * @brief          Set mode of a QoS shaper.
- * @details        [localdata_shp]
- * @param[in,out]  p_shp     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_shp_get_by_id().
- * @param[in]      shp_mode  shaper mode
- *                           For valid modes, see the FCI API Reference, 
- *                           chapter 'shapermode'.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_shp_ld_set_mode(fpp_qos_shaper_cmd_t* p_shp, uint8_t shp_mode)
-{
-    assert(NULL != p_shp);
-    p_shp->mode = shp_mode;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set position of a QoS shaper in a QoS configuration.
- * @details        [localdata_shp]
- * @param[in,out]  p_shp     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_shp_get_by_id().
- * @param[in]      position  position of the QoS shaper
- *                           For valid positions, see the FCI API Reference, 
- *                           chapter Egress QoS.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_shp_ld_set_position(fpp_qos_shaper_cmd_t* p_shp, uint8_t position)
-{
-    assert(NULL != p_shp);
-    p_shp->position = position;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set idle slope rate of a QoS shaper.
- * @details        [localdata_shp]
- * @param[in,out]  p_shp     Local data to be modified.
- *                           Initial data can be obtained via fci_qos_shp_get_by_id().
- * @param[in]      isl       idle slope rate (units per second)
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_shp_ld_set_isl(fpp_qos_shaper_cmd_t* p_shp, uint32_t isl)
-{
-    assert(NULL != p_shp);
-    p_shp->isl = isl;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set minimal credit of a QoS shaper.
- * @details        [localdata_shp]
- * @param[in,out]  p_shp       Local data to be modified.
- *                             Initial data can be obtained via fci_qos_shp_get_by_id().
- * @param[in]      min_credit  minimal credit
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_shp_ld_set_min_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t min_credit)
-{
-    assert(NULL != p_shp);
-    p_shp->min_credit = min_credit;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set maximal credit of a QoS shaper.
- * @details        [localdata_shp]
- * @param[in,out]  p_shp       Local data to be modified.
- *                             Initial data can be obtained via fci_qos_shp_get_by_id().
- * @param[in]      min_credit  maximal credit
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_qos_shp_ld_set_max_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t max_credit)
-{
-    assert(NULL != p_shp);
-    p_shp->max_credit = max_credit;
-    return (FPP_ERR_OK);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
- 
- 
-/*
- * @brief      Query whether an input of a QoS scheduler is enabled or not.
- * @details    [localdata_sch]
- * @param[in]  p_sch  Local data to be queried.
- *                    Initial data can be obtained via fci_qos_sch_get_by_id().
- * @param[in]  input_id  Queried scheduler input.
- * @return     At time when the data was obtained, the given scheduler input:
- *             true  : was enabled
- *             false : was disabled
- */
-bool fci_qos_sch_ld_is_input_enabled(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id)
-{
-    assert(NULL != p_sch);
-    return (bool)((32u > input_id) ? ((1uL << input_id) & (p_sch->input_en)) : (false));
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
- 
- 
-/*
- * @brief      Use FCI calls to iterate through QoS queues of the given physical
- *             interface and execute a callback print function for each QoS queue.
- * @param[in]  p_cl           FCI client instance
- * @param[in]  p_cb_print     Callback print function.
- *                            --> If the callback returns zero, then all is OK and 
- *                                the next QoS queue is picked for a print process.
- *                            --> If the callback returns non-zero, then some problem is 
- *                                assumed and this function terminates prematurely.
- * @param[in]  p_phyif_name   Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return     FPP_ERR_OK : Successfully iterated through QoS queues of 
- *                          the given physical interface.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_qos_que_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_que_cb_print_t p_cb_print, 
-                               const char* p_phyif_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_queue_cmd_t cmd_to_fci = {0};
-    fpp_qos_queue_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* query loop */
-        uint8_t que_id = 0u;
-        while (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.id = que_id;
-            cmd_to_fci.action = FPP_ACTION_QUERY;
-            rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
-                            sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_que(&reply_from_fci);  /* set correct byte order */
-            
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = p_cb_print(&reply_from_fci);
-            }
-            
-            que_id++;
-        }
-        
-        /* query loop runs till there are no more QoS queues to report */
-        /* the following error is therefore OK and expected (it ends the query loop) */
-        if (FPP_ERR_QOS_QUEUE_NOT_FOUND == rtn)
-        {
-            rtn = FPP_ERR_OK;
-        }
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all QoS queues in the PFE which
- *              are a part of a given parent physical interface.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_count   Space to store the count of QoS queues.
- * @param[in]   p_phyif_name  Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Successfully counted QoS queues.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_qos_que_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
-                                   const char* p_phyif_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_queue_cmd_t cmd_to_fci = {0};
-    fpp_qos_queue_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* query loop */
-        uint8_t que_id = 0u;
-        while (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.id = que_id;
-            cmd_to_fci.action = FPP_ACTION_QUERY;
-            rtn = fci_query(p_cl, FPP_CMD_QOS_QUEUE,
-                            sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            /* no need to set correct byte order (we are just counting QoS queues) */
-            
-            if (FPP_ERR_OK == rtn)
-            {
-                que_id++;
-            }
-        }
-        
-        /* query loop runs till there are no more QoS queues to report */
-        /* the following error is therefore OK and expected (it ends the query loop) */
-        if (FPP_ERR_QOS_QUEUE_NOT_FOUND == rtn)
-        {
-            *p_rtn_count = que_id;
-            rtn = FPP_ERR_OK;
-        }
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through QoS schedulers of the given physical
- *             interface and execute a callback print function for each QoS scheduler.
- * @param[in]  p_cl           FCI client instance
- * @param[in]  p_cb_print     Callback print function.
- *                            --> If the callback returns zero, then all is OK and 
- *                                the next QoS scheduler is picked for a print process.
- *                            --> If the callback returns non-zero, then some problem is 
- *                                assumed and this function terminates prematurely.
- * @param[in]  p_phyif_name   Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return     FPP_ERR_OK : Successfully iterated through QoS schedulers of 
- *                          the given physical interface.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_qos_sch_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_sch_cb_print_t p_cb_print, 
-                               const char* p_phyif_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
-    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* query loop */
-        uint8_t sch_id = 0u;
-        while (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.id = sch_id;
-            cmd_to_fci.action = FPP_ACTION_QUERY;
-            rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
-                            sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_sch(&reply_from_fci);  /* set correct byte order */
-            
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = p_cb_print(&reply_from_fci);
-            }
-            
-            sch_id++;
-        }
-        
-        /* query loop runs till there are no more QoS schedulers to report */
-        /* the following error is therefore OK and expected (it ends the query loop) */
-        if (FPP_ERR_QOS_SCHEDULER_NOT_FOUND == rtn)
-        {
-            rtn = FPP_ERR_OK;
-        }
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all QoS schedulers in the PFE which
- *              are a part of a given parent physical interface.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_count   Space to store the count of QoS schedulers.
- * @param[in]   p_phyif_name  Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Successfully counted QoS schedulers.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_qos_sch_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
-                                   const char* p_phyif_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_scheduler_cmd_t cmd_to_fci = {0};
-    fpp_qos_scheduler_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* query loop */
-        uint8_t sch_id = 0u;
-        while (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.id = sch_id;
-            cmd_to_fci.action = FPP_ACTION_QUERY;
-            rtn = fci_query(p_cl, FPP_CMD_QOS_SCHEDULER,
-                            sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            /* no need to set correct byte order (we are just counting QoS schedulers) */
-            
-            if (FPP_ERR_OK == rtn)
-            {
-                sch_id++;
-            }
-        }
-        
-        /* query loop runs till there are no more QoS schedulers to report */
-        /* the following error is therefore OK and expected (it ends the query loop) */
-        if (FPP_ERR_QOS_SCHEDULER_NOT_FOUND == rtn)
-        {
-            *p_rtn_count = sch_id;
-            rtn = FPP_ERR_OK;
-        }
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through QoS shapers of the given physical
- *             interface and execute a callback print function for each QoS shaper.
- * @param[in]  p_cl           FCI client instance
- * @param[in]  p_cb_print     Callback print function.
- *                            --> If the callback returns zero, then all is OK and 
- *                                the next QoS shaper is picked for a print process.
- *                            --> If the callback returns non-zero, then some problem is 
- *                                assumed and this function terminates prematurely.
- * @param[in]  p_phyif_name   Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return     FPP_ERR_OK : Successfully iterated through QoS shapers of 
- *                          the given physical interface.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_qos_shp_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_shp_cb_print_t p_cb_print, 
-                               const char* p_phyif_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
-    fpp_qos_shaper_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* query loop */
-        uint8_t shp_id = 0u;
-        while (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.id = shp_id;
-            cmd_to_fci.action = FPP_ACTION_QUERY;
-            rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
-                            sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_shp(&reply_from_fci);  /* set correct byte order */
-            
-            if (FPP_ERR_OK == rtn)
-            {
-                rtn = p_cb_print(&reply_from_fci);
-            }
-            
-            shp_id++;
-        }
-        
-        /* query loop runs till there are no more QoS shapers to report */
-        /* the following error is therefore OK and expected (it ends the query loop) */
-        if (FPP_ERR_QOS_SHAPER_NOT_FOUND == rtn)
-        {
-            rtn = FPP_ERR_OK;
-        }
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all QoS shapers in the PFE which
- *              are a part of a given parent physical interface.
- * @param[in]   p_cl          FCI client instance
- * @param[out]  p_rtn_count   Space to store the count of QoS shapers.
- * @param[in]   p_phyif_name  Name of a parent physical interface.
- *                            Names of physical interfaces are hardcoded.
- *                            See the FCI API Reference, chapter Interface Management.
- * @return      FPP_ERR_OK : Successfully counted QoS shapers.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_qos_shp_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, 
-                                   const char* p_phyif_name)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_phyif_name);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_qos_shaper_cmd_t cmd_to_fci = {0};
-    fpp_qos_shaper_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* prepare data */
-    rtn = set_text((cmd_to_fci.if_name), p_phyif_name, IFNAMSIZ);
-    
-    /* do the query */
-    if (FPP_ERR_OK == rtn)
-    {
-        /* query loop */
-        uint8_t shp_id = 0u;
-        while (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.id = shp_id;
-            cmd_to_fci.action = FPP_ACTION_QUERY;
-            rtn = fci_query(p_cl, FPP_CMD_QOS_SHAPER,
-                            sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            /* no need to set correct byte order (we are just counting QoS queues) */
-            
-            if (FPP_ERR_OK == rtn)
-            {
-                shp_id++;
-            }
-        }
-        
-        /* query loop runs till there are no more QoS shapers to report */
-        /* the following error is therefore OK and expected (it ends the query loop) */
-        if (FPP_ERR_QOS_SHAPER_NOT_FOUND == rtn)
-        {
-            *p_rtn_count = shp_id;
-            rtn = FPP_ERR_OK;
-        }
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ========================================================================= */
- 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_qos.h b/sw/libfci_cli/src/libfci_interface/fci_qos.h
deleted file mode 100644
index 0689434..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_qos.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
-
-#ifndef FCI_SPD_H_
-#define FCI_SPD_H_
-
-#include "fpp_ext.h"
-#include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-typedef int (*fci_qos_que_cb_print_t)(const fpp_qos_queue_cmd_t* p_que);
-typedef int (*fci_qos_sch_cb_print_t)(const fpp_qos_scheduler_cmd_t* p_sch);
-typedef int (*fci_qos_shp_cb_print_t)(const fpp_qos_shaper_cmd_t* p_shp);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
-
-int fci_qos_que_get_by_id(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_rtn_que, const char* p_phyif_name, uint8_t que_id);
-int fci_qos_sch_get_by_id(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_rtn_sch, const char* p_phyif_name, uint8_t sch_id);
-int fci_qos_shp_get_by_id(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_rtn_shp, const char* p_phyif_name, uint8_t shp_id);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
-
-int fci_qos_que_update(FCI_CLIENT* p_cl, fpp_qos_queue_cmd_t* p_que);
-int fci_qos_sch_update(FCI_CLIENT* p_cl, fpp_qos_scheduler_cmd_t* p_sch);
-int fci_qos_shp_update(FCI_CLIENT* p_cl, fpp_qos_shaper_cmd_t* p_shp);
-
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-
-int fci_qos_que_ld_set_mode(fpp_qos_queue_cmd_t* p_que, uint8_t que_mode);
-int fci_qos_que_ld_set_min(fpp_qos_queue_cmd_t* p_que, uint32_t min);
-int fci_qos_que_ld_set_max(fpp_qos_queue_cmd_t* p_que, uint32_t max);
-int fci_qos_que_ld_set_zprob(fpp_qos_queue_cmd_t* p_que, uint8_t zprob_id, uint8_t percentage);
-
-int fci_qos_sch_ld_set_mode(fpp_qos_scheduler_cmd_t* p_sch, uint8_t sch_mode);
-int fci_qos_sch_ld_set_algo(fpp_qos_scheduler_cmd_t* p_sch, uint8_t algo);
-int fci_qos_sch_ld_set_input(fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id, bool enable, uint8_t src, uint32_t weight);
-
-int fci_qos_shp_ld_set_mode(fpp_qos_shaper_cmd_t* p_shp, uint8_t shp_mode);
-int fci_qos_shp_ld_set_position(fpp_qos_shaper_cmd_t* p_shp, uint8_t position);
-int fci_qos_shp_ld_set_isl(fpp_qos_shaper_cmd_t* p_shp, uint32_t isl);
-int fci_qos_shp_ld_set_min_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t min_credit);
-int fci_qos_shp_ld_set_max_credit(fpp_qos_shaper_cmd_t* p_shp, int32_t max_credit);
-
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
-
-bool fci_qos_sch_ld_is_input_enabled(const fpp_qos_scheduler_cmd_t* p_sch, uint8_t input_id);
-
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
-
-int fci_qos_que_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_que_cb_print_t p_cb_print, const char* p_phyif_name);
-int fci_qos_que_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
-
-int fci_qos_sch_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_sch_cb_print_t p_cb_print, const char* p_phyif_name);
-int fci_qos_sch_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
-
-int fci_qos_shp_print_by_phyif(FCI_CLIENT* p_cl, fci_qos_shp_cb_print_t p_cb_print, const char* p_phyif_name);
-int fci_qos_shp_get_count_by_phyif(FCI_CLIENT* p_cl, uint16_t* p_rtn_count, const char* p_parent_name);
-
-/* ========================================================================= */
-
-#endif
diff --git a/sw/libfci_cli/src/libfci_interface/fci_rt_ct.c b/sw/libfci_cli/src/libfci_interface/fci_rt_ct.c
deleted file mode 100644
index eeb195c..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_rt_ct.c
+++ /dev/null
@@ -1,1800 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
- 
- 
-#include <assert.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include "fpp.h"
-#include "fpp_ext.h"
-#include "libfci.h"
-#include "fci_common.h"
-#include "fci_rt_ct.h"
- 
- 
-/* ==== PRIVATE FUNCTIONS ================================================== */
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for a route struct.
- * @param[in,out]  p_rtn_rt  The route struct to be converted.
- */
-static void ntoh_rt(fpp_rt_cmd_t* p_rtn_rt)
-{
-    assert(NULL != p_rtn_rt);
-    
-    
-    p_rtn_rt->id = ntohl(p_rtn_rt->id);
-    p_rtn_rt->flags = ntohl(p_rtn_rt->flags);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for a route struct.
- * @param[in,out]  p_rtn_rt  The route struct to be converted.
- */
-static void hton_rt(fpp_rt_cmd_t* p_rtn_rt)
-{
-    assert(NULL != p_rtn_rt);
-    
-    
-    p_rtn_rt->id = htonl(p_rtn_rt->id);
-    p_rtn_rt->flags = htonl(p_rtn_rt->flags);
-}
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for an IPv4 conntrack struct.
- * @param[in,out]  p_rtn_ct  The IPv4 conntrack struct to be converted.
- */
-static void ntoh_ct(fpp_ct_cmd_t* p_rtn_ct)
-{
-    assert(NULL != p_rtn_ct);
-    
-    
-    p_rtn_ct->saddr = ntohl(p_rtn_ct->saddr);
-    p_rtn_ct->daddr = ntohl(p_rtn_ct->daddr);
-    p_rtn_ct->sport = ntohs(p_rtn_ct->sport);
-    p_rtn_ct->dport = ntohs(p_rtn_ct->dport);
-    p_rtn_ct->saddr_reply = ntohl(p_rtn_ct->saddr_reply);
-    p_rtn_ct->daddr_reply = ntohl(p_rtn_ct->daddr_reply);
-    p_rtn_ct->sport_reply = ntohs(p_rtn_ct->sport_reply);
-    p_rtn_ct->dport_reply = ntohs(p_rtn_ct->dport_reply);
-    p_rtn_ct->protocol = ntohs(p_rtn_ct->protocol);
-    p_rtn_ct->flags = ntohs(p_rtn_ct->flags);
-    p_rtn_ct->route_id = ntohl(p_rtn_ct->route_id);
-    p_rtn_ct->route_id_reply = ntohl(p_rtn_ct->route_id_reply);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for the IPv4 conntrack struct.
- * @param[in,out]  p_rtn_ct  The IPv4 conntrack struct to be converted.
- */
-static void hton_ct(fpp_ct_cmd_t* p_rtn_ct)
-{
-    assert(NULL != p_rtn_ct);
-    
-    
-    p_rtn_ct->saddr = htonl(p_rtn_ct->saddr);
-    p_rtn_ct->daddr = htonl(p_rtn_ct->daddr);
-    p_rtn_ct->sport = htons(p_rtn_ct->sport);
-    p_rtn_ct->dport = htons(p_rtn_ct->dport);
-    p_rtn_ct->saddr_reply = htonl(p_rtn_ct->saddr_reply);
-    p_rtn_ct->daddr_reply = htonl(p_rtn_ct->daddr_reply);
-    p_rtn_ct->sport_reply = htons(p_rtn_ct->sport_reply);
-    p_rtn_ct->dport_reply = htons(p_rtn_ct->dport_reply);
-    p_rtn_ct->protocol = htons(p_rtn_ct->protocol);
-    p_rtn_ct->flags = htons(p_rtn_ct->flags);
-    p_rtn_ct->route_id = htonl(p_rtn_ct->route_id);
-    p_rtn_ct->route_id_reply = htonl(p_rtn_ct->route_id_reply);
-}
- 
- 
-/*
- * @brief          Network-to-host (ntoh) function for the IPv6 conntrack struct.
- * @param[in,out]  p_rtn_ct  The IPv6 conntrack struct to be converted.
- */
-static void ntoh_ct6(fpp_ct6_cmd_t* p_rtn_ct6)
-{
-    assert(NULL != p_rtn_ct6);
-    
-    
-    p_rtn_ct6->saddr[0] = ntohl(p_rtn_ct6->saddr[0]);
-    p_rtn_ct6->saddr[1] = ntohl(p_rtn_ct6->saddr[1]);
-    p_rtn_ct6->saddr[2] = ntohl(p_rtn_ct6->saddr[2]);
-    p_rtn_ct6->saddr[3] = ntohl(p_rtn_ct6->saddr[3]);
-    p_rtn_ct6->daddr[0] = ntohl(p_rtn_ct6->daddr[0]);
-    p_rtn_ct6->daddr[1] = ntohl(p_rtn_ct6->daddr[1]);
-    p_rtn_ct6->daddr[2] = ntohl(p_rtn_ct6->daddr[2]);
-    p_rtn_ct6->daddr[3] = ntohl(p_rtn_ct6->daddr[3]);
-    p_rtn_ct6->sport = ntohs(p_rtn_ct6->sport);
-    p_rtn_ct6->dport = ntohs(p_rtn_ct6->dport);
-    p_rtn_ct6->saddr_reply[0] = ntohl(p_rtn_ct6->saddr_reply[0]);
-    p_rtn_ct6->saddr_reply[1] = ntohl(p_rtn_ct6->saddr_reply[1]);
-    p_rtn_ct6->saddr_reply[2] = ntohl(p_rtn_ct6->saddr_reply[2]);
-    p_rtn_ct6->saddr_reply[3] = ntohl(p_rtn_ct6->saddr_reply[3]);
-    p_rtn_ct6->daddr_reply[0] = ntohl(p_rtn_ct6->daddr_reply[0]);
-    p_rtn_ct6->daddr_reply[1] = ntohl(p_rtn_ct6->daddr_reply[1]);
-    p_rtn_ct6->daddr_reply[2] = ntohl(p_rtn_ct6->daddr_reply[2]);
-    p_rtn_ct6->daddr_reply[3] = ntohl(p_rtn_ct6->daddr_reply[3]);
-    p_rtn_ct6->sport_reply = ntohs(p_rtn_ct6->sport_reply);
-    p_rtn_ct6->dport_reply = ntohs(p_rtn_ct6->dport_reply);
-    p_rtn_ct6->protocol = ntohs(p_rtn_ct6->protocol);
-    p_rtn_ct6->flags = ntohs(p_rtn_ct6->flags);
-    p_rtn_ct6->route_id = ntohl(p_rtn_ct6->route_id);
-    p_rtn_ct6->route_id_reply = ntohl(p_rtn_ct6->route_id_reply);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for the IPv6 conntrack struct.
- * @param[in,out]  p_rtn_ct  The IPv6 conntrack struct to be converted.
- */
-static void hton_ct6(fpp_ct6_cmd_t* p_rtn_ct6)
-{
-    assert(NULL != p_rtn_ct6);
-    
-    
-    p_rtn_ct6->saddr[0] = htonl(p_rtn_ct6->saddr[0]);
-    p_rtn_ct6->saddr[1] = htonl(p_rtn_ct6->saddr[1]);
-    p_rtn_ct6->saddr[2] = htonl(p_rtn_ct6->saddr[2]);
-    p_rtn_ct6->saddr[3] = htonl(p_rtn_ct6->saddr[3]);
-    p_rtn_ct6->daddr[0] = htonl(p_rtn_ct6->daddr[0]);
-    p_rtn_ct6->daddr[1] = htonl(p_rtn_ct6->daddr[1]);
-    p_rtn_ct6->daddr[2] = htonl(p_rtn_ct6->daddr[2]);
-    p_rtn_ct6->daddr[3] = htonl(p_rtn_ct6->daddr[3]);
-    p_rtn_ct6->sport = htons(p_rtn_ct6->sport);
-    p_rtn_ct6->dport = htons(p_rtn_ct6->dport);
-    p_rtn_ct6->saddr_reply[0] = htonl(p_rtn_ct6->saddr_reply[0]);
-    p_rtn_ct6->saddr_reply[1] = htonl(p_rtn_ct6->saddr_reply[1]);
-    p_rtn_ct6->saddr_reply[2] = htonl(p_rtn_ct6->saddr_reply[2]);
-    p_rtn_ct6->saddr_reply[3] = htonl(p_rtn_ct6->saddr_reply[3]);
-    p_rtn_ct6->daddr_reply[0] = htonl(p_rtn_ct6->daddr_reply[0]);
-    p_rtn_ct6->daddr_reply[1] = htonl(p_rtn_ct6->daddr_reply[1]);
-    p_rtn_ct6->daddr_reply[2] = htonl(p_rtn_ct6->daddr_reply[2]);
-    p_rtn_ct6->daddr_reply[3] = htonl(p_rtn_ct6->daddr_reply[3]);
-    p_rtn_ct6->sport_reply = htons(p_rtn_ct6->sport_reply);
-    p_rtn_ct6->dport_reply = htons(p_rtn_ct6->dport_reply);
-    p_rtn_ct6->protocol = htons(p_rtn_ct6->protocol);
-    p_rtn_ct6->flags = htons(p_rtn_ct6->flags);
-    p_rtn_ct6->route_id = htonl(p_rtn_ct6->route_id);
-    p_rtn_ct6->route_id_reply = htonl(p_rtn_ct6->route_id_reply);
-}
- 
- 
-/*
- * @brief          Host-to-network (hton) function for the timeout struct.
- * @param[in,out]  p_rtn_ct  The timeout struct to be converted.
- */
-static void hton_timeout(fpp_timeout_cmd_t* p_rtn_timeout)
-{
-    assert(NULL != p_rtn_timeout);
-    
-    
-    p_rtn_timeout->protocol = htons(p_rtn_timeout->protocol);
-    p_rtn_timeout->sam_4o6_timeout = htons(p_rtn_timeout->sam_4o6_timeout);
-    p_rtn_timeout->timeout_value1 = htonl(p_rtn_timeout->timeout_value1);
-    p_rtn_timeout->timeout_value2 = htonl(p_rtn_timeout->timeout_value2);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested route from the PFE.
- *              Identify the route by its ID.
- * @param[in]   p_cl      FCI client instance
- * @param[out]  p_rtn_rt  Space for data from the PFE.
- * @param[in]   id        ID of the requested route.
- *                        Route IDs are user-defined. See fci_rt_add().
- * @return      FPP_ERR_OK : Requested route was found.
- *                           A copy of its configuration was stored into p_rtn_rt.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_rt_get_by_id(FCI_CLIENT* p_cl, fpp_rt_cmd_t* p_rtn_rt, uint32_t id)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_rt);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_rt_cmd_t cmd_to_fci = {0};
-    fpp_rt_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
-                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_rt(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) && (id != (reply_from_fci.id)))
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
-                        sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_rt(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_rt = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested IPv4 conntrack 
- *              from the PFE. Identify the conntrack by a specific tuple of parameters.
- * @param[in]   p_cl       FCI client instance
- * @param[out]  p_rtn_ct   Space for data from the PFE.
- * @param[in]   p_ct_data  Configuration data for IPv4 conntrack identification.
- *                         To identify a conntrack, all following data must be correctly set:
- *                           --> protocol
- *                           --> saddr
- *                           --> daddr
- *                           --> sport
- *                           --> dport
- * @return      FPP_ERR_OK : Requested route was found.
- *                           A copy of its configuration was stored into p_rtn_ct.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_ct_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct_cmd_t* p_rtn_ct, 
-                                    const fpp_ct_cmd_t* p_ct_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_ct);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_ct_cmd_t cmd_to_fci = {0};
-    fpp_ct_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
-                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_ct(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) &&
-           (
-            ((p_ct_data->protocol) == (reply_from_fci.protocol)) && 
-            ((p_ct_data->sport) == (reply_from_fci.sport)) && 
-            ((p_ct_data->dport) == (reply_from_fci.dport)) &&
-            ((p_ct_data->saddr) == (reply_from_fci.saddr)) && 
-            ((p_ct_data->daddr) == (reply_from_fci.daddr)) 
-           )
-          )
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
-                        sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_ct(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_ct = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get configuration data of a requested IPv6 conntrack 
- *              from the PFE. Identify the conntrack by a specific tuple of parameters.
- * @param[in]   p_cl        FCI client instance
- * @param[out]  p_rtn_ct6   Space for data from the PFE.
- * @param[in]   p_ct6_data  Configuration data for IPv6 conntrack identification.
- *                          To identify a conntrack, all following data must be correctly set:
- *                            --> protocol
- *                            --> saddr
- *                            --> daddr
- *                            --> sport
- *                            --> dport
- * @return      FPP_ERR_OK : Requested route was found.
- *                           A copy of its configuration was stored into p_rtn_ct6.
- *              other      : Some error occured (represented by the respective error code).
- *                           No data copied.
- */
-int fci_ct6_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct6_cmd_t* p_rtn_ct6, 
-                                     const fpp_ct6_cmd_t* p_ct6_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_ct6);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_ct6_cmd_t cmd_to_fci = {0};
-    fpp_ct6_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
-                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_ct6(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop (with the search condition) */
-    while ((FPP_ERR_OK == rtn) &&
-           (
-            ((p_ct6_data->protocol) == (reply_from_fci.protocol)) && 
-            ((p_ct6_data->sport) == (reply_from_fci.sport)) && 
-            ((p_ct6_data->dport) == (reply_from_fci.dport)) &&
-            (0 == memcmp(p_ct6_data->saddr, reply_from_fci.saddr, (4 * sizeof(uint32_t)))) &&
-            (0 == memcmp(p_ct6_data->daddr, reply_from_fci.daddr, (4 * sizeof(uint32_t))))
-           )
-          )
-    {
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
-                        sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        ntoh_ct6(&reply_from_fci);  /* set correct byte order */
-    }
-    
-    /* if search successful, then assign the data */
-    if (FPP_ERR_OK == rtn)
-    {
-        *p_rtn_ct6 = reply_from_fci;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
- 
- 
-/*
- * @brief       Use FCI calls to update configuration of a target IPv4 conntrack in the PFE.
- * @details     NOTE: For conntracks, only a few selected parameters can be modified.
- *                    See FCI API Reference, chapter FPP_CMD_IPV4_CONNTRACK, 
- *              subsection "Action FPP_ACTION_UPDATE"
- * @param[in]   p_cl       FCI client instance
- * @param[in]   p_ct_data  Data struct which represents a new configuration of 
- *                         the target IPv4 conntrack.
- *                         Initial data can be obtained via fci_ct_get_by_tuple().
- * @return      FPP_ERR_OK : Configuration of the target IPv4 conntrack was
- *                           successfully updated in the PFE.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_update(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_ct_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_ct_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_ct_data;
-    
-    /* send data */
-    hton_ct(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to update configuration of a target IPv6 conntrack in the PFE.
- * @details     NOTE: For conntracks, only a few selected parameters can be modified.
- *                    See FCI API Reference, chapter FPP_CMD_IPV6_CONNTRACK, 
- *              subsection "Action FPP_ACTION_UPDATE"
- * @param[in]   p_cl        FCI client instance
- * @param[in]   p_ct6_data  Data struct which represents a new configuration of 
- *                          the target IPv6 conntrack.
- *                          Initial data can be obtained via fci_ct6_get_by_tuple().
- * @return      FPP_ERR_OK : Configuration of the target IPv6 conntrack was
- *                           successfully updated in the PFE.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct6_update(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_ct6_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_ct6_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_ct6_data;
-    
-    /* send data */
-    hton_ct6(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_UPDATE;
-    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to set timeout for IPv4 TCP conntracks in the PFE.
- * @param[in]   p_cl     FCI client instance
- * @param[in]   timeout  Timeout [seconds]
- * @param[in]   is_4o6   Set true if the timeout is intended for 
- *                       IPv4 over IPv6 tunnel connections.
- * @return      FPP_ERR_OK : New timeout was set.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_timeout_tcp(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_timeout_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.protocol = 6u;  /* 6 == tcp */
-    cmd_to_fci.timeout_value1 = timeout;
-    cmd_to_fci.sam_4o6_timeout = ((is_4o6) ? (1u) : (0u));
-    
-    /* send data */
-    hton_timeout(&cmd_to_fci);  /* set correct byte order */
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
-                                                   (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to set timeout for IPv4 UDP conntracks in the PFE.
- * @param[in]   p_cl      FCI client instance
- * @param[in]   timeout   Timeout [seconds]
- * @param[in]   timeout2  Separate timeout for unidirectional IPv4 UDP conntracks.
- *                        If zero, then it is ignored and 'timeout' value is used for both
- *                        bidirectional and unidirectional conntracks.
- * @param[in]   is_4o6    Set true if the timeout is intended for 
- *                        IPv4 over IPv6 tunnel connections.
- * @return      FPP_ERR_OK : New timeout was set.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_timeout_udp(FCI_CLIENT* p_cl, uint32_t timeout, uint32_t timeout2, bool is_4o6)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_timeout_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.protocol = 17u;  /* 17 == udp */
-    cmd_to_fci.timeout_value1 = timeout;
-    cmd_to_fci.timeout_value2 = timeout2;
-    cmd_to_fci.sam_4o6_timeout = ((is_4o6) ? (1u) : (0u));
-    
-    /* send data */
-    hton_timeout(&cmd_to_fci);  /* set correct byte order */
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
-                                                   (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to set timeout for all other IPv4 conntracks than TCP/UDP ones.
- * @param[in]   p_cl     FCI client instance
- * @param[in]   timeout  Timeout [seconds]
- * @param[in]   is_4o6    Set true if the timeout is intended for 
- *                        IPv4 over IPv6 tunnel connections.
- * @return      FPP_ERR_OK : New timeout was set.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_timeout_others(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_timeout_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.protocol = 0u;  /* 0 == others */
-    cmd_to_fci.timeout_value1 = timeout;
-    cmd_to_fci.sam_4o6_timeout = ((is_4o6) ? (1u) : (0u));
-    
-    /*  send data  */
-    hton_timeout(&cmd_to_fci);  /* set correct byte order */
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
-                                                   (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
- 
- 
-/*
- * @brief       Use FCI calls to create a new IP route in the PFE.
- * @param[in]   p_cl       FCI client instance
- * @param[in]   id         ID of the new route.
- * @param[in]   p_rt_data  Configuration data for the new IP route.
- *                         To create a new IP route, a local data struct must be created,
- *                         configured and then passed to this function.
- *                         See [localdata_rt] functions to learn more.
- * @return      FPP_ERR_OK : New IP route was created.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_rt_add(FCI_CLIENT* p_cl, uint32_t id, const fpp_rt_cmd_t* p_rt_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rt_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_rt_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_rt_data;
-    cmd_to_fci.id = id;
-    
-    /* send data */
-    hton_rt(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_REGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
-                                           (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to destroy the target IP route in the PFE.
- * @param[in]   p_cl  FCI client instance
- * @param[in]   id    ID of the route to destroy.
- * @return      FPP_ERR_OK : IP route was destroyed.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_rt_del(FCI_CLIENT* p_cl, uint32_t id)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_rt_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci.id = id;
-    
-    /* send data */
-    hton_rt(&cmd_to_fci);  /*  set correct byte order  */
-    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
-                                           (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to create a new IPv4 conntrack in the PFE.
- * @param[in]   p_cl       FCI client instance
- * @param[in]   p_ct_data  Configuration data for the new IPv4 conntrack.
- *                         To create a new IPv4 conntrack, a local data struct must 
- *                         be created, configured and then passed to this function.
- *                         See [localdata_ct] functions to learn more.
- * @return      FPP_ERR_OK : New IPv4 conntrack was created.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_add(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_ct_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_ct_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_ct_data;
-    
-    /* send data */
-    hton_ct(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_REGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to destroy the target IPv4 conntrack in the PFE.
- * @param[in]   p_cl  FCI client instance
- * @param[in]   p_ct_data  Configuration data for IPv4 conntrack identification.
- *                         To identify a conntrack, all following data must be correctly set:
- *                           --> protocol
- *                           --> saddr
- *                           --> daddr
- *                           --> sport
- *                           --> dport
- * @return      FPP_ERR_OK : IPv4 conntrack was destroyed.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_del(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_ct_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_ct_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_ct_data;
-    
-    /* send data */
-    hton_ct(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
-                                                 (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to create a new IPv6 conntrack in the PFE.
- * @param[in]   p_cl       FCI client instance
- * @param[in]   p_ct_data  Configuration data for the new IPv6 conntrack.
- *                         To create a new IPv6 conntrack, a local data struct must 
- *                         be created, configured and then passed to this function.
- *                         See [localdata_ct6] functions to learn more.
- * @return      FPP_ERR_OK : New IPv6 conntrack was created.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct6_add(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_ct6_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_ct6_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_ct6_data;
-    
-    /* send data */
-    hton_ct6(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_REGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
-                                                 (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to destroy the target IPv6 conntrack in the PFE.
- * @param[in]   p_cl  FCI client instance
- * @param[in]   p_ct_data  Configuration data for IPv6 conntrack identification.
- *                         To identify a conntrack, all following data must be correctly set:
- *                           --> protocol
- *                           --> saddr
- *                           --> daddr
- *                           --> sport
- *                           --> dport
- * @return      FPP_ERR_OK : IPv6 conntrack was destroyed.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_ct6_del(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_ct6_data);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    fpp_ct6_cmd_t cmd_to_fci = {0};
-    
-    /* prepare data */
-    cmd_to_fci = *p_ct6_data;
-    
-    /* send data */
-    hton_ct6(&cmd_to_fci);  /* set correct byte order */
-    cmd_to_fci.action = FPP_ACTION_DEREGISTER;
-    rtn = fci_write(p_cl, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
-                                                 (unsigned short*)(&cmd_to_fci));
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to reset (clear) all IPv4 routes & conntracks in the PFE.
- * @param[in]   p_cl  FCI client instance
- * @return      FPP_ERR_OK : All IPv4 routes & conntracks were cleared.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_rtct_reset_ip4(FCI_CLIENT* p_cl)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* prepare data */
-    /* empty */
-    
-    /* send data */
-    rtn = fci_write(p_cl, FPP_CMD_IPV4_RESET, 0, NULL);
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to reset (clear) all IPv6 routes & conntracks in the PFE.
- * @param[in]   p_cl  FCI client instance
- * @return      FPP_ERR_OK : All IPv6 routes & conntracks were cleared.
- *              other      : Some error occured (represented by the respective error code).
- */
-int fci_rtct_reset_ip6(FCI_CLIENT* p_cl)
-{
-    assert(NULL != p_cl);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    /* prepare data */
-    /* empty */
-    
-    /* send data */
-    rtn = fci_write(p_cl, FPP_CMD_IPV6_RESET, 0, NULL);
-    
-    return (rtn);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-/*
- * @defgroup    localdata_rt  [localdata_rt]
- * @brief:      Functions marked as [localdata_rt] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_rt_add() to 
- *              create a new IP route with given configuration in the PFE.
- */
- 
- 
-/*
- * @brief          Set a route as IPv4 route. If the route was previously set as IPv6, then 
- *                 the IPv6 flag is removed.
- * @details        [localdata_rt]
- * @param[in,out]  p_rt  Local data to be modified.
- *                       For IP routes, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_rt_ld_set_as_ip4(fpp_rt_cmd_t* p_rt)
-{
-    assert(NULL != p_rt);
-    p_rt->flags &= ~(FPP_IP_ROUTE_4o6);
-    p_rt->flags |= FPP_IP_ROUTE_6o4;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set a route as IPv6 route. If the route was previously set as IPv4, then 
- *                 the IPv4 flag is removed.
- * @details        [localdata_rt]
- * @param[in,out]  p_rt  Local data to be modified.
- *                       For IP routes, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_rt_ld_set_as_ip6(fpp_rt_cmd_t* p_rt)
-{
-    assert(NULL != p_rt);
-    p_rt->flags &= ~(FPP_IP_ROUTE_6o4);
-    p_rt->flags |= FPP_IP_ROUTE_4o6;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set destination MAC address of a route.
- * @details        [localdata_rt]
- * @param[in,out]  p_rt  Local data to be modified.
- *                       For IP routes, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- *                 p_src_mac  Source MAC address.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_rt_ld_set_src_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_src_mac[6])
-{
-    assert(NULL != p_rt);
-    assert(NULL != p_src_mac);
-    memcpy((p_rt->src_mac), p_src_mac, (6 * sizeof(uint8_t)));
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set destination MAC address of a route.
- * @details        [localdata_rt]
- * @param[in,out]  p_rt  Local data to be modified.
- *                       For IP routes, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- *                 p_dst_mac  Destination MAC address.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_rt_ld_set_dst_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_dst_mac[6])
-{
-    assert(NULL != p_rt);
-    assert(NULL != p_dst_mac);
-    memcpy((p_rt->dst_mac), p_dst_mac, (6 * sizeof(uint8_t)));
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set egress physical interface of a route.
- * @details        [localdata_rt]
- * @param[in,out]  p_rt  Local data to be modified.
- *                       For IP routes, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      p_phyif_name  Name of a physical interface which shall be used as egress.
- *                               Names of physical interfaces are hardcoded.
- *                               See the FCI API Reference, chapter Interface Management.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_rt_ld_set_egress_phyif(fpp_rt_cmd_t* p_rt, const char* p_phyif_name)
-{
-    assert(NULL != p_rt);
-    assert(NULL != p_phyif_name);
-    
-    return set_text((p_rt->output_device), p_phyif_name, IFNAMSIZ);
-}
- 
- 
-/*
- * @defgroup    localdata_ct  [localdata_ct]
- * @brief:      Functions marked as [localdata_ct] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_ct_add() to 
- *              create a new IPv4 conntrack with given configuration in the PFE.
- */
- 
- 
-/*
- * @brief          Set protocol type of an IPv4 conntrack.
- * @details        [localdata_ct]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      protocol  IP protocol ID
- *                           See "IANA Assigned Internet Protocol Number":
- *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct_ld_set_protocol(fpp_ct_cmd_t* p_ct, uint16_t protocol)
-{
-    assert(NULL != p_ct);
-    p_ct->protocol = protocol;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set ttl decrementing of an IPv4 conntrack.
- * @details        [localdata_ct]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      enable  A request to enable/disable ttl decrementing.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct_ld_set_ttl_decr(fpp_ct_cmd_t* p_ct, bool enable)
-{
-    assert(NULL != p_ct);
-    if (enable)
-    {
-        p_ct->flags |= CTCMD_FLAGS_TTL_DECREMENT;
-    }
-    else
-    {
-        p_ct->flags &= (uint16_t)(~CTCMD_FLAGS_TTL_DECREMENT);
-    }
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set "orig direction" of an IPv4 conntrack.
- * @details        [localdata_ct]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      saddr     IPv4 source address
- * @param[in]      daddr     IPv4 destination address
- * @param[in]      sport     Source port
- * @param[in]      dport     Destination port
- * @param[in]      route_id  ID of a route for the orig direction.
- *                           The route must already exist in the PFE.
- * @param[in]      vlan      VLAN tag
- *                           0     : no VLAN tagging 
- *                           non 0 : --> if packet not tagged, then VLAN tag is added.
- *                                   --> if packet already tagged, then VLAN tag is replaced.
- * @param[in]      unidir_orig_only  Request to make the conntrack unidirectional
- *                                   (orig direction only).
- *                                   If conntrack was previously configured to be
- *                                   "reply direction only", it gets reconfigured to be
- *                                   orig direction only.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct_ld_set_orig_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr, uint32_t daddr,
-                           uint16_t sport, uint16_t dport,
-                           uint32_t route_id, uint16_t vlan, 
-                           bool unidir_orig_only)
-{
-    assert(NULL != p_ct);
-    
-    
-    p_ct->saddr = saddr;
-    p_ct->daddr = daddr;
-    p_ct->sport = sport;
-    p_ct->dport = dport;
-    p_ct->route_id = route_id;
-    p_ct->vlan = vlan;
-    if (unidir_orig_only)
-    {
-        p_ct->route_id_reply = 0uL;
-        p_ct->flags |= CTCMD_FLAGS_REP_DISABLED;
-        p_ct->flags &= ~(CTCMD_FLAGS_ORIG_DISABLED);
-    }
-    
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set "reply direction" of an IPv4 conntrack.
- * @details        [localdata_ct]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      saddr_reply     IPv4 source address (reply direction)
- * @param[in]      daddr_reply     IPv4 destination address (reply direction)
- * @param[in]      sport_reply     Source port (reply direction)
- * @param[in]      dport_reply     Destination port (reply direction)
- * @param[in]      route_id_reply  ID of a route for the orig direction.
- * @param[in]      vlan_reply      VLAN tag (reply direction)
- *                                 0     : no VLAN tagging 
- *                                 non 0 : --> if packet not tagged, then VLAN tag is added.
- *                                         --> if packet already tagged, then 
- *                                             VLAN tag is replaced.
- * @param[in]      unidir_reply_only  Request to make the conntrack unidirectional 
- *                                    (reply direction only).
- *                                    If conntrack was previously configured to be
- *                                    "orig direction only", it gets reconfigured to be
- *                                    reply direction only.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct_ld_set_reply_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr_reply, uint32_t daddr_reply,
-                            uint16_t sport_reply, uint16_t dport_reply,
-                            uint32_t route_id_reply, uint16_t vlan_reply,
-                            bool unidir_reply_only)
-{
-    assert(NULL != p_ct);
-    
-    
-    p_ct->saddr_reply = saddr_reply;
-    p_ct->daddr_reply = daddr_reply;
-    p_ct->sport_reply = sport_reply;
-    p_ct->dport_reply = dport_reply;
-    p_ct->route_id_reply = route_id_reply;
-    p_ct->vlan_reply = vlan_reply;
-    if (unidir_reply_only)
-    {
-        p_ct->route_id = 0uL;
-        p_ct->flags |= CTCMD_FLAGS_ORIG_DISABLED;
-        p_ct->flags &= ~(CTCMD_FLAGS_REP_DISABLED);
-    }
-    
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @defgroup    localdata_ct6  [localdata_ct6]
- * @brief:      Functions marked as [localdata_ct] guarantee that 
- *              only local data are accessed.
- * @details:    These functions do not make any FCI calls.
- *              If some local data modifications are made, then after all local data changes
- *              are done and finished, call fci_ct6_add() to 
- *              create a new IPv4 conntrack with given configuration in the PFE.
- */
- 
- 
-/*
- * @brief          Set protocol type of an IPv6 conntrack.
- * @details        [localdata_ct6]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      protocol  IP protocol ID
- *                           See "IANA Assigned Internet Protocol Number":
- *                https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct6_ld_set_protocol(fpp_ct6_cmd_t* p_ct6, uint16_t protocol)
-{
-    assert(NULL != p_ct6);
-    p_ct6->protocol = protocol;
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set ttl decrementing of an IPv6 conntrack.
- * @details        [localdata_ct6]
- * @param[in,out]  p_ct6  Local data to be modified.
- *                        For conntracks, there are no "initial data" to be obtained from PFE.
- *                        Simply declare a local data struct and configure it.
- * @param[in]      enable  A request to enable/disable ttl decrementing.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct6_ld_set_ttl_decr(fpp_ct6_cmd_t* p_ct6, bool enable)
-{
-    assert(NULL != p_ct6);
-    if (enable)
-    {
-        p_ct6->flags |= CTCMD_FLAGS_TTL_DECREMENT;
-    }
-    else
-    {
-        p_ct6->flags &= (uint16_t)(~CTCMD_FLAGS_TTL_DECREMENT);
-    }
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set "orig direction" of an IPv6 conntrack.
- * @details        [localdata_ct6]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      saddr     IPv6 source address
- * @param[in]      daddr     IPv6 destination address
- * @param[in]      sport     Source port
- * @param[in]      dport     Destination port
- * @param[in]      route_id  ID of a route for the orig direction.
- *                           The route must already exist in the PFE.
- * @param[in]      vlan      VLAN tag
- *                           0     : no VLAN tagging 
- *                           non 0 : --> if packet not tagged, then VLAN tag is added.
- *                                   --> if packet already tagged, then VLAN tag is replaced.
- * @param[in]      unidir_orig_only  Request to make the conntrack unidirectional
- *                                   (orig direction only).
- *                                   If conntrack was previously configured to be
- *                                   "reply direction only", it gets reconfigured to be
- *                                   orig direction only.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct6_ld_set_orig_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr[4], 
-                            const uint32_t p_daddr[4],
-                            uint16_t sport, uint16_t dport,
-                            uint32_t route_id, uint16_t vlan, 
-                            bool unidir_orig_only)
-{
-    assert(NULL != p_ct6);
-    assert(NULL != p_saddr);
-    assert(NULL != p_daddr);
-    
-    
-    memcpy((p_ct6->saddr), p_saddr, (4 * sizeof(uint32_t)));
-    memcpy((p_ct6->daddr), p_daddr, (4 * sizeof(uint32_t)));
-    p_ct6->sport = sport;
-    p_ct6->dport = dport;
-    p_ct6->route_id = route_id;
-    p_ct6->vlan = vlan;
-    if (unidir_orig_only)
-    {
-        p_ct6->route_id_reply = 0uL;
-        p_ct6->flags |= CTCMD_FLAGS_REP_DISABLED;
-        p_ct6->flags &= ~(CTCMD_FLAGS_ORIG_DISABLED);
-    }
-    
-    return (FPP_ERR_OK);
-}
- 
- 
-/*
- * @brief          Set "reply direction" of an IPv6 conntrack.
- * @details        [localdata_ct6]
- * @param[in,out]  p_ct  Local data to be modified.
- *                       For conntracks, there are no "initial data" to be obtained from PFE.
- *                       Simply declare a local data struct and configure it.
- * @param[in]      saddr_reply     IPv6 source address (reply direction)
- * @param[in]      daddr_reply     IPv6 destination address (reply direction)
- * @param[in]      sport_reply     Source port (reply direction)
- * @param[in]      dport_reply     Destination port (reply direction)
- * @param[in]      route_id_reply  ID of a route for the orig direction.
- * @param[in]      vlan_reply      VLAN tag (reply direction)
- *                                 0     : no VLAN tagging 
- *                                 non 0 : --> if packet not tagged, then VLAN tag is added.
- *                                         --> if packet already tagged, then 
- *                                             VLAN tag is replaced.
- * @param[in]      unidir_reply_only  Request to make the conntrack unidirectional 
- *                                    (reply direction only).
- *                                    If conntrack was previously configured to be
- *                                    "orig direction only", it gets reconfigured to be
- *                                    reply direction only.
- * @return         FPP_ERR_OK : Local data were successfully modified.
- *                 other      : Some error occured (represented by the respective error code).
- *                              Local data not modified.
- */
-int fci_ct6_ld_set_reply_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr_reply[4], 
-                             const uint32_t p_daddr_reply[4],
-                             uint16_t sport_reply, uint16_t dport_reply,
-                             uint32_t route_id_reply, uint16_t vlan_reply,
-                             bool unidir_reply_only)
-{
-    assert(NULL != p_ct6);
-    assert(NULL != p_saddr_reply);
-    assert(NULL != p_daddr_reply);
-    
-    
-    memcpy((p_ct6->saddr_reply), p_saddr_reply, (4 * sizeof(uint32_t)));
-    memcpy((p_ct6->daddr_reply), p_daddr_reply, (4 * sizeof(uint32_t)));
-    p_ct6->sport_reply = sport_reply;
-    p_ct6->dport_reply = dport_reply;
-    p_ct6->route_id_reply = route_id_reply;
-    p_ct6->vlan_reply = vlan_reply;
-    if (unidir_reply_only)
-    {
-        p_ct6->route_id = 0uL;
-        p_ct6->flags |= CTCMD_FLAGS_ORIG_DISABLED;
-        p_ct6->flags &= ~(CTCMD_FLAGS_REP_DISABLED);
-    }
-    
-    return (FPP_ERR_OK);
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
- 
- 
-/*
- * @brief      Query whether the route is IPv4 route.
- * @details    [localdata_rt]
- * @param[in]  p_rt  Local data to be queried.
- * @return     The route:
- *             true  : is an IPv4 route.
- *             false : is NOT an IPv4 route.
- */
-bool fci_rt_ld_is_ip4(const fpp_rt_cmd_t* p_rt)
-{
-    assert(NULL != p_rt);
-    return (bool)(FPP_IP_ROUTE_6o4 & (p_rt->flags));
-}
- 
- 
-/*
- * @brief      Query whether the route is IPv6 route.
- * @details    [localdata_rt]
- * @param[in]  p_rt  Local data to be queried.
- * @return     The route:
- *             true  : is an IPv6 route.
- *             false : is NOT an IPv6 route.
- */
-bool fci_rt_ld_is_ip6(const fpp_rt_cmd_t* p_rt)
-{
-    assert(NULL != p_rt);
-    return (bool)(FPP_IP_ROUTE_4o6 & (p_rt->flags));
-}
- 
- 
-/*
- * @brief      Query whether the IPv4 conntrack serves as a NAT.
- * @details    [localdata_ct]
- * @param[in]  p_ct  Local data to be queried.
- * @return     The IPv4 conntrack:
- *             true  : does serve as a NAT.
- *             false : does NOT serve as a NAT.
- */
-bool fci_ct_ld_is_nat(const fpp_ct_cmd_t* p_ct)
-{
-    assert(NULL != p_ct);
-    return (bool)(((p_ct->daddr_reply) != (p_ct->saddr)) || ((p_ct->saddr_reply) != (p_ct->daddr)));
-}
- 
- 
-/*
- * @brief      Query whether the IPv4 conntrack serves as a PAT.
- * @details    [localdata_ct]
- * @param[in]  p_ct  Local data to be queried.
- * @return     The IPv4 conntrack:
- *             true  : does serve as a PAT.
- *             false : does NOT serve as a PAT.
- */
-bool fci_ct_ld_is_pat(const fpp_ct_cmd_t* p_ct)
-{
-    assert(NULL != p_ct);
-    return (bool)(((p_ct->dport_reply) != (p_ct->sport)) || ((p_ct->sport_reply) != (p_ct->dport)));
-}
- 
- 
-/*
- * @brief      Query whether the IPv4 conntrack modifies VLAN tags.
- * @details    [localdata_ct]
- * @param[in]  p_ct  Local data to be queried.
- * @return     The IPv4 conntrack:
- *             true  : does modify VLAN tags of served packets.
- *             false : does NOT modify VLAN tags of served packets.
- */
-bool fci_ct_ld_is_vlan_tagging(const fpp_ct_cmd_t* p_ct)
-{
-    assert(NULL != p_ct);
-    return (bool)((0u != p_ct->vlan) || (0u != p_ct->vlan_reply));
-}
- 
- 
-/*
- * @brief      Query whether the IPv4 conntrack decrements packet's TTL counter or not.
- * @details    [localdata_ct]
- * @param[in]  p_ct  Local data to be queried.
- * @return     The IPV4 conntrack:
- *             true  : does decrement TTL counter.
- *             false : does NOT decrement TTL counter.
- */
-bool fci_ct_ld_is_ttl_decr(const fpp_ct_cmd_t* p_ct)
-{
-    assert(NULL != p_ct);
-    return (bool)(CTCMD_FLAGS_TTL_DECREMENT & (p_ct->flags));
-}
- 
- 
-/*
- * @brief      Query whether the IPv4 conntrack is orig direction only.
- * @details    [localdata_ct]
- * @param[in]  p_ct  Local data to be queried.
- * @return     The IPv4 conntrack:
- *             true  : is orig direction only.
- *             false : is NOT orig direction only.
- */
-bool fci_ct_ld_is_orig_only(const fpp_ct_cmd_t* p_ct)
-{
-    assert(NULL != p_ct);
-    return (bool)(CTCMD_FLAGS_REP_DISABLED & (p_ct->flags));
-}
- 
- 
-/*
- * @brief      Query whether the IPv4 conntrack is reply direction only.
- * @details    [localdata_ct]
- * @param[in]  p_ct  Local data to be queried.
- * @return     The IPv4 conntrack:
- *             true  : is reply direction only.
- *             false : is NOT reply direction only.
- */
-bool fci_ct_ld_is_reply_only(const fpp_ct_cmd_t* p_ct)
-{
-    assert(NULL != p_ct);
-    return (bool)(CTCMD_FLAGS_ORIG_DISABLED & (p_ct->flags));
-}
- 
- 
-/*
- * @brief      Query whether the IPv6 conntrack serves as a NAT.
- * @details    [localdata_ct6]
- * @param[in]  p_ct6  Local data to be queried.
- * @return     The IPv6 conntrack:
- *             true  : does serve as a NAT.
- *             false : does NOT serve as a NAT.
- */
-bool fci_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6)
-{
-    assert(NULL != p_ct6);
-    return (bool)(memcmp((p_ct6->daddr_reply), (p_ct6->saddr), (4 * sizeof(uint32_t))) ||
-                  memcmp((p_ct6->saddr_reply), (p_ct6->daddr), (4 * sizeof(uint32_t))));
-}
- 
- 
-/*
- * @brief      Query whether the IPv6 conntrack serves as a PAT.
- * @details    [localdata_ct6]
- * @param[in]  p_ct6  Local data to be queried.
- * @return     The IPv6 conntrack:
- *             true  : does serve as a PAT.
- *             false : does NOT serve as a PAT.
- */
-bool fci_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6)
-{
-    assert(NULL != p_ct6);
-    return (bool)(((p_ct6->dport_reply) != (p_ct6->sport)) || ((p_ct6->sport_reply) != (p_ct6->dport)));
-}
- 
- 
-/*
- * @brief      Query whether the IPv6 conntrack modifies VLAN tags.
- * @details    [localdata_ct6]
- * @param[in]  p_ct6  Local data to be queried.
- * @return     The IPv6 conntrack:
- *             true  : does modify VLAN tags of served packets.
- *             false : does NOT modify VLAN tags of served packets.
- */
-bool fci_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6)
-{
-    assert(NULL != p_ct6);
-    return (bool)((0u != p_ct6->vlan) || (0u != p_ct6->vlan_reply));
-}
- 
- 
-/*
- * @brief      Query whether the IPv6 conntrack decrements packet's TTL counter or not.
- * @details    [localdata_ct6]
- * @param[in]  p_ct6  Local data to be queried.
- * @return     The IPV6 conntrack:
- *             true  : does decrement TTL counter.
- *             false : does NOT decrement TTL counter.
- */
-bool fci_ct6_ld_is_ttl_decr(const fpp_ct6_cmd_t* p_ct6)
-{
-    assert(NULL != p_ct6);
-    return (bool)(CTCMD_FLAGS_TTL_DECREMENT & (p_ct6->flags));
-}
- 
- 
-/*
- * @brief      Query whether the IPv6 conntrack is orig direction only.
- * @details    [localdata_ct6]
- * @param[in]  p_ct6  Local data to be queried.
- * @return     The IPv6 conntrack:
- *             true  : is orig direction only.
- *             false : is NOT orig direction only.
- */
-bool fci_ct6_ld_is_orig_only(const fpp_ct6_cmd_t* p_ct6)
-{
-    assert(NULL != p_ct6);
-    return (bool)(CTCMD_FLAGS_REP_DISABLED & (p_ct6->flags));
-}
- 
- 
-/*
- * @brief      Query whether the IPv6 conntrack is reply direction only.
- * @details    [localdata_ct6]
- * @param[in]  p_ct6  Local data to be queried.
- * @return     The IPv6 conntrack:
- *             true  : is reply direction only.
- *             false : is NOT reply direction only.
- */
-bool fci_ct6_ld_is_reply_only(const fpp_ct6_cmd_t* p_ct6)
-{
-    assert(NULL != p_ct6);
-    return (bool)(CTCMD_FLAGS_ORIG_DISABLED & (p_ct6->flags));
-}
- 
- 
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all IP routes in the PFE and
- *             execute a callback print function for each reported IP route.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next IP route is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @param[in]  print_ip4   Set true to print IPv4 routes.
- * @param[in]  print_ip6   Set true to print IPv6 routes.
- * @return     FPP_ERR_OK : Successfully iterated through all IP routes.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_rt_print_all(FCI_CLIENT* p_cl, fci_rt_cb_print_t p_cb_print, bool print_ip4, bool print_ip6)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_rt_cmd_t cmd_to_fci = {0};
-    fpp_rt_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
-                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_rt(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        if ((print_ip4) && (FPP_IP_ROUTE_6o4 & (reply_from_fci.flags)))
-        {
-            rtn = p_cb_print(&reply_from_fci);  /* print IPv4 route info */
-        }
-        if ((print_ip6) && (FPP_IP_ROUTE_4o6 & (reply_from_fci.flags)))
-        {
-            rtn = p_cb_print(&reply_from_fci);  /* print IPv6 route info */
-        }
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
-                            sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_rt(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more IP routes to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_RT_ENTRY_NOT_FOUND == rtn) 
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all IP routes in the PFE.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of IP routes.
- * @return      FPP_ERR_OK : Successfully counted all IP routes.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_rt_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_rt_cmd_t cmd_to_fci = {0};
-    fpp_rt_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint32_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
-                    sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting routes) */
-    
-    /*  query loop  */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_IP_ROUTE,
-                        sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting routes) */
-    }
-    
-    /* query loop runs till there are no more IP routes to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_RT_ENTRY_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all IPv4 conntracks in the PFE and
- *             execute a callback print function for each reported IPv4 conntrack.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next IPv4 conntrack is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all IPv4 conntracks.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_ct_print_all(FCI_CLIENT* p_cl, fci_ct_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_ct_cmd_t cmd_to_fci = {0};
-    fpp_ct_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
-                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_ct(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        rtn = p_cb_print(&reply_from_fci);
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
-                            sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_ct(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more IPv4 conntracks to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all IPv4 conntracks in the PFE.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of IPv4 conntracks.
- * @return      FPP_ERR_OK : Successfully counted all IPv4 conntracks.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_ct_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_ct_cmd_t cmd_to_fci = {0};
-    fpp_ct_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint32_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
-                    sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting conntracks) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_IPV4_CONNTRACK,
-                        sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting conntracks) */
-    }
-    
-    /* query loop runs till there are no more IPv4 conntracks to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief      Use FCI calls to iterate through all IPv6 conntracks in the PFE and
- *             execute a callback print function for each reported IPv6 conntrack.
- * @param[in]  p_cl        FCI client instance
- * @param[in]  p_cb_print  Callback print function.
- *                         --> If the callback returns zero, then all is OK and 
- *                             the next IPv6 conntrack is picked for a print process.
- *                         --> If the callback returns non-zero, then some problem is 
- *                             assumed and this function terminates prematurely.
- * @return     FPP_ERR_OK : Successfully iterated through all IPv6 conntracks.
- *             other      : Some error occured (represented by the respective error code).
- */
-int fci_ct6_print_all(FCI_CLIENT* p_cl, fci_ct6_cb_print_t p_cb_print)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_cb_print);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_ct6_cmd_t cmd_to_fci = {0};
-    fpp_ct6_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
-                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    ntoh_ct6(&reply_from_fci);  /* set correct byte order */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        rtn = p_cb_print(&reply_from_fci);
-        
-        if (FPP_ERR_OK == rtn)
-        {
-            cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-            rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
-                            sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
-                            &reply_length, (unsigned short*)(&reply_from_fci));
-            ntoh_ct6(&reply_from_fci);  /* set correct byte order */
-        }
-    }
-    
-    /* query loop runs till there are no more IPv6 conntracks to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
-    {
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/*
- * @brief       Use FCI calls to get a count of all IPv6 conntracks in the PFE.
- * @param[in]   p_cl         FCI client instance
- * @param[out]  p_rtn_count  Space to store the count of IPv6 conntracks.
- * @return      FPP_ERR_OK : Successfully counted all IPv6 conntracks.
- *                           Count was stored into p_rtn_count.
- *              other      : Some error occured (represented by the respective error code).
- *                           No count was stored.
- */
-int fci_ct6_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count)
-{
-    assert(NULL != p_cl);
-    assert(NULL != p_rtn_count);
-    
-    
-    int rtn = FPP_ERR_FCI;
-    
-    fpp_ct6_cmd_t cmd_to_fci = {0};
-    fpp_ct6_cmd_t reply_from_fci = {0};
-    unsigned short reply_length = 0u;
-    uint32_t count = 0u;
-        
-    /* start query process */
-    cmd_to_fci.action = FPP_ACTION_QUERY;
-    rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
-                    sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
-                    &reply_length, (unsigned short*)(&reply_from_fci));
-    /* no need to set correct byte order (we are just counting conntracks) */
-    
-    /* query loop */
-    while (FPP_ERR_OK == rtn)
-    {
-        count++;
-        
-        cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
-        rtn = fci_query(p_cl, FPP_CMD_IPV6_CONNTRACK,
-                        sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
-                        &reply_length, (unsigned short*)(&reply_from_fci));
-        /* no need to set correct byte order (we are just counting conntracks) */
-    }
-    
-    /* query loop runs till there are no more IPv6 conntracks to report */
-    /* the following error is therefore OK and expected (it ends the query loop) */
-    if (FPP_ERR_CT_ENTRY_NOT_FOUND == rtn)
-    {
-        *p_rtn_count = count;
-        rtn = FPP_ERR_OK;
-    }
-    
-    return (rtn);
-}
- 
- 
-/* ========================================================================= */
- 
diff --git a/sw/libfci_cli/src/libfci_interface/fci_rt_ct.h b/sw/libfci_cli/src/libfci_interface/fci_rt_ct.h
deleted file mode 100644
index 1f40127..0000000
--- a/sw/libfci_cli/src/libfci_interface/fci_rt_ct.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* =========================================================================
- *  Copyright 2020-2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
- * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * ========================================================================= */
-
-#ifndef FCI_RT_CT_H_
-#define FCI_RT_CT_H_
-
-#include "fpp_ext.h"
-#include "libfci.h"
-
-/* ==== TYPEDEFS & DATA ==================================================== */
-
-typedef int (*fci_rt_cb_print_t)(const fpp_rt_cmd_t* p_rt);
-typedef int (*fci_ct_cb_print_t)(const fpp_ct_cmd_t* p_ct);
-typedef int (*fci_ct6_cb_print_t)(const fpp_ct6_cmd_t* p_ct6);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to get data from the PFE ========== */
-
-int fci_rt_get_by_id(FCI_CLIENT* p_cl, fpp_rt_cmd_t* p_rtn_rt, uint32_t id);
-int fci_ct_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct_cmd_t* p_rtn_ct, const fpp_ct_cmd_t* p_ct_data);
-int fci_ct6_get_by_tuple(FCI_CLIENT* p_cl, fpp_ct6_cmd_t* p_rtn_ct6, const fpp_ct6_cmd_t* p_ct6_data);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to update data in the PFE ========= */
-
-int fci_ct_update(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
-int fci_ct6_update(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
-
-int fci_ct_timeout_tcp(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6);
-int fci_ct_timeout_udp(FCI_CLIENT* p_cl, uint32_t timeout, uint32_t timeout2, bool is_4o6);
-int fci_ct_timeout_others(FCI_CLIENT* p_cl, uint32_t timeout, bool is_4o6);
-
-/* ==== PUBLIC FUNCTIONS : use FCI calls to add/del items in the PFE ======= */
-
-int fci_rt_add(FCI_CLIENT* p_cl, uint32_t id, const fpp_rt_cmd_t* p_rt_data);
-int fci_rt_del(FCI_CLIENT* p_cl, uint32_t id);
-
-int fci_ct_add(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
-int fci_ct_del(FCI_CLIENT* p_cl, const fpp_ct_cmd_t* p_ct_data);
-
-int fci_ct6_add(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
-int fci_ct6_del(FCI_CLIENT* p_cl, const fpp_ct6_cmd_t* p_ct6_data);
-
-int fci_rtct_reset_ip4(FCI_CLIENT* p_cl);
-int fci_rtct_reset_ip6(FCI_CLIENT* p_cl);
-
-/* ==== PUBLIC FUNCTIONS : modify local data (no FCI calls) ================ */
-
-int fci_rt_ld_set_as_ip4(fpp_rt_cmd_t* p_rt);
-int fci_rt_ld_set_as_ip6(fpp_rt_cmd_t* p_rt);
-int fci_rt_ld_set_src_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_src_mac[6]);
-int fci_rt_ld_set_dst_mac(fpp_rt_cmd_t* p_rt, const uint8_t p_dst_mac[6]);
-int fci_rt_ld_set_egress_phyif(fpp_rt_cmd_t* p_rt, const char* p_phyif_name);
-
-int fci_ct_ld_set_protocol(fpp_ct_cmd_t* p_ct, uint16_t protocol);
-int fci_ct_ld_set_ttl_decr(fpp_ct_cmd_t* p_ct, bool enable);
-int fci_ct_ld_set_orig_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr, uint32_t daddr,
-                           uint16_t sport, uint16_t dport,
-                           uint32_t route_id, uint16_t vlan, bool unidir_orig_only);
-int fci_ct_ld_set_reply_dir(fpp_ct_cmd_t* p_ct, uint32_t saddr_reply, uint32_t daddr_reply,
-                            uint16_t sport_reply, uint16_t dport_reply,
-                            uint32_t route_id_reply, uint16_t vlan_reply, bool unidir_reply_only);
-                            
-                            
-int fci_ct6_ld_set_protocol(fpp_ct6_cmd_t* p_ct6, uint16_t protocol);
-int fci_ct6_ld_set_ttl_decr(fpp_ct6_cmd_t* p_ct6, bool enable);
-int fci_ct6_ld_set_orig_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr[4], const uint32_t p_daddr[4],
-                            uint16_t sport, uint16_t dport,
-                            uint32_t route_id, uint16_t vlan, bool unidir_orig_only);
-int fci_ct6_ld_set_reply_dir(fpp_ct6_cmd_t* p_ct6, const uint32_t p_saddr_reply[4], const uint32_t p_daddr_reply[4],
-                             uint16_t sport_reply, uint16_t dport_reply,
-                             uint32_t route_id_reply, uint16_t vlan_reply, bool unidir_reply_only);
-
-/* ==== PUBLIC FUNCTIONS : query local data (no FCI calls) ================= */
-
-bool fci_rt_ld_is_ip4(const fpp_rt_cmd_t* p_rt);
-bool fci_rt_ld_is_ip6(const fpp_rt_cmd_t* p_rt);
-
-bool fci_ct_ld_is_nat(const fpp_ct_cmd_t* p_ct);
-bool fci_ct_ld_is_pat(const fpp_ct_cmd_t* p_ct);
-bool fci_ct_ld_is_vlan_tagging(const fpp_ct_cmd_t* p_ct);
-bool fci_ct_ld_is_ttl_decr(const fpp_ct_cmd_t* p_ct);
-bool fci_ct_ld_is_orig_only(const fpp_ct_cmd_t* p_ct);
-bool fci_ct_ld_is_reply_only(const fpp_ct_cmd_t* p_ct);
-
-bool fci_ct6_ld_is_nat(const fpp_ct6_cmd_t* p_ct6);
-bool fci_ct6_ld_is_pat(const fpp_ct6_cmd_t* p_ct6);
-bool fci_ct6_ld_is_vlan_tagging(const fpp_ct6_cmd_t* p_ct6);
-bool fci_ct6_ld_is_ttl_decr(const fpp_ct6_cmd_t* p_ct6);
-bool fci_ct6_ld_is_orig_only(const fpp_ct6_cmd_t* p_ct6);
-bool fci_ct6_ld_is_reply_only(const fpp_ct6_cmd_t* p_ct6);
-
-/* ==== PUBLIC FUNCTIONS : misc ============================================ */
-
-int fci_rt_print_all(FCI_CLIENT* p_cl, fci_rt_cb_print_t p_cb_print, bool print_ip4, bool print_ip6);
-int fci_rt_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
-
-int fci_ct_print_all(FCI_CLIENT* p_cl, fci_ct_cb_print_t p_cb_print);
-int fci_ct_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
-
-int fci_ct6_print_all(FCI_CLIENT* p_cl, fci_ct6_cb_print_t p_cb_print);
-int fci_ct6_get_count(FCI_CLIENT* p_cl, uint32_t* p_rtn_count);
-
-/* ========================================================================= */
-
-#endif
diff --git a/sw/linux-pfeng/pfeng.h b/sw/linux-pfeng/pfeng.h
index 087cdaf..43e5bb9 100644
--- a/sw/linux-pfeng/pfeng.h
+++ b/sw/linux-pfeng/pfeng.h
@@ -43,7 +43,7 @@
 #else
 #error Incorrect configuration!
 #endif
-#define PFENG_DRIVER_VERSION		"BETA 0.9.5"
+#define PFENG_DRIVER_VERSION		"BETA 0.9.5 PATCH1"
 
 #define PFENG_FW_CLASS_NAME		"s32g_pfe_class.fw"
 #define PFENG_FW_UTIL_NAME		"s32g_pfe_util.fw"
diff --git a/sw/pfe_platform/hw/s32g/pfe_platform_master.c b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
index 6c7e159..4089650 100644
--- a/sw/pfe_platform/hw/s32g/pfe_platform_master.c
+++ b/sw/pfe_platform/hw/s32g/pfe_platform_master.c
@@ -1015,6 +1015,36 @@ void  pfe_platform_idex_rpc_cbk(pfe_ct_phy_if_id_t sender, uint32_t id, void *bu
 			break;
 		}
 
+		case PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_EGRESS_IF:
+		{
+			pfe_platform_rpc_pfe_log_if_del_egress_if_arg_t *arg_p = (pfe_platform_rpc_pfe_log_if_del_egress_if_arg_t *)buf;
+
+			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_LOG_IF_DEL_EGRESS_IF\n");
+
+			if (EOK == ret)
+			{
+				ret = pfe_if_db_get_first(platform->phy_if_db, sender, IF_DB_CRIT_BY_ID, (void *)(addr_t)arg_p->phy_if_id, &entry);
+				phy_if_arg = pfe_if_db_entry_get_phy_if(entry);
+
+				if ((NULL == phy_if_arg) || (EOK != ret))
+				{
+					ret = ENOENT;
+				}
+				else
+				{
+					ret = pfe_log_if_del_egress_if(log_if_arg, phy_if_arg);
+				}
+			}
+
+			/*	Report execution status to caller */
+			if (EOK != pfe_idex_set_rpc_ret_val(ret, NULL, 0U))
+			{
+				NXP_LOG_ERROR("Could not send RPC response\n");
+			}
+
+			break;
+		}
+
 		case PFE_PLATFORM_RPC_PFE_LOG_IF_IS_MATCH_OR:
 		{
 			pfe_platform_rpc_pfe_log_if_is_match_or_ret_t rpc_ret = {0};
@@ -1375,8 +1405,8 @@ void  pfe_platform_idex_rpc_cbk(pfe_ct_phy_if_id_t sender, uint32_t id, void *bu
 
 		case PFE_PLATFORM_RPC_PFE_PHY_IF_GET_OP_MODE:
 		{
-			pfe_platform_rpc_pfe_phy_if_get_op_mode_ret_t rpc_ret = {IF_OP_DEFAULT};
-			pfe_ct_if_op_mode_t mode = IF_OP_DEFAULT;
+			pfe_platform_rpc_pfe_phy_if_get_op_mode_ret_t rpc_ret = {IF_OP_DISABLED};
+			pfe_ct_if_op_mode_t mode = IF_OP_DISABLED;
 
 			NXP_LOG_DEBUG("RPC: PFE_PLATFORM_RPC_PFE_PHY_IF_GET_OP_MODE\n");
 
@@ -2021,10 +2051,8 @@ static void pfe_platform_destroy_class(pfe_platform_t *platform)
 /**
  * @brief		Assign L2 Bridge to the platform
  */
-static errno_t pfe_platform_create_l2_bridge(pfe_platform_t *platform, const pfe_platform_config_t *config)
+static errno_t pfe_platform_create_l2_bridge(pfe_platform_t *platform)
 {
-	uint16_t vlan_id = config->vlan_id;
-
 	platform->mactab = pfe_l2br_table_create(platform->cbus_baseaddr, PFE_L2BR_TABLE_MAC2F);
 	if (NULL == platform->mactab)
 	{
@@ -2039,13 +2067,7 @@ static errno_t pfe_platform_create_l2_bridge(pfe_platform_t *platform, const pfe
 		return ENODEV;
 	}
 
-	if((vlan_id == 0U) || (vlan_id >= 4095U))
-	{
-		NXP_LOG_WARNING("VLAN ID incorrect or not set. Using default VLAN ID = 0x01.\n");
-		vlan_id = 0x01;
-	}
-
-	platform->l2_bridge = pfe_l2br_create(platform->classifier, vlan_id, 300U, platform->mactab, platform->vlantab);
+	platform->l2_bridge = pfe_l2br_create(platform->classifier, 1U, platform->mactab, platform->vlantab);
 	if (NULL == platform->l2_bridge)
 	{
 		NXP_LOG_ERROR("Could not create L2 Bridge\n");
@@ -2161,7 +2183,6 @@ static errno_t pfe_platform_create_tmu(pfe_platform_t *platform)
 	};
 
 	platform->tmu = pfe_tmu_create(platform->cbus_baseaddr, platform->tmu_pe_count, &tmu_cfg);
-
 	if (NULL == platform->tmu)
 	{
 		NXP_LOG_ERROR("Couldn't create TMU instance\n");
@@ -2453,6 +2474,7 @@ static errno_t pfe_platform_create_fci(pfe_platform_t *platform)
 	fci_init_info.class = platform->classifier;
 	fci_init_info.phy_if_db = platform->phy_if_db;
 	fci_init_info.log_if_db = platform->log_if_db;
+	fci_init_info.tmu = platform->tmu;
 	ret = fci_init(&fci_init_info, "pfe_fci");
 	if (EOK != ret)
 	{
@@ -3161,7 +3183,7 @@ errno_t pfe_platform_init(const pfe_platform_config_t *config)
 #ifdef PFE_CFG_FCI_ENABLE
 #if defined(PFE_CFG_L2BRIDGE_ENABLE)
 	/*	L2 Bridge. Must be initialized after soft reset. */
-	ret = pfe_platform_create_l2_bridge(&pfe, config);
+	ret = pfe_platform_create_l2_bridge(&pfe);
 	if (EOK != ret)
 	{
 		goto exit;
diff --git a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
index 7678e10..b66edef 100644
--- a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
+++ b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.c
@@ -66,6 +66,72 @@ const pfe_tmu_phy_cfg_t *pfe_tmu_cfg_get_phy_config(pfe_ct_phy_if_id_t phy)
 	return NULL;
 }
 
+/**
+ * @brief		Initialize TMU reclaim memory
+ * @details		This implements reclaim memory initialization workaround.
+ * 				It is necessary to call this function to initialize the ECC for
+ * 				TMU reclaim memory.
+ * @warning		Function should be called before @ref pfe_tmu_cfg_init.
+ * @param[in]	cbus_base_va The cbus base address
+ */
+void pfe_tmu_reclaim_init(addr_t cbus_base_va)
+{
+	uint8_t queue;
+	uint32_t ii;
+	uint32_t dropped_packets;
+	uint32_t retries = 0U;
+
+	hal_write32(0x1U, cbus_base_va + TMU_CNTX_ACCESS_CTRL);
+
+	for (ii = 0U; ii < TLITE_PHYS_CNT; ii++)
+	{
+		/*	Initialize queues */
+		for (queue = 0U; queue < TLITE_PHY_QUEUES_CNT; queue++)
+		{
+			hal_write32(((ii & 0x1fUL) << 8U) | ((uint32_t)queue & 0x7UL), cbus_base_va + TMU_PHY_QUEUE_SEL);
+			hal_nop();
+
+			/*	Clear direct access registers */
+			hal_write32(0U, cbus_base_va + TMU_CURQ_PTR);
+			hal_write32(0U, cbus_base_va + TMU_CURQ_PKT_CNT);
+			hal_write32(0U, cbus_base_va + TMU_CURQ_DROP_CNT);
+			hal_write32(0U, cbus_base_va + TMU_CURQ_TRANS_CNT);
+			hal_write32(0U, cbus_base_va + TMU_CURQ_QSTAT);
+			hal_write32(0U, cbus_base_va + TMU_HW_PROB_CFG_TBL0);
+			hal_write32(0U, cbus_base_va + TMU_HW_PROB_CFG_TBL1);
+			hal_write32(0U, cbus_base_va + TMU_CURQ_DEBUG);
+		}
+	}
+
+	/* Queue 0 PHY 0*/
+	hal_write32(0U, cbus_base_va + TMU_PHY_QUEUE_SEL);
+	hal_nop();
+	/* WRED min 0 max 0*/
+	hal_write32(2U, cbus_base_va + TMU_CURQ_QSTAT);
+
+	/* Initialize internal TMU FIFO (length is hard coded in verilog)*/
+	for(ii = 0U; ii < TLITE_INQ_FIFODEPTH; ii++)
+	{
+		hal_write32(0UL, cbus_base_va + TMU_PHY_INQ_PKTINFO);
+	}
+
+	do
+	{
+		oal_time_usleep(10U);
+		dropped_packets = hal_read32(cbus_base_va + TMU_CURQ_DROP_CNT);
+		retries++;
+	}
+	while ((TLITE_INQ_FIFODEPTH != dropped_packets) && (10U > retries));
+
+	if (dropped_packets != TLITE_INQ_FIFODEPTH)
+	{
+		NXP_LOG_ERROR("Failed to initialize TMU reclaim memory %d\n", dropped_packets);
+	}
+
+	/* Set queue to default mode */
+	hal_write32(0U, cbus_base_va + TMU_CURQ_QSTAT);
+}
+
 /**
  * @brief		Initialize and configure the TMU
  * @param[in]	cbus_base_va The cbus base address
@@ -74,7 +140,7 @@ const pfe_tmu_phy_cfg_t *pfe_tmu_cfg_get_phy_config(pfe_ct_phy_if_id_t phy)
  */
 errno_t pfe_tmu_cfg_init(addr_t cbus_base_va, const pfe_tmu_cfg_t *cfg)
 {
-    uint8_t queue;
+	uint8_t queue;
 	uint32_t ii;
 	errno_t ret;
 	const pfe_ct_phy_if_id_t phy_if_id_temp[TLITE_PHYS_CNT] =
@@ -1526,7 +1592,7 @@ errno_t pfe_tmu_sch_cfg_bind_sched_output(addr_t cbus_base_va, pfe_ct_phy_if_id_
  */
 uint8_t pfe_tmu_sch_cfg_get_bound_sched_output(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t sch, uint8_t input)
 {
-	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, sch);
+	addr_t sch_base_va = cbus_base_va + TLITE_PHYn_SCHEDm_BASE_ADDR((uint32_t)phy, 0U);
 	uint32_t reg;
 
 	/*	Scheduler0 -> Scheduler1 is the only possible option */
diff --git a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
index c0cde16..1f23ce5 100644
--- a/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
+++ b/sw/pfe_platform/hw/s32g/pfe_tmu_csr.h
@@ -200,6 +200,8 @@
 #define TLITE_SHP_INVALID_POS	0x1fU
 #define TLITE_SCH_INVALID_INPUT 0xffU
 
+#define TLITE_INQ_FIFODEPTH		256U
+
 /*	Implementation of the pfe_tmu_phy_cfg_t */
 struct pfe_tmu_phy_cfg_tag
 {
@@ -247,6 +249,7 @@ errno_t pfe_tmu_sch_cfg_bind_queue(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy,
 uint8_t pfe_tmu_sch_cfg_get_bound_queue(addr_t cbus_base_va, pfe_ct_phy_if_id_t phy, uint8_t sch, uint8_t input);
 
 errno_t pfe_tmu_cfg_init(addr_t cbus_base_va, const pfe_tmu_cfg_t *cfg);
+void pfe_tmu_reclaim_init(addr_t cbus_base_va);
 void pfe_tmu_cfg_reset(addr_t cbus_base_va);
 void pfe_tmu_cfg_enable(addr_t cbus_base_va);
 void pfe_tmu_cfg_disable(addr_t cbus_base_va);
diff --git a/sw/pfe_platform/public/pfe_ct.h b/sw/pfe_platform/public/pfe_ct.h
index 798e5f7..ba57fa2 100644
--- a/sw/pfe_platform/public/pfe_ct.h
+++ b/sw/pfe_platform/public/pfe_ct.h
@@ -312,13 +312,14 @@ typedef struct __attribute__((packed, aligned(4)))
  */
 typedef enum __attribute__((packed))
 {
-	IF_OP_DEFAULT = 0U,				/*!< Default operational mode */
-	IF_OP_BRIDGE = 1U,				/*!< L2 bridge */
-	IF_OP_ROUTER = 2U,				/*!< L3 router */
-	IF_OP_VLAN_BRIDGE = 3U,			/*!< L2 bridge with VLAN */
-	IF_OP_FLEX_ROUTER = 4U,			/*!< Flexible router */
-	IF_OP_L2L3_BRIDGE = 5U,			/*!< L2-L3 bridge */
-	IF_OP_L2L3_VLAN_BRIDGE = 6U,	/*!< L2-L3 bridge with VLAN */
+	IF_OP_DISABLED = 0U,			/*!< Disabled */
+	IF_OP_DEFAULT = 1U,				/*!< Default operational mode */
+	IF_OP_BRIDGE = 2U,				/*!< L2 bridge */
+	IF_OP_ROUTER = 3U,				/*!< L3 router */
+	IF_OP_VLAN_BRIDGE = 4U,			/*!< L2 bridge with VLAN */
+	IF_OP_FLEX_ROUTER = 5U,			/*!< Flexible router */
+	IF_OP_L2L3_BRIDGE = 6U,			/*!< L2-L3 bridge */
+	IF_OP_L2L3_VLAN_BRIDGE = 7U,	/*!< L2-L3 bridge with VLAN */
 } pfe_ct_if_op_mode_t;
 
 /*	We expect given pfe_ct_if_op_mode_t size due to byte order compatibility. */
@@ -338,7 +339,6 @@ typedef enum __attribute__((packed))
 	IF_FL_PTP_PROMISC = (1U << 9U),		/*!< PTP traffic will bypass all ingress checks */
 	IF_FL_LOOPBACK = (1U << 10U),		/*!< If set, interface is in loopback mode */
 	IF_FL_ALLOW_Q_IN_Q = (1U << 11U),	/*!< If set, QinQ traffic is accepted */
-	IF_FL_DISCARD_TTL = (1U << 12U),	/*!< Discard packet with TTL<2 instead of passing to default logical interface */
 	IF_FL_MAX = (int)(1U << 31U)
 } pfe_ct_if_flags_t;
 
@@ -723,15 +723,6 @@ typedef struct __attribute__ (( packed, aligned (4) ))
 	uint8_t graceful_stop_confirmation;
 } pfe_ct_pe_misc_control_t;
 
-/**
-	@brief Miscellaneous config between host and PE
-*/
-typedef struct __attribute__ (( packed, aligned (4) ))
-{
-	/*	Timeout of mac aging algorithm of l2 bridge in seconds*/
-	uint16_t l2_mac_aging_timeout;
-} pfe_ct_misc_config_t;
-
 /**
  * @brief Statistics gathered for each classification algorithm
  * @details NULL pointer means that given statistics are no available
@@ -875,8 +866,6 @@ typedef struct __attribute__((packed, aligned(4)))
 	pfe_ct_version_t version;
 	/*	Misc. control  */
 	PFE_PTR(pfe_ct_pe_misc_control_t) pe_misc_control;
-	/*	Misc. config  */
-	PFE_PTR(pfe_ct_misc_config_t) misc_config;
 	/*	Errors reported by the FW */
 	PFE_PTR(pfe_ct_error_record_t) error_record;
 	/*	FW state */
diff --git a/sw/pfe_platform/public/pfe_l2br.h b/sw/pfe_platform/public/pfe_l2br.h
index ba91f81..cb805be 100644
--- a/sw/pfe_platform/public/pfe_l2br.h
+++ b/sw/pfe_platform/public/pfe_l2br.h
@@ -73,7 +73,7 @@ errno_t pfe_l2br_static_entry_set_local_flag(const pfe_l2br_t *bridge, pfe_l2br_
 errno_t pfe_l2br_static_entry_set_src_discard_flag(const pfe_l2br_t *bridge, pfe_l2br_static_entry_t* static_ent, bool_t src_discard);
 errno_t pfe_l2br_static_entry_set_dst_discard_flag(const pfe_l2br_t * bridge, pfe_l2br_static_entry_t* static_ent, bool_t dst_discard);
 
-pfe_l2br_t *pfe_l2br_create(pfe_class_t *class, uint16_t def_vlan, uint16_t def_aging_time, pfe_l2br_table_t *mac_table, pfe_l2br_table_t *vlan_table);
+pfe_l2br_t *pfe_l2br_create(pfe_class_t *class, uint16_t def_vlan, pfe_l2br_table_t *mac_table, pfe_l2br_table_t *vlan_table);
 errno_t pfe_l2br_destroy(pfe_l2br_t *bridge);
 pfe_l2br_domain_t *pfe_l2br_get_default_domain(const pfe_l2br_t *bridge) __attribute__((pure));
 pfe_l2br_domain_t *pfe_l2br_get_fallback_domain(const pfe_l2br_t *bridge) __attribute__((pure));
diff --git a/sw/pfe_platform/public/pfe_platform.h b/sw/pfe_platform/public/pfe_platform.h
index 5d4d478..f90d68e 100644
--- a/sw/pfe_platform/public/pfe_platform.h
+++ b/sw/pfe_platform/public/pfe_platform.h
@@ -77,7 +77,6 @@ typedef struct
 	pfe_ct_phy_if_id_t local_hif; /* ID of the local interface */
 	uint32_t rtable_hash_size;	/* Size (number of entries) of hash area within routing table */
 	uint32_t rtable_collision_size;	/* Size (number of entries) of collision area within routing table */
-	uint16_t vlan_id;	/* VLAN ID used for L2 Bridge configuration */
 } pfe_platform_config_t;
 
 typedef struct
diff --git a/sw/pfe_platform/src/pfe_hif_chnl.c b/sw/pfe_platform/src/pfe_hif_chnl.c
index a58bcb7..f11e060 100644
--- a/sw/pfe_platform/src/pfe_hif_chnl.c
+++ b/sw/pfe_platform/src/pfe_hif_chnl.c
@@ -1180,6 +1180,13 @@ __attribute__((pure, hot)) bool_t pfe_hif_chnl_can_accept_rx_buf(const pfe_hif_c
 	}
 #endif /* PFE_CFG_NULL_ARG_CHECK */
 
+#if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
+	if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
+	{
+        return FALSE;
+    }
+#endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
+
 	/*	A single entry must remain unused within the ring
 	 	because HIF expects that. */
 	return (pfe_hif_ring_get_fill_level(chnl->rx_ring) < (pfe_hif_ring_get_len(chnl->rx_ring) - 1U));
@@ -2402,26 +2409,32 @@ __attribute__((cold)) void pfe_hif_chnl_destroy(pfe_hif_chnl_t *chnl)
 #if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
 				if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
 				{
-					/*	HIF NOCPY buffers are provided by BMU so return them to BMU */
-					buf_va = pfe_bmu_get_va(chnl->bmu, (addr_t)buf_pa);
-				}
-				else
+                    if (NULL == buf_pa)
+                    {
+                        NXP_LOG_WARNING("Drained buffer PA is NULL\n");
+                    }
+                    else
+                    {
+					/*	Return buffer into BMU. Resource protection is embedded. */
+                        pfe_bmu_free_buf(chnl->bmu, (addr_t)buf_pa);
+                    }
+                }
+                else
 #endif /* PFE_CFG_HIF_NOCPY_SUPPORT */
 				{
 					/*	HIF buffers are provided by SW pool so return them to SW pool */
 					buf_va = bpool_get_va(chnl->rx_pool, buf_pa);
-				}
-
-				if (NULL == buf_va)
-				{
-					NXP_LOG_WARNING("Drained buffer VA is NULL\n");
-				}
-				else
-				{
-					/*	Return buffer into pool. Resource protection is embedded. */
-					bpool_put(chnl->rx_pool, buf_va);
-				}
-			}
+                    if (NULL == buf_va)
+                    {
+                        NXP_LOG_WARNING("Drained buffer VA is NULL\n");
+                    }
+                    else
+                    {
+                        /*	Return buffer into pool. Resource protection is embedded. */
+                        bpool_put(chnl->rx_pool, buf_va);
+                    }
+                }
+            }
 
 #if defined(PFE_CFG_HIF_NOCPY_SUPPORT)
 			if (chnl->id >= PFE_HIF_CHNL_NOCPY_ID)
diff --git a/sw/pfe_platform/src/pfe_l2br.c b/sw/pfe_platform/src/pfe_l2br.c
index fbea5a8..3d795d6 100644
--- a/sw/pfe_platform/src/pfe_l2br.c
+++ b/sw/pfe_platform/src/pfe_l2br.c
@@ -45,6 +45,12 @@
 #include "pfe_l2br_table.h"
 #include "pfe_l2br.h"
 
+/**
+ * @brief	Tick period for internal timer in seconds
+ * @details	The timer is used to generate MAC table aging period.
+ */
+#define PFE_L2BR_CFG_TICK_PERIOD_SEC	300U
+
 /**
  * @brief	The L2 Bridge instance structure
  */
@@ -142,10 +148,9 @@ static errno_t pfe_bd_write_to_class(const pfe_l2br_t *bridge, uint32_t base, pf
 static errno_t pfe_l2br_update_hw_entry(pfe_l2br_domain_t *domain);
 static pfe_l2br_domain_t *pfe_l2br_create_default_domain(pfe_l2br_t *bridge, uint16_t vlan);
 static pfe_l2br_domain_t *pfe_l2br_create_fallback_domain(pfe_l2br_t *bridge);
-static bool_t pfe_l2br_domain_match_if_criterion(const pfe_l2br_domain_t *domain, const pfe_phy_if_t *iface);
-static bool_t pfe_l2br_domain_match_criterion(const pfe_l2br_t *bridge, pfe_l2br_domain_t *domain);
-static bool_t pfe_l2br_static_entry_match_criterion(const pfe_l2br_t *bridge, pfe_l2br_static_entry_t *static_ent);
-static errno_t pfe_l2br_set_mac_aging_timeout(pfe_class_t *class, const uint16_t timeout);
+static bool_t pfe_l2br_domain_match_if_criterion(pfe_l2br_domain_t *domain, pfe_phy_if_t *iface);
+static bool_t pfe_l2br_domain_match_criterion(pfe_l2br_t *bridge, pfe_l2br_domain_t *domain);
+static bool_t pfe_l2br_static_entry_match_criterion(pfe_l2br_t *bridge, pfe_l2br_static_entry_t *static_ent);
 
 /**
  * @brief		Write bridge domain structure to classifier memory
@@ -943,7 +948,7 @@ __attribute__((pure)) uint32_t pfe_l2br_domain_get_untag_if_list(const pfe_l2br_
  * @retval		TRUE Interface matches the criterion
  * @retval		FALSE Interface does not match the criterion
  */
-static bool_t pfe_l2br_domain_match_if_criterion(const pfe_l2br_domain_t *domain, const pfe_phy_if_t *iface)
+static bool_t pfe_l2br_domain_match_if_criterion(pfe_l2br_domain_t *domain, pfe_phy_if_t *iface)
 {
 	bool_t match = FALSE;
 
@@ -1796,7 +1801,7 @@ pfe_l2br_static_entry_t *pfe_l2br_static_entry_get_next(pfe_l2br_t *bridge)
  * @param[in]	bridge The bridge instance
  * @param[in]	static_ent Static entry to be matched to criterion parameters
  */
-static bool_t pfe_l2br_static_entry_match_criterion(const pfe_l2br_t *bridge, pfe_l2br_static_entry_t *static_ent)
+static bool_t pfe_l2br_static_entry_match_criterion(pfe_l2br_t *bridge, pfe_l2br_static_entry_t *static_ent)
 {
 	bool_t match = FALSE;
 
@@ -2140,7 +2145,7 @@ static errno_t pfe_platform_class_feature_enable(const pfe_class_t *class, const
  * @param[in]	vlan_table The VLAN table instance
  * @return		The instance or NULL if failed
  */
-pfe_l2br_t *pfe_l2br_create(pfe_class_t *class, uint16_t def_vlan, uint16_t def_aging_time, pfe_l2br_table_t *mac_table, pfe_l2br_table_t *vlan_table)
+pfe_l2br_t *pfe_l2br_create(pfe_class_t *class, uint16_t def_vlan, pfe_l2br_table_t *mac_table, pfe_l2br_table_t *vlan_table)
 {
 	pfe_l2br_t *bridge;
 
@@ -2202,12 +2207,6 @@ pfe_l2br_t *pfe_l2br_create(pfe_class_t *class, uint16_t def_vlan, uint16_t def_
 		/*	Configure classifier */
 		(void)pfe_class_set_default_vlan(class, def_vlan);
 
-		if (EOK != pfe_l2br_set_mac_aging_timeout(bridge->class, def_aging_time))
-		{
-			NXP_LOG_DEBUG("Could not set mac aging timeout\n");
-			goto free_and_fail;
-		}
-
 		/*	If the FW aging is off, turn it on */
 		if (pfe_platform_class_feature_enabled(bridge->class, "l2_bridge_aging")==FALSE)
 		{
@@ -2331,7 +2330,7 @@ __attribute__((pure)) pfe_l2br_domain_t *pfe_l2br_get_fallback_domain(const pfe_
  * @retval		TRUE Domain matches the criterion
  * @retval		FALSE Domain does not match the criterion
  */
-static bool_t pfe_l2br_domain_match_criterion(const pfe_l2br_t *bridge, pfe_l2br_domain_t *domain)
+static bool_t pfe_l2br_domain_match_criterion(pfe_l2br_t *bridge, pfe_l2br_domain_t *domain)
 {
 	bool_t match = FALSE;
 	LLIST_t *item;
@@ -2507,44 +2506,6 @@ pfe_l2br_domain_t *pfe_l2br_get_next_domain(pfe_l2br_t *bridge)
 	}
 }
 
-/**
- * @brief Configures the l2 bridge mac aging timeout
- * @param[in] class The classifier instance
- * @param[in] timeout Timeout time in seconds.
- * @return Either EOK or error code.
- */
-static errno_t pfe_l2br_set_mac_aging_timeout(pfe_class_t *class, const uint16_t timeout)
-{
-	pfe_ct_class_mmap_t mmap;
-	pfe_ct_misc_config_t misc_config;
-
-	errno_t ret = EOK;
-    uint32_t ff_addr;
-#if defined(PFE_CFG_NULL_ARG_CHECK)
-	if (unlikely(NULL == class))
-	{
-		NXP_LOG_ERROR("NULL argument received\n");
-		return EINVAL;
-	}
-#endif /* PFE_CFG_NULL_ARG_CHECK */
-
-	misc_config.l2_mac_aging_timeout = oal_htons(timeout);
-
-    /* Get the memory map */
-	/* All PEs share the same memory map therefore we can read
-	   arbitrary one (in this case 0U)
-	   Also mac aging algorithm will work only on core 0*/
-	ret = pfe_class_get_mmap(class, 0U, &mmap);
-	if(EOK == ret)
-	{
-        /* Get the misc address */
-        ff_addr = oal_ntohl(mmap.common.misc_config);
-        /* Write new address of misc config */
-        ret = pfe_class_write_dmem(class, 0, (addr_t)ff_addr, (void *)&misc_config, sizeof(pfe_ct_misc_config_t));
-    }
-    return ret;
-}
-
 /**
  * @brief		Return L2 Bridge runtime statistics in text form
  * @details		Function writes formatted text into given buffer.
diff --git a/sw/pfe_platform/src/pfe_log_if.c b/sw/pfe_platform/src/pfe_log_if.c
index de8b120..f15309a 100644
--- a/sw/pfe_platform/src/pfe_log_if.c
+++ b/sw/pfe_platform/src/pfe_log_if.c
@@ -1018,6 +1018,13 @@ errno_t pfe_log_if_del_mac_addr(pfe_log_if_t *iface, const pfe_mac_addr_t addr,
 		if (EOK != ret)
 		{
 			NXP_LOG_ERROR("Unable to del MAC address: %d\n", ret);
+
+			/* Removal of MAC address from phy failed, put it back to DB */
+			ret = pfe_mac_db_add_addr(iface->mac_db, addr, owner);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Unable to put back the MAC address into log_if MAC database: %d\n", ret);
+			}
 		}
 	}
 
diff --git a/sw/pfe_platform/src/pfe_log_if_slave.c b/sw/pfe_platform/src/pfe_log_if_slave.c
index 247e1f9..e043fd8 100644
--- a/sw/pfe_platform/src/pfe_log_if_slave.c
+++ b/sw/pfe_platform/src/pfe_log_if_slave.c
@@ -662,6 +662,13 @@ errno_t pfe_log_if_del_mac_addr(pfe_log_if_t *iface, const pfe_mac_addr_t addr,
 		if (EOK != ret)
 		{
 			NXP_LOG_DEBUG("Can't del MAC address: %d\n", ret);
+
+			/* Removal of MAC address by master failed, put it back to DB */
+			ret = pfe_mac_db_add_addr(iface->mac_db, addr, owner);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Unable to put back the MAC address into log_if MAC database: %d\n", ret);
+			}
 		}
 	}
 
diff --git a/sw/pfe_platform/src/pfe_pe.c b/sw/pfe_platform/src/pfe_pe.c
index d2c715b..b9c5d9c 100644
--- a/sw/pfe_platform/src/pfe_pe.c
+++ b/sw/pfe_platform/src/pfe_pe.c
@@ -292,6 +292,10 @@ errno_t pfe_pe_mem_unlock(pfe_pe_t *pe)
 		return EINVAL;
 	}
 
+	/*	Read the misc control structure from DMEM */
+	pfe_pe_memcpy_from_dmem_to_host_32_nolock(
+			pe, &misc_ctrl, misc_dmem, sizeof(pfe_ct_pe_misc_control_t));
+
 	/*	Cancel the stop request */
 	misc_ctrl.graceful_stop_request = 0U;
 
diff --git a/sw/pfe_platform/src/pfe_phy_if.c b/sw/pfe_platform/src/pfe_phy_if.c
index 0828178..b0c43b5 100644
--- a/sw/pfe_platform/src/pfe_phy_if.c
+++ b/sw/pfe_platform/src/pfe_phy_if.c
@@ -2413,6 +2413,13 @@ errno_t pfe_phy_if_del_mac_addr(pfe_phy_if_t *iface, const pfe_mac_addr_t addr,
 				if (EOK != ret)
 				{
 					NXP_LOG_ERROR("Unable to del MAC address: %d\n", ret);
+
+					/* Removal of MAC address from emac failed, put it back to DB */
+					ret = pfe_mac_db_add_addr(iface->mac_db, addr, owner);
+					if (EOK != ret)
+					{
+						NXP_LOG_ERROR("Unable to put back the MAC address into phy_if MAC database: %d\n", ret);
+					}
 					ret = ENOENT;
 				}
 			}
diff --git a/sw/pfe_platform/src/pfe_phy_if_slave.c b/sw/pfe_platform/src/pfe_phy_if_slave.c
index 1722432..ca8bcad 100644
--- a/sw/pfe_platform/src/pfe_phy_if_slave.c
+++ b/sw/pfe_platform/src/pfe_phy_if_slave.c
@@ -351,7 +351,7 @@ errno_t pfe_phy_if_del_log_if(pfe_phy_if_t *iface, const pfe_log_if_t *log_if)
 pfe_ct_if_op_mode_t pfe_phy_if_get_op_mode(pfe_phy_if_t *iface)
 {
 	errno_t ret;
-	pfe_ct_if_op_mode_t mode = IF_OP_DEFAULT;
+	pfe_ct_if_op_mode_t mode = IF_OP_DISABLED;
 	pfe_platform_rpc_pfe_phy_if_get_op_mode_arg_t arg = {0};
 	pfe_platform_rpc_pfe_phy_if_get_op_mode_ret_t rpc_ret = {0};
 
@@ -359,7 +359,7 @@ pfe_ct_if_op_mode_t pfe_phy_if_get_op_mode(pfe_phy_if_t *iface)
 	if (unlikely(NULL == iface))
 	{
 		NXP_LOG_ERROR("NULL argument received\n");
-		return IF_OP_DEFAULT;
+		return IF_OP_DISABLED;
 	}
 #endif /* GLOBAL_CFG_NULL_ARG_CHECK */
 
@@ -1196,20 +1196,27 @@ errno_t pfe_phy_if_del_mac_addr(pfe_phy_if_t *iface, const pfe_mac_addr_t addr,
 
 	(void)pfe_phy_if_db_lock();
 
-	/*	Ask the master driver to delete the MAC address */
-	memcpy(&arg.mac_addr[0], addr, sizeof(arg.mac_addr));
-	arg.phy_if_id = iface->id;
-	ret = pfe_idex_master_rpc(PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR, &arg, sizeof(arg), NULL, 0U);
-	if (EOK != ret)
+	ret = pfe_mac_db_del_addr(iface->mac_db, addr, owner);
+	if(EOK != ret)
 	{
-		NXP_LOG_DEBUG("PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR failed: %d\n", ret);
+		NXP_LOG_WARNING("Unable to remove MAC address from phy_if MAC database: %d\n", ret);
 	}
 	else
 	{
-		ret = pfe_mac_db_del_addr(iface->mac_db, addr, owner);
-		if(EOK != ret)
+		/*	Ask the master driver to delete the MAC address */
+		memcpy(&arg.mac_addr[0], addr, sizeof(arg.mac_addr));
+		arg.phy_if_id = iface->id;
+		ret = pfe_idex_master_rpc(PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR, &arg, sizeof(arg), NULL, 0U);
+		if (EOK != ret)
 		{
-			NXP_LOG_WARNING("Unable to remove MAC address from phy_if MAC database: %d\n", ret);
+			NXP_LOG_DEBUG("PFE_PLATFORM_RPC_PFE_PHY_IF_DEL_MAC_ADDR failed: %d\n", ret);
+
+			/* Removal of MAC address by master failed, put it back to DB */
+			ret = pfe_mac_db_add_addr(iface->mac_db, addr, owner);
+			if (EOK != ret)
+			{
+				NXP_LOG_ERROR("Unable to put back the MAC address into phy_if MAC database: %d\n", ret);
+			}
 		}
 	}
 
@@ -1412,6 +1419,8 @@ errno_t pfe_phy_if_get_stats(pfe_phy_if_t *iface, pfe_ct_phy_if_stats_t *stat)
 	{
 		NXP_LOG_DEBUG("mutex lock failed\n");
 	}
+	
+	(void)pfe_phy_if_db_lock();
 
 	arg.phy_if_id = iface->id;
 	ret = pfe_idex_master_rpc(PFE_PLATFORM_RPC_PFE_PHY_IF_STATS, &arg, sizeof(arg), &rpc_ret, sizeof(rpc_ret));
@@ -1423,6 +1432,8 @@ errno_t pfe_phy_if_get_stats(pfe_phy_if_t *iface, pfe_ct_phy_if_stats_t *stat)
 	{
 		memcpy(stat,&rpc_ret.stats,sizeof(rpc_ret.stats));
 	}
+	
+	(void)pfe_phy_if_db_unlock();
 
 	if (EOK != oal_mutex_unlock(&iface->lock))
 	{
diff --git a/sw/pfe_platform/src/pfe_tmu.c b/sw/pfe_platform/src/pfe_tmu.c
index 567c85a..4d8081c 100644
--- a/sw/pfe_platform/src/pfe_tmu.c
+++ b/sw/pfe_platform/src/pfe_tmu.c
@@ -83,6 +83,9 @@ pfe_tmu_t *pfe_tmu_create(addr_t cbus_base_va, uint32_t pe_num, const pfe_tmu_cf
 	/*	Issue block reset */
 	pfe_tmu_reset(tmu);
 
+	/* Initialize reclaim memory */
+	pfe_tmu_reclaim_init(cbus_base_va);
+
 	/*	Disable the TMU */
 	pfe_tmu_disable(tmu);
 
diff --git a/sw/xfci/libfci/public/fpp.h b/sw/xfci/libfci/public/fpp.h
index ba1a5d0..c3770a3 100644
--- a/sw/xfci/libfci/public/fpp.h
+++ b/sw/xfci/libfci/public/fpp.h
@@ -218,317 +218,492 @@ typedef enum {
 #define FPP_ERR_CT_ENTRY_NOT_FOUND			101
 
 /**
- * @brief Specifies FCI command for working with IPv4 tracked connections
- * @details This command can be used with various values of `.action`:
- *          - @c FPP_ACTION_REGISTER: Defines a connection and binds it to previously created route(s).
- *          - @c FPP_ACTION_DEREGISTER: Deletes previously defined connection.
- *          - @c FPP_ACTION_UPDATE: Updates properties of previously defined connection.
- *          - @c FPP_ACTION_QUERY: Gets parameters of existing connection. It creates a snapshot of all active
- *            conntrack entries and replies with first of them.
- *          - @c FPP_ACTION_QUERY_CONT: Shall be called periodically after @c FPP_ACTION_QUERY was called. On each
- *            call it replies with parameters of next connection. It returns @c FPP_ERR_CT_ENTRY_NOT_FOUND when no more
- *            entries exist.
- *
- * Command Argument Type: @ref fpp_ct_cmd_t
+ * @addtogroup  dxgrLibFCI
+ * @{
+ */
+
+/**
+ * @def         FPP_CMD_IPV4_CONNTRACK
+ * @brief       FCI command for management of IPv4 conntracks.
+ * @details     Related topics: @ref l3_router
+ * @details     Related data types: @ref fpp_ct_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new IPv4 conntrack and bind it to previously created route(s).
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing IPv4 conntrack.
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of IPv4 conntrack.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) IPv4 conntrack query session and get properties 
+ *                   of the first IPv4 conntrack from the internal list of IPv4 conntracks.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next IPv4 conntrack
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
  *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new IPv4 conntrack.
  * @code{.c}
- *   fpp_ct_cmd_t cmd_data =
- *   {
- *     // Register new conntrack
- *     .action = FPP_ACTION_REGISTER,
- *     // Source IPv4 address (network endian)
- *     .saddr = ...,
- *     // Destination IPv4 address (network endian)
- *     .daddr = ...,
- *     // Source port (network endian)
- *     .sport = ...,
- *     // Destination port (network endian)
- *     .dport = ...,
- *     // Reply source IPv4 address (network endian). Used for NAT, otherwise equals .daddr
- *     .saddr_reply = ...,
- *     // Reply destination IPv4 address (network endian). Used for NAT, otherwise equals .saddr
- *     .daddr_reply = ...,
- *     // Reply source port (network endian). Used for NAT, otherwise equals .dport
- *     .sport_reply = ...,
- *     // Reply destination port (network endian). Used for NAT, otherwise equals .sport
- *     .dport_reply = ...,
- *     // IP protocol ID (17=UDP, 6=TCP, ...)
- *     .protocol = ...,
- *     // Bidirectional/Single direction (network endian)
- *     .flags = ...,
- *     // ID of route previously created with .FPP_CMD_IP_ROUTE command (network endian)
- *     .route_id = ...,
- *     // ID of reply route previously created with .FPP_CMD_IP_ROUTE command (network endian)
- *     .route_id_reply = ...,
- *     // VLAN tag in normal direction. If non-zero then it is added to routed traffic which
- *     // is untagged. If the routed traffic is tagged, then the outer tag will be replaced.
- *     .vlan = ...,
- *     // VLAN tag in reply direction. Same meaning as .vlan.
- *     .vlan_reply = ...
- *   };
+ *  .............................................  
+ *  fpp_ct_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_REGISTER,  // Action
+ *      
+ *    .saddr = ...,        // 'orig' direction: Source IP address. [NBO]
+ *    .daddr = ...,        // 'orig' direction: Destination IP address. [NBO]
+ *    .sport = ...,        // 'orig' direction: Source port. [NBO]
+ *    .dport = ...,        // 'orig' direction: Destination port. [NBO]
+ *      
+ *    .saddr_reply = ...,  // 'reply' direction: Source IP address. [NBO]
+ *                         // Used for NAT, otherwise equals '.daddr'.
+ *      
+ *    .daddr_reply = ...,  // 'reply' direction: Destination IP address.
+ *                         // Used for NAT, otherwise equals '.saddr'.
+ *      
+ *    .sport_reply = ...,  // 'reply' direction: Source port. [NBO]
+ *                         // Used for NAT, otherwise equals '.dport'.
+ *      
+ *    .dport_reply = ...,  // 'reply' direction: Destination port. [NBO]
+ *                         // Used for NAT, otherwise equals '.sport'.
+ *      
+ *    .protocol = ...,     // IANA IP Protocol Number (protocol ID). [NBO]
+ *      
+ *    .flags = ...,        // Flags. A bitset. [NBO]
+ *      
+ *    .route_id = ...,     // 'orig' direction: ID of an associated route. [NBO]
+ *                         // See FPP_CMD_IP_ROUTE.
+ *      
+ *    .route_id_reply = ...,  // 'reply' direction: ID of an associated route. [NBO]
+ *                            // See FPP_CMD_IP_ROUTE.
+ *      
+ *    .vlan = ...,         // 'orig' direction: VLAN tag. [NBO]
+ *                         // If non-zero, then this VLAN tag is added to the routed packet.
+ *                         // If the packet already has a VLAN tag, then its tag is replaced.
+ *      
+ *    .vlan_reply = ...    // 'reply' direction: VLAN tag. [NBO]
+ *                         // If non-zero, then this VLAN tag is added to the routed packet.
+ *                         // If the packet already has a VLAN tag, then its tag is replaced.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
+ * <b>orig and reply direction</b><br>
  * By default the connection is created as bi-directional. It means that two routing table entries
- * are created at once: one for standard flow given by .saddr, .daddr, .sport, .dport, and .protocol
- * and one for reverse flow defined by .saddr_reply, .daddr_reply, .sport_reply and .dport_reply. To
- * create uni-directional connection, either:
- * - set `.flags |= CTCMD_FLAGS_REP_DISABLED` and don't set @c route_id_reply, or
- * - set `.flags |= CTCMD_FLAGS_ORIG_DISABLED` and don't set @c route_id.
+ * are created at once:
+ *   - one for standard flow ('orig' direction), defined by `.protocol`, `.saddr`, `.daddr`, 
+ *     `.sport`, and `.dport`
+ *   - one for reverse flow ('reply' direction), defined by `.protocol`, `.saddr_reply`, `.daddr_reply`,
+ *     `.sport_reply` and `.dport_reply`.
+ * 
+ * To create an uni-directional connection (only one routing table entry), set one of these flags 
+ * (@b never both) when configuring a conntrack:
+ * - 'orig' direction only:  `.flags |= CTCMD_FLAGS_REP_DISABLED`, and @b don't set `.route_id_reply`.
+ * - 'reply' direction only: `.flags |= CTCMD_FLAGS_ORIG_DISABLED`, and @b don't set `.route_id`.
  *
- * To configure NAT-ed connection, set reply addresses and/or ports different than original
- * addresses and ports. To achieve NAPT (also called PAT), use @c daddr_reply, @c dport_reply,
- *  @c saddr_reply, and @c sport_reply:
- * -# `daddr_reply != saddr`: Source address of packets in original direction will be changed
- *    from @c saddr to @c daddr_reply. In case of bi-directional connection, destination address
- *    of packets in reply direction will be changed from @c daddr_reply to @c saddr.
- * -# `dport_reply != sport`: Source port of packets in original direction will be changed
- *    from @c sport to @c dport_reply. In case of bi-directional connection, destination port of
- *    packets in reply direction will be changed from @c dport_reply to @c sport.
- * -# `saddr_reply != daddr`: Destination address of packets in original direction will be changed
- *    from @c daddr to @c saddr_reply. In case of bi-directional connection, source address of
- *    packets in reply direction will be changed from @c saddr_reply to @c daddr.
- * -# `sport_reply != dport`: Destination port of packets in original direction will be changed
- *    from @c dport to @c sport_reply. In case of bi-directional connection, source port of packets
- *    in reply direction will be changed from @c sport_reply to @c dport.
+ * <b>NAT and NAPT/PAT</b><br>
+ * To configure NAT or NAPT/PAT connection, set 'reply' IP addresses and ports to different values
+ * than 'orig' IP addresses and ports.
+ * -# `.daddr_reply != .saddr`: Source address of packets in the 'orig' direction will be changed
+ *    from `.saddr` to `daddr_reply`. In case of a bi-directional connection, destination address
+ *    of packets in the 'reply' direction will be changed from `.daddr_reply` to `.saddr`.
+ * -# `.saddr_reply != .daddr`: Destination address of packets in the 'orig' direction will be changed
+ *    from `.daddr` to `.saddr_reply`. In case of a bi-directional connection, source address of
+ *    packets in the 'reply' direction will be changed from `.saddr_reply` to `.daddr`.
+ * -# `.dport_reply != .sport`: Source port of packets in the 'orig' direction will be changed
+ *    from `.sport` to `.dport_reply. In case of a bi-directional connection, destination port of
+ *    packets in the 'reply' direction will be changed from `.dport_reply` to `.sport`.
+ * -# `.sport_reply != .dport`: Destination port of packets in the 'orig' direction will be changed
+ *    from `.dport` to `.sport_reply`. In case of a bi-directional connection, source port of packets
+ *    in the 'reply' direction will be changed from `.sport_reply` to `.dport`.
  *
- * To disable port numbers check, just set both `.sport` and `.dport` to zero. This allows routing
- * using only IP addresses and protocol number.
+ * <b>Disable port checking</b><br>
+ * It is possible to leave out ports from matching process of a particular conntrack.
+ * To do so, configure the conntrack's `.sport` and `.dport` to zero.
+ * This allows routing based only on 3-tuple (protocol, source IP, destination IP).
  *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing IPv4 conntrack. 'Orig' properties are mandatory for this action.
+ * 'Reply' properties are optional.
  * @code{.c}
- *   fpp_ct_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_DEREGISTER, // Deregister previously created conntrack
- *     .saddr = ...,                    // Source IPv4 address (network endian)
- *     .daddr = ...,                    // Destination IPv4 address (network endian)
- *     .sport = ...,                    // Source port (network endian)
- *     .dport = ...,                    // Destination port (network endian)
- *     .saddr_reply = ...,              // Reply source IPv4 address (network endian)
- *     .daddr_reply = ...,              // Reply destination IPv4 address (network endian)
- *     .sport_reply = ...,              // Reply source port (network endian)
- *     .dport_reply = ...,              // Reply destination port (network endian)
- *     .protocol = ...,                 // IP protocol ID
- *   };
+ *  .............................................  
+ *  fpp_ct_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *      
+ *    // Identification of the target conntrack.
+ *    .saddr = ...,        // 'orig' direction: Source IP address. [NBO]
+ *    .daddr = ...,        // 'orig' direction: Destination IP address. [NBO]
+ *    .sport = ...,        // 'orig' direction: Source port. [NBO]
+ *    .dport = ...         // 'orig' direction: Destination port. [NBO]
+ *    .protocol = ...,     // IANA IP Protocol Number (protocol ID). [NBO]
+ *      
+ *    .saddr_reply = ...,  // 'reply' direction: Source IP address. [NBO]
+ *                         // Used for NAT, otherwise equals '.daddr'.
+ *      
+ *    .daddr_reply = ...,  // 'reply' direction: Destination IP address.
+ *                         // Used for NAT, otherwise equals '.saddr'.
+ *      
+ *    .sport_reply = ...,  // 'reply' direction: Source port. [NBO]
+ *                         // Used for NAT, otherwise equals '.dport'.
+ *      
+ *    .dport_reply = ...,  // 'reply' direction: Destination port. [NBO]
+ *                         // Used for NAT, otherwise equals '.sport'.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_UPDATE
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of an IPv4 conntrack.
  * @code{.c}
- *   fpp_ct_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_UPDATE,    // Update previously created conntrack
- *     .saddr = ...,                    // Source IPv4 address (network endian)
- *     .daddr = ...,                    // Destination IPv4 address (network endian)
- *     .sport = ...,                    // Source port (network endian)
- *     .dport = ...,                    // Destination port (network endian)
- *     .protocol = ...,                 // IP protocol ID
- *     .flags = CTCMD_FLAGS_TTL_DECREMENT, // Only TTL decrement can be updated
- *   };
+ *  .............................................  
+ *  fpp_ct_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *      
+ *    // Identification of the target conntrack.
+ *    .saddr = ...,     // 'orig' direction: Source IP address. [NBO]
+ *    .daddr = ...,     // 'orig' direction: Destination IP address. [NBO]
+ *    .sport = ...,     // 'orig' direction: Source port. [NBO]
+ *    .dport = ...,     // 'orig' direction: Destination port. [NBO]
+ *    .protocol = ...,  // IANA IP Protocol Number (protocol ID). [NBO]
+ *      
+ *    // Modification of the target conntrack.
+ *    .flags |= ntohs(CTCMD_FLAGS_TTL_DECREMENT)  // The only modification available: 
+ *                                                // set/unset TTL decrement flag.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV4_CONNTRACK, sizeof(fpp_ct_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of an IPv4 conntrack.
  * @code{.c}
- *   fpp_ct_cmd_t cmd_data =
- *   {
- *     .action = ...     // Either FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT
- *   };
+ *  .............................................  
+ *  fpp_ct_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_ct_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_IPV4_CONNTRACK,
+ *                  sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first IPv4 conntrack from 
+ *  //  the internal list of IPv4 conntracks.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_IPV4_CONNTRACK,
+ *                  sizeof(fpp_ct_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next IPv4 conntrack from 
+ *  //  the internal list of IPv4 conntracks.
+ *  .............................................  
  * @endcode
  *
- * Response data type for queries: @ref fpp_ct_cmd_t
- *
- * Response data provided:
- * @code{.c}
- *     rsp_data.saddr;         // Source IPv4 address (network endian)
- *     rsp_data.daddr;         // Destination IPv4 address (network endian)
- *     rsp_data.sport;         // Source port (network endian)
- *     rsp_data.dport;         // Destination port (network endian)
- *     rsp_data.saddr_reply;   // Reply source IPv4 address (network endian)
- *     rsp_data.daddr_reply;   // Reply destination IPv4 address (network endian)
- *     rsp_data.sport_reply;   // Reply source port (network endian)
- *     rsp_data.dport_reply;   // Reply destination port (network endian)
- *     rsp_data.protocol;      // IP protocol ID (17=UDP, 6=TCP, ...)
- * @endcode
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_CT_ENTRY_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the IPv4 conntrack query session (no more IPv4 conntracks).
+ *        - For other ACTIONs: Unknown (nonexistent) IPv4 conntrack was requested.
+ * - @c FPP_ERR_CT_ENTRY_ALREADY_REGISTERED <br>
+ *        Requested IPv4 conntrack already exists (is already registered).
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property (probably nonexistent route).
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_IPV4_CONNTRACK				0x0314
 
 /**
- * @brief Specifies FCI command for working with IPv6 tracked connections
- * @details This command can be used with various values of `.action`:
- *          - @c FPP_ACTION_REGISTER: Defines a connection and binds it to previously created route(s).
- *          - @c FPP_ACTION_DEREGISTER: Deletes previously defined connection.
- *          - @c FPP_ACTION_UPDATE: Updates properties of previously defined connection.
- *          - @c FPP_ACTION_QUERY: Gets parameters of existing connection. It creates a snapshot of all active
- *            conntrack entries and replies with first of them.
- *          - @c FPP_ACTION_QUERY_CONT: Shall be called periodically after @c FPP_ACTION_QUERY was called. On each
- *            call it replies with parameters of next connection. It returns @c FPP_ERR_CT_ENTRY_NOT_FOUND when no more
- *            entries exist.
- *
- * Command Argument Type: @ref fpp_ct6_cmd_t
+ * @def         FPP_CMD_IPV6_CONNTRACK
+ * @brief       FCI command for management of IPv6 conntracks.
+ * @details     Related topics: @ref l3_router
+ * @details     Related data types: @ref fpp_ct6_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new IPv6 conntrack and bind it to previously created route(s).
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing IPv6 conntrack.
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of IPv6 conntrack.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) IPv6 conntrack query session and get properties 
+ *                   of the first IPv6 conntrack from the internal list of IPv6 conntracks.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next IPv6 conntrack
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
  *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new IPv6 conntrack.
  * @code{.c}
- *   fpp_ct6_cmd_t cmd_data =
- *   {
- *     // Register new conntrack
- *     .action = FPP_ACTION_REGISTER,
- *     // Source IPv6 address, (network endian)
- *     .saddr[0..3] = ...,
- *     // Destination IPv6 address, (network endian)
- *     .daddr[0..3] = ...,
- *     // Source port (network endian)
- *     .sport = ...,
- *     // Destination port (network endian)
- *     .dport = ...,
- *     // Reply source IPv6 address (network endian). Used for NAT, otherwise equals .daddr
- *     .saddr_reply[0..3] = ...,
- *     // Reply destination IPv6 address (network endian). Used for NAT, otherwise equals .saddr
- *     .daddr_reply[0..3] = ...,
- *     // Reply source port (network endian). Used for NAT, otherwise equals .dport
- *     .sport_reply = ...,
- *     // Reply destination port (network endian). Used for NAT, otherwise equals .sport
- *     .dport_reply = ...,
- *     // IP protocol ID (17=UDP, 6=TCP, ...)
- *     .protocol = ...,
- *     // Bidirectional/Single direction (network endian)
- *     .flags = ...,
- *     // ID of route previously created with .FPP_CMD_IP_ROUTE command (network endian)
- *     .route_id = ...,
- *     // ID of reply route previously created with .FPP_CMD_IP_ROUTE command (network endian)
- *     .route_id_reply = ...,
- *     // VLAN tag in normal direction. If non-zero then it is added to routed traffic which
- *     // is untagged. If the routed traffic is tagged, then the outer tag will be replaced.
- *     .vlan = ...,
- *     // VLAN tag in reply direction. Same meaning as .vlan.
- *     .vlan_reply = ...
- *   };
+ *  .............................................  
+ *  fpp_ct6_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_REGISTER,  // Action
+ *      
+ *    .saddr = {...},         // 'orig' direction: Source IP address. [NBO]
+ *    .daddr = {...},         // 'orig' direction: Destination IP address. [NBO]
+ *    .sport =  ...,          // 'orig' direction: Source port. [NBO]
+ *    .dport =  ...,          // 'orig' direction: Destination port. [NBO]
+ *      
+ *    .saddr_reply = {...},   // 'reply' direction: Source IP address. [NBO]
+ *                            // Used for NAT, otherwise equals '.daddr'.
+ *      
+ *    .daddr_reply = {...},   // 'reply' direction: Destination IP address.
+ *                            // Used for NAT, otherwise equals '.saddr'.
+ *      
+ *    .sport_reply = ...,     // 'reply' direction: Source port. [NBO]
+ *                            // Used for NAT, otherwise equals '.dport'.
+ *      
+ *    .dport_reply = ...,     // 'reply' direction: Destination port. [NBO]
+ *                            // Used for NAT, otherwise equals '.sport'.
+ *      
+ *    .protocol = ...,        // IANA IP Protocol Number (protocol ID). [NBO]
+ *      
+ *    .flags = ...,           // Flags. A bitset. [NBO]
+ *      
+ *    .route_id = ...,        // 'orig' direction: ID of an associated route. [NBO]
+ *                            // See FPP_CMD_IP_ROUTE.
+ *      
+ *    .route_id_reply = ...,  // 'reply' direction: ID of an associated route. [NBO]
+ *                            // See FPP_CMD_IP_ROUTE.
+ *      
+ *    .vlan = ...,         // 'orig' direction: VLAN tag. [NBO]
+ *                         // If non-zero, then this VLAN tag is added to the routed packet.
+ *                         // If the packet already has a VLAN tag, then its tag is replaced.
+ *      
+ *    .vlan_reply = ...    // 'reply' direction: VLAN tag. [NBO]
+ *                         // If non-zero, then this VLAN tag is added to the routed packet.
+ *                         // If the packet already has a VLAN tag, then its tag is replaced.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
- *
+ * <b>orig and reply direction</b><br>
  * By default the connection is created as bi-directional. It means that two routing table entries
- * are created at once: one for standard flow given by .saddr, .daddr, .sport, .dport, and .protocol
- * and one for reverse flow defined by .saddr_reply, .daddr_reply, .sport_reply and .dport_reply. To
- * create uni-directional connection, either:
- * - set `.flags |= CTCMD_FLAGS_REP_DISABLED` and don't set @c route_id_reply, or
- * - set `.flags |= CTCMD_FLAGS_ORIG_DISABLED` and don't set @c route_id.
+ * are created at once:
+ *   - one for standard flow ('orig' direction), defined by `.protocol`, `.saddr`, `.daddr`, 
+ *     `.sport`, and `.dport`
+ *   - one for reverse flow ('reply' direction), defined by `.protocol`, `.saddr_reply`, `.daddr_reply`,
+ *     `.sport_reply` and `.dport_reply`.
+ * 
+ * To create an uni-directional connection (only one routing table entry), set one of these flags 
+ * (@b never both) when configuring a conntrack:
+ * - 'orig' direction only:  `.flags |= CTCMD_FLAGS_REP_DISABLED`, and @b don't set `.route_id_reply`.
+ * - 'reply' direction only: `.flags |= CTCMD_FLAGS_ORIG_DISABLED`, and @b don't set `.route_id`.
  *
- * To configure NAT-ed connection, set reply addresses and/or ports different than original
- * addresses and ports. To achieve NAPT (also called PAT), use @c daddr_reply, @c dport_reply,
- *  @c saddr_reply, and @c sport_reply:
- * -# `daddr_reply != saddr`: Source address of packets in original direction will be changed
- *    from @c saddr to @c daddr_reply. In case of bi-directional connection, destination address
- *    of packets in reply direction will be changed from @c daddr_reply to @c saddr.
- * -# `dport_reply != sport`: Source port of packets in original direction will be changed
- *    from @c sport to @c dport_reply. In case of bi-directional connection, destination port of
- *    packets in reply direction will be changed from @c dport_reply to @c sport.
- * -# `saddr_reply != daddr`: Destination address of packets in original direction will be changed
- *    from @c daddr to @c saddr_reply. In case of bi-directional connection, source address of
- *    packets in reply direction will be changed from @c saddr_reply to @c daddr.
- * -# `sport_reply != dport`: Destination port of packets in original direction will be changed
- *    from @c dport to @c sport_reply. In case of bi-directional connection, source port of packets
- *    in reply direction will be changed from @c sport_reply to @c dport.
+ * <b>NAT and NAPT/PAT</b><br>
+ * To configure NAT or NAPT/PAT connection, set 'reply' IP addresses and ports to different values
+ * than 'orig' IP addresses and ports.
+ * -# `.daddr_reply != .saddr`: Source address of packets in the 'orig' direction will be changed
+ *    from `.saddr` to `daddr_reply`. In case of a bi-directional connection, destination address
+ *    of packets in the 'reply' direction will be changed from `.daddr_reply` to `.saddr`.
+ * -# `.saddr_reply != .daddr`: Destination address of packets in the 'orig' direction will be changed
+ *    from `.daddr` to `.saddr_reply`. In case of a bi-directional connection, source address of
+ *    packets in the 'reply' direction will be changed from `.saddr_reply` to `.daddr`.
+ * -# `.dport_reply != .sport`: Source port of packets in the 'orig' direction will be changed
+ *    from `.sport` to `.dport_reply. In case of a bi-directional connection, destination port of
+ *    packets in the 'reply' direction will be changed from `.dport_reply` to `.sport`.
+ * -# `.sport_reply != .dport`: Destination port of packets in the 'orig' direction will be changed
+ *    from `.dport` to `.sport_reply`. In case of a bi-directional connection, source port of packets
+ *    in the 'reply' direction will be changed from `.sport_reply` to `.dport`.
  *
- * To disable port numbers check, just set both `.sport` and `.dport` to zero. This allows routing
- * using only IP addresses and protocol number.
+ * <b>Disable port checking</b><br>
+ * It is possible to leave out ports from matching process of a particular conntrack.
+ * To do so, configure the conntrack's `.sport` and `.dport` to zero.
+ * This allows routing based only on 3-tuple (protocol, source IP, destination IP).
  *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing IPv6 conntrack. 'Orig' properties are mandatory for this action.
+ * 'Reply' properties are optional.
  * @code{.c}
- *   fpp_ct6_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_DEREGISTER, // Deregister previously created conntrack
- *     .saddr[0..3] = ...,              // Source IPv6 address, (network endian)
- *     .daddr[0..3] = ...,              // Destination IPv6 address, (network endian)
- *     .sport = ...,                    // Source port (network endian)
- *     .dport = ...,                    // Destination port (network endian)
- *     .saddr_reply[0..3] = ...,        // Reply source IPv6 address (network endian)
- *     .daddr_reply[0..3] = ...,        // Reply destination IPv6 address (network endian)
- *     .sport_reply = ...,              // Reply source port (network endian)
- *     .dport_reply = ...,              // Reply destination port (network endian)
- *     .protocol = ...,                 // IP protocol ID
- *   };
+ *  .............................................  
+ *  fpp_ct6_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *      
+ *    // Identification of the target conntrack.
+ *    .saddr = {...},        // 'orig' direction: Source IP address. [NBO]
+ *    .daddr = {...},        // 'orig' direction: Destination IP address. [NBO]
+ *    .sport =  ...,         // 'orig' direction: Source port. [NBO]
+ *    .dport =  ...          // 'orig' direction: Destination port. [NBO]
+ *    .protocol = ...,       // IANA IP Protocol Number (protocol ID). [NBO]
+ *      
+ *    .saddr_reply = {...},  // 'reply' direction: Source IP address. [NBO]
+ *                           // Used for NAT, otherwise equals '.daddr'.
+ *      
+ *    .daddr_reply = {...},  // 'reply' direction: Destination IP address.
+ *                           // Used for NAT, otherwise equals '.saddr'.
+ *      
+ *    .sport_reply = ...,    // 'reply' direction: Source port. [NBO]
+ *                           // Used for NAT, otherwise equals '.dport'.
+ *      
+ *    .dport_reply = ...,    // 'reply' direction: Destination port. [NBO]
+ *                           // Used for NAT, otherwise equals '.sport'.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_UPDATE
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of an IPv6 conntrack.
  * @code{.c}
- *   fpp_ct_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_UPDATE,     // Update previously created conntrack
- *     .saddr[0..3] = ...,              // Source IPv6 address, (network endian)
- *     .daddr[0..3] = ...,              // Destination IPv6 address, (network endian)
- *     .sport = ...,                    // Source port (network endian)
- *     .dport = ...,                    // Destination port (network endian)
- *     .protocol = ...,                 // IP protocol ID
- *     .flags = CTCMD_FLAGS_TTL_DECREMENT, // Only TTL decrement can be updated
- *   };
+ *  .............................................  
+ *  fpp_ct6_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *      
+ *    // Identification of the target conntrack.
+ *    .saddr = {...},   // 'orig' direction: Source IP address. [NBO]
+ *    .daddr = {...},   // 'orig' direction: Destination IP address. [NBO]
+ *    .sport =  ...,    // 'orig' direction: Source port. [NBO]
+ *    .dport =  ...,    // 'orig' direction: Destination port. [NBO]
+ *    .protocol = ...,  // IANA IP Protocol Number (protocol ID). [NBO]
+ *      
+ *    // Modification of the target conntrack.
+ *    .flags |= ntohs(CTCMD_FLAGS_TTL_DECREMENT)  // The only modification available: 
+ *                                                // set/unset TTL decrement flag.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV6_CONNTRACK, sizeof(fpp_ct6_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of an IPv6 conntrack.
  * @code{.c}
- *   fpp_ct6_cmd_t cmd_data =
- *   {
- *     .action = ...     // Either FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT
- *   };
+ *  .............................................  
+ *  fpp_ct6_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_ct6_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_IPV6_CONNTRACK,
+ *                  sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first IPv6 conntrack from 
+ *  //  the internal list of IPv6 conntracks.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_IPV6_CONNTRACK,
+ *                  sizeof(fpp_ct6_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next IPv6 conntrack from 
+ *  //  the internal list of IPv6 conntracks.
+ *  .............................................  
  * @endcode
  *
- * Response data type for queries: @ref fpp_ct6_cmd_t
- *
- * Response data provided (all values in network byte order):
- * @code{.c}
- *     rsp_data.saddr;         // Source IPv6 address (network endian)
- *     rsp_data.daddr;         // Destination IPv6 address (network endian)
- *     rsp_data.sport;         // Source port (network endian)
- *     rsp_data.dport;         // Destination port (network endian)
- *     rsp_data.saddr_reply;   // Reply source IPv6 address (network endian)
- *     rsp_data.daddr_reply;   // Reply destination IPv6 address (network endian)
- *     rsp_data.sport_reply;   // Reply source port (network endian)
- *     rsp_data.dport_reply;   // Reply destination port (network endian)
- *     rsp_data.protocol;      // IP protocol ID (17=UDP, 6=TCP, ...)
- * @endcode
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_CT_ENTRY_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the IPv6 conntrack query session (no more IPv6 conntracks).
+ *        - For other ACTIONs: Unknown (nonexistent) IPv6 conntrack was requested.
+ * - @c FPP_ERR_CT_ENTRY_ALREADY_REGISTERED <br>
+ *        Requested IPv6 conntrack already exists (is already registered).
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property (probably nonexistent route).
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_IPV6_CONNTRACK          		0x0414
 
 /**
- * @brief       Data structure used in various functions for conntrack management
- * @details     It can be used:
- *              - for command buffer in functions @ref fci_write, @ref fci_query or
- *                @ref fci_cmd, with @ref FPP_CMD_IPV4_CONNTRACK command.
+ * @brief       Data structure for IPv4 conntrack.
+ * @details     Related FCI commands: @ref FPP_CMD_IPV4_CONNTRACK, @ref FPP_CMD_IP_ROUTE
+ * @details     See @ref l3_router for detailed explanation how to create conntracks.
+ *
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp.h  fpp_ct_cmd_t
  */
+/* [fpp_ct_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4) {
-	uint16_t action;			/**< Action to perform */
-	uint16_t rsvd0;
-	uint32_t saddr;				/**< Source IP address */
-	uint32_t daddr;				/**< Destination IP address */
-	uint16_t sport;				/**< Source port */
-	uint16_t dport;				/**< Destination port */
-	uint32_t saddr_reply;		/**< Source IP address in 'reply' direction */
-	uint32_t daddr_reply;		/**< Destination IP address in 'reply' direction */
-	uint16_t sport_reply;		/**< Source port in 'reply' direction */
-	uint16_t dport_reply;		/**< Destination port in 'reply' direction */
-	uint16_t protocol;			/**< Protocol ID: TCP, UDP */
-	uint16_t flags;				/**< Flags. See @ref FPP_CMD_IPV4_CONNTRACK. */
-	uint32_t fwmark;
-	uint32_t route_id;			/**< Associated route ID. See @ref FPP_CMD_IP_ROUTE. */
-	uint32_t route_id_reply;	/**< Route for 'reply' direction. Applicable only for bi-directional connections. */
-	uint16_t vlan;				/**< VLAN tag. If non-zero, then it will be added to the routed packet. */
-	uint16_t vlan_reply;		/**< VLAN tag in reply direction. If non-zero, then it will be added to the routed packet. */
+    uint16_t action;          /*< Action */
+    uint16_t rsvd0;           /*< RESERVED (do not use) */
+    
+    uint32_t saddr;           /*< 'orig' direction: Source IP address. [NBO] */
+    uint32_t daddr;           /*< 'orig' direction: Destination IP address. [NBO] */
+    uint16_t sport;           /*< 'orig' direction: Source port. [NBO] */
+    uint16_t dport;           /*< 'orig' direction: Destination port. [NBO] */
+    
+    uint32_t saddr_reply;     /*< 'reply' direction: Source IP address. [NBO] 
+                                   Used for NAT, otherwise equals '.daddr'. */
+    
+    uint32_t daddr_reply;     /*< 'reply' direction: Destination IP address. [NBO]
+                                   Used for NAT, otherwise equals '.saddr'. */
+    
+    uint16_t sport_reply;     /*< 'reply' direction: Source port. [NBO]
+                                   Used for NAT, otherwise equals '.dport'. */
+    
+    uint16_t dport_reply;     /*< 'reply' direction: Destination port. [NBO] 
+                                   Used for NAT, otherwise equals '.sport'. */
+    
+    uint16_t protocol;        /*< IANA IP Protocol Number (protocol ID). [NBO] */
+    uint16_t flags;           /*< Flags. A bitset. [NBO]. See FPP_CMD_IPV4_CONNTRACK. */
+    uint32_t fwmark;          /*< RESERVED (do not use) */
+    
+    uint32_t route_id;        /*< 'orig' direction: ID of an associated route. [NBO]
+                                  See FPP_CMD_IP_ROUTE. */
+    
+    uint32_t route_id_reply;  /*< 'reply' direction: ID of an associated route. [NBO]
+                                  See FPP_CMD_IP_ROUTE. */
+    
+    uint16_t vlan;            /*< 'orig' direction: VLAN tag. [NBO]
+                                  If non-zero, then this VLAN tag is added to the routed
+                                  packet. If the packet already has a VLAN tag, then its tag
+                                  is replaced. */
+    
+    uint16_t vlan_reply;      /*< 'reply' direction: VLAN tag. [NBO]
+                                  If non-zero, then this VLAN tag is added to the routed
+                                  packet. If the packet already has a VLAN tag, then its tag
+                                  is replaced. */
 } fpp_ct_cmd_t;
+/* [fpp_ct_cmd_t] */
 
 typedef struct CAL_PACKED {
 	uint16_t action;                       /*Action to perform*/
@@ -560,30 +735,57 @@ typedef struct CAL_PACKED {
 } fpp_ct_ex_cmd_t;
 
 /**
- * @brief       Data structure used in various functions for IPv6 conntrack management
- * @details     It can be used:
- *              - for command buffer in functions @ref fci_write, @ref fci_query or
- *                @ref fci_cmd, with @ref FPP_CMD_IPV6_CONNTRACK command.
+ * @brief       Data structure for IPv6 conntrack.
+ * @details     Related FCI commands: @ref FPP_CMD_IPV6_CONNTRACK, @ref FPP_CMD_IP_ROUTE
+ * @details     See @ref l3_router for detailed explanation how to create conntracks.
+ *
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp.h  fpp_ct6_cmd_t
  */
+/* [fpp_ct6_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4) {
-	uint16_t action;			/**< Action to perform */
-	uint16_t rsvd1;
-	uint32_t saddr[4];			/**< Source IP address */
-	uint32_t daddr[4];			/**< Destination IP address */
-	uint16_t sport;				/**< Source port */
-	uint16_t dport;				/**< Destination port */
-	uint32_t saddr_reply[4];	/**< Source IP address in 'reply' direction */
-	uint32_t daddr_reply[4];	/**< Destination IP address in 'reply' direction */
-	uint16_t sport_reply;		/**< Source port in 'reply' direction */
-	uint16_t dport_reply;		/**< Destination port in 'reply' direction */
-	uint16_t protocol;			/**< Protocol ID: TCP, UDP */
-	uint16_t flags;				/**< Flags. See @ref FPP_CMD_IPV6_CONNTRACK. */
-	uint32_t fwmark;
-	uint32_t route_id;			/**< Associated route ID. See @ref FPP_CMD_IP_ROUTE. */
-	uint32_t route_id_reply;	/**< Route for 'reply' direction. Applicable only for bi-directional connections. */
-	uint16_t vlan;				/**< VLAN tag. If non-zero, then it will be added to the routed packet. */
-	uint16_t vlan_reply;		/**< VLAN tag in reply direction. If non-zero, then it will be added to the routed packet. */
+    uint16_t action;          /*< Action */
+    uint16_t rsvd1;           /*< RESERVED (do not use) */
+    
+    uint32_t saddr[4];        /*< 'orig' direction: Source IP address. [NBO] */
+    uint32_t daddr[4];        /*< 'orig' direction: Destination IP address. [NBO] */
+    uint16_t sport;           /*< 'orig' direction: Source port. [NBO] */
+    uint16_t dport;           /*< 'orig' direction: Destination port. [NBO] */
+    
+    uint32_t saddr_reply[4];  /*< 'reply' direction: Source IP address. [NBO] 
+                                   Used for NAT, otherwise equals '.daddr'. */
+    
+    uint32_t daddr_reply[4];  /*< 'reply' direction: Destination IP address. [NBO]
+                                   Used for NAT, otherwise equals '.saddr'. */
+    
+    uint16_t sport_reply;     /*< 'reply' direction: Source port. [NBO]
+                                   Used for NAT, otherwise equals '.dport'. */
+    
+    uint16_t dport_reply;     /*< 'reply' direction: Destination port. [NBO] 
+                                   Used for NAT, otherwise equals '.sport'. */
+    
+    uint16_t protocol;        /*< IANA IP Protocol Number (protocol ID). [NBO] */
+    uint16_t flags;           /*< Flags. A bitset. [NBO. See FPP_CMD_IPV4_CONNTRACK. */
+    uint32_t fwmark;          /*< RESERVED (do not use) */
+    
+    uint32_t route_id;        /*< 'orig' direction: ID of an associated route. [NBO]
+                                  See FPP_CMD_IP_ROUTE. */
+    
+    uint32_t route_id_reply;  /*< 'reply' direction: ID of an associated route. [NBO]
+                                  See FPP_CMD_IP_ROUTE. */
+    
+    uint16_t vlan;            /*< 'orig' direction: VLAN tag. [NBO]
+                                  If non-zero, then this VLAN tag is added to the routed
+                                  packet. If the packet already has a VLAN tag, then its tag
+                                  is replaced. */
+    
+    uint16_t vlan_reply;      /*< 'reply' direction: VLAN tag. [NBO]
+                                  If non-zero, then this VLAN tag is added to the routed
+                                  packet. If the packet already has a VLAN tag, then its tag
+                                  is replaced. */
 } fpp_ct6_cmd_t;
+/* [fpp_ct6_cmd_t] */
 
 typedef struct CAL_PACKED {
 	uint16_t action;                       /*Action to perform*/
@@ -611,81 +813,144 @@ typedef struct CAL_PACKED {
 	uint32_t tunnel_route_id_reply;
 } fpp_ct6_ex_cmd_t;
 
+/** @}*/
+
 /*--------------------------------------- IP ---------------------------------*/ 
 #define FPP_ERR_RT_ENTRY_ALREADY_REGISTERED		200
 #define FPP_ERR_RT_ENTRY_NOT_FOUND			201
 
 /**
- * @brief Specifies FCI command for working with routes
- * @details Routes are representing direction where matching traffic shall be forwarded to. Every
- * 			route specifies egress physical interface and MAC address of next network node.
- *          This command can be used with various values of `.action`:
- *          - @c FPP_ACTION_REGISTER: Defines a new route.
- *          - @c FPP_ACTION_DEREGISTER: Deletes previously defined route.
- *          - @c FPP_ACTION_QUERY: Gets parameters of existing routes. It creates a snapshot of all active
- *            route entries and replies with first of them.
- *          - @c FPP_ACTION_QUERY_CONT: Shall be called periodically after @c FPP_ACTION_QUERY was called. On each
- *            call it replies with parameters of next route. It returns @c FPP_ERR_RT_ENTRY_NOT_FOUND when no more
- *            entries exist.
- *
- * Command Argument Type: @ref fpp_rt_cmd_t
+ * @addtogroup  dxgrLibFCI
+ * @{
+ */
+
+/**
+ * @def         FPP_CMD_IP_ROUTE
+ * @brief       FCI command for management of IP routes.
+ * @details     Related topics: @ref l3_router
+ * @details     Related data types: @ref fpp_rt_cmd_t
+ * @details     In the context of PFE, a route represents a direction where the matching 
+ *              traffic shall be forwarded to. Every route specifies an egress physical interface
+ *              and a MAC address of the next network node.
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new route.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing route.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) a route query session and get properties 
+ *                   of the first route from the internal collective list of all routes
+ *                   (regardless of IP type nor conntrack affiliation).
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next route
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
  *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new route. For detailed info about route properties, see fpp_rt_cmd_t.
  * @code{.c}
- *   fpp_rt_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_REGISTER, // Register new route
- *     .src_mac = ...,                // Source MAC address (network endian). 
- *                                    // If left unset (all-zero), then MAC of the egress interface is used.
- *     .dst_mac = ...,                // Destination MAC address (network endian)
- *     .output_device = ...,          // Name of egress interface (name of physical interface)
- *     .id = ...                      // Chosen number will be used as unique route identifier (network endian)
- *     .flags = ...,                  // 1 for IPv4 addressing, 2 for IPv6 (network endian)
- *   };
+ *  .............................................  
+ *  fpp_rt_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_REGISTER,  // Action
+ *    .src_mac = ...,                  // Source MAC address.
+ *    .dst_mac = ...,                  // Destination MAC address.
+ *    .output_device = ...,            // Name of the egress physical interface.
+ *    .id    = ...,                    // Route ID. [NBO]. User-defined.
+ *    .flags = ...                     // Flags. [NBO]. 1 for IPv4 routes, 2 for IPv6 routes.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
+ *                                           (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing route.
  * @code{.c}
- *   fpp_rt_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_DEREGISTER, // Deregister a route
- *     .id = ...                        // Unique route identifier (network endian)
- *   };
+ *  .............................................  
+ *  fpp_rt_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *    .id     = ...                     // Route ID. [NBO]. User-defined.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IP_ROUTE, sizeof(fpp_rt_cmd_t), 
+ *                                           (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of a route.
  * @code{.c}
- *   fpp_rt_cmd_t cmd_data =
- *   {
- *     .action = ...     // Either FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT
- *   };
- * @endcode
+ *  .............................................  
+ *  fpp_rt_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_rt_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_IP_ROUTE,
+ *                  sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first route from 
+ *  //  the internal collective list of all routes.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_IP_ROUTE,
+ *                  sizeof(fpp_rt_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next route from 
+ *  //  the internal collective list of all routes.
+ *  .............................................  
+ * @endcode 
  *
- * Response data provided (@ref fpp_rt_cmd_t):
- * @code{.c}
- *     rsp_data.src_mac;        // Source MAC address
- *     rsp_data.dst_mac;        // Destination MAC address
- *     rsp_data.output_device;  // Output device name
- *     rsp_data.id;             // Route ID (network endian)
- *     srp_data.flags;          // Flags (network endian)
- * @endcode
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_RT_ENTRY_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the route query session (no more routes).
+ *        - For other ACTIONs: Unknown (nonexistent) route was requested.
+ * - @c FPP_ERR_RT_ENTRY_ALREADY_REGISTERED <br>
+ *        Requested route already exists (is already registered).
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_IP_ROUTE			0x0313
 
 /**
- * @brief Specifies FCI command that clears all IPv4 routes (see @ref FPP_CMD_IP_ROUTE)
- *        and conntracks (see @ref FPP_CMD_IPV4_CONNTRACK)
- * @details This command uses no arguments.
+ * @def         FPP_CMD_IPV4_RESET
+ * @brief       FCI command to remove all IPv4 routes and conntracks. 
+ * @details     Related topics: @ref l3_router, @ref FPP_CMD_IP_ROUTE, <br> @ref FPP_CMD_IPV4_CONNTRACK
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV4_RESET, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * Command Argument Type: none (cmd_buf = NULL; cmd_len = 0;)
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
@@ -693,38 +958,64 @@ typedef struct CAL_PACKED {
 #define FPP_CMD_IP_ROUTE_CHANGE			0x0318
 
 /**
- * @brief Specifies FCI command that clears all IPv6 routes (see @ref FPP_CMD_IP_ROUTE)
- *        and conntracks (see @ref FPP_CMD_IPV6_CONNTRACK)
- * @details This command uses no arguments.
+ * @def         FPP_CMD_IPV6_RESET
+ * @brief       FCI command to remove all IPv6 routes and conntracks. 
+ * @details     Related topics: @ref l3_router, @ref FPP_CMD_IP_ROUTE, <br> @ref FPP_CMD_IPV6_CONNTRACK
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV6_RESET, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * Command Argument Type: none (cmd_buf = NULL; cmd_len = 0;)
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_IPV6_RESET				0x0416
 
 /**
- * @brief       Structure representing the command to add or remove a route
- * @details     Data structure to be used for command buffer for route commands. It
- * 				can be used:
- *              - as command buffer in functions @ref fci_write, @ref fci_query or
- *                @ref fci_cmd, with @ref FPP_CMD_IP_ROUTE command.
- *              - as reply buffer in functions @ref fci_query or @ref fci_cmd,
- *                with @ref FPP_CMD_IP_ROUTE command.
+ * @brief       Data structure for a route.
+ * @details     Related FCI commands: @ref FPP_CMD_IP_ROUTE
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp.h  fpp_rt_cmd_t
  */
+/* [fpp_rt_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4) {
-	uint16_t action;					/**< Action to perform */
-	uint16_t mtu;
-	uint8_t src_mac[6];					/**< Source MAC address (network endian) */
-	uint8_t dst_mac[6];					/**< Destination MAC address (network endian) */
-	uint16_t pad;						
-	char	  output_device[IFNAMSIZ];	/**< Name of egress physical interface */
-	char	  input_device[IFNAMSIZ];
-	char	  underlying_input_device[IFNAMSIZ];
-	uint32_t id;						/**< Unique route identifier */
-	uint32_t flags;						/**< Flags (network endian). 1 for IPv4 route, 2 for IPv6. */
-	uint32_t dst_addr[4];
+    uint16_t action;        /*< Action */
+    uint16_t mtu;           /*< RESERVED (do not use) */
+    
+    uint8_t src_mac[6];     /*< Source MAC address. When a packet is routed, this address 
+                                is set as the source MAC address of the packet. If left
+                                unset (all-zero), then PFE automatically uses MAC address
+                                of the associated physical interface (.output_device). */
+    
+    uint8_t dst_mac[6];     /*< Destination MAC address. When a packet is routed, this address
+                                is set as the destination MAC address of the packet. */
+    
+    uint16_t pad;           /*< RESERVED (do not use) */
+    
+    char output_device[IFNAMSIZ];   /*< Name of the egress physical interface. 
+                                        When a packet is routed, it is egressed
+                                        through this physical interface. */
+    
+    char input_device[IFNAMSIZ];            /*< RESERVED (do not use) */
+    char underlying_input_device[IFNAMSIZ]; /*< RESERVED (do not use) */
+    
+    uint32_t id;            /*< Route ID. [NBO]. Unique route identifier. */
+    uint32_t flags;         /*< Flags. [NBO]. 1 for IPv4 routes, 2 for IPv6 routes. */
+    
+    uint32_t dst_addr[4];   /*< RESERVED (do not use) */
 } fpp_rt_cmd_t;
+/* [fpp_rt_cmd_t] */
 
 #define FPP_IP_ROUTE_6o4	(1<<0)
 #define FPP_IP_ROUTE_4o6	(1<<1)
@@ -735,6 +1026,8 @@ typedef struct {
 	uint16_t rsvd;
 } __attribute__((__packed__)) fpp_ipsec_cmd_t;
 
+/** @}*/
+
 /* ----------------------------------- RTP ----------------------------------*/
 #define FPP_ERR_RTP_STATS_MAX_ENTRIES			1230
 #define FPP_ERR_RTP_STATS_STREAMID_ALREADY_USED	1231
@@ -1956,34 +2249,56 @@ typedef struct {
 #endif
 
 /*--------------------------------- Timeout ---------------------------------*/
+
+/**
+ * @addtogroup  dxgrLibFCI
+ * @{
+ */
+
 /**
- * @brief Specifies FCI command for setting timeouts of conntracks
- * @details This command sets timeout for conntracks based on protocol. Three kinds
- * of protocols are distinguished: TCP, UDP and others. For each of them timeout can
- * be set independently. For UDP it is possible to set different value for bidirectional
- * and single-directional connection. Default timeout value is 5 days for TCP, 300s for
- * UDP and 240s for others.
+ * @def         FPP_CMD_IPV4_SET_TIMEOUT
+ * @brief       FCI command for configuration of conntrack timeouts.
+ * @details     Related topics: @ref l3_router
+ * @details     Related data types: @ref fpp_timeout_cmd_t
+ * @details     @ref FPP_CMD_IPV4_SET_TIMEOUT sets default timeout for @b both @ref FPP_CMD_IPV4_CONNTRACK 
+ *              and @ref FPP_CMD_IPV6_CONNTRACK.
+ * @details     This command allows for configuration of conntrack default timeout periods. 
+ *              Three protocol groups are distinguished: `TCP (6)`, `UDP (17)` and `others` 
+ *              (all other protocols; usually represented by 0).
+ *              Timeout can be set independently for each of these groups.
+ * @details     Factory-default timeout values are:
+ *                - 5 days for `TCP`
+ *                - 300 seconds for `UDP`
+ *                - 240 seconds for `others`
+ * @details     If these timeouts are updated (changed), then all newly created conntracks 
+ *              are created with updated timeout values. Conntracks which were created before 
+ *              the change have their timeout updated with the first received packet after the change.
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  fpp_timeout_cmd_t cmd_to_fci = 
+ *  {
+ *    .protocol = ...,       // IP Protocol Number (protocol ID). [NBO]
+ *                           // The only accepted values are 6 (TCP), 17 (UDP) or 0 (others).
+ *    
+ *    .timeout_value1 = ...  // Timeout value in seconds. [NBO]
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IPV4_SET_TIMEOUT, sizeof(fpp_timeout_cmd_t), 
+ *                                                   (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Newly created connections are being created with new timeout values already set.
- * Previously created connections have their timeout updated with first received packet.
  *
- * Command Argument Type: @ref fpp_timeout_cmd_t
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_timeout_cmd_t cmd_data =
- *   {
- *     // IP protocol to be affected. Either 17 for UDP, 6 for TCP or 0 for others.
- *     .protocol;
- *     // Use 0 for normal connections, 1 for 4over6 IP tunnel connections.
- *     .sam_4o6_timeout;
- *     // Timeout value in seconds.
- *     .timeout_value1;
- *     // Optional timeout value which is valid only for UDP connections. If the value is set
- *     // (non zero), then it affects unidirectional UDP connections only.
- *     .timeout_value2;
- *   };
- * @endcode
  * @hideinitializer
  */
 #define FPP_CMD_IPV4_SET_TIMEOUT	0x0319
@@ -1994,23 +2309,34 @@ typedef struct {
 #define FPP_CMD_IPV6_FRAGTIMEOUT	0x0433
 
 /**
- * @brief       Timeout command argument
- * @details     Data structure to be used for command buffer for timeout settings. It can be used:
- *              - for command buffer in functions @ref fci_write, @ref fci_query or
- *                @ref fci_cmd, with @ref FPP_CMD_IPV4_SET_TIMEOUT command.
+ * @brief       Data structure for conntrack timeout setting.
+ * @details     Related FCI commands: @ref FPP_CMD_IPV4_SET_TIMEOUT
+ * @details     @ref FPP_CMD_IPV4_SET_TIMEOUT sets timeout for @b both @ref FPP_CMD_IPV4_CONNTRACK 
+ *              and @ref FPP_CMD_IPV6_CONNTRACK.
+ *
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp.h  fpp_timeout_cmd_t
  */
+/* [fpp_timeout_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4) {
-	uint16_t	protocol;
-	uint16_t	sam_4o6_timeout;
-	uint32_t	timeout_value1;
-	uint32_t	timeout_value2;
+    uint16_t    protocol;         /*< IP Protocol Number (protocol ID). [NBO]
+                                      The only accepted values are 6 (TCP), 17 (UDP) or
+                                      0 (others). */
+    
+    uint16_t    sam_4o6_timeout;  /*< RESERVED (do not use) */
+    uint32_t    timeout_value1;   /*< Timeout value in seconds. [NBO] */
+    uint32_t    timeout_value2;   /*< RESERVED (do not use) */
 } fpp_timeout_cmd_t;
+/* [fpp_timeout_cmd_t] */
 
 typedef struct {
 	uint16_t	timeout;
 	uint16_t	mode;
 } __attribute__((__packed__)) fpp_frag_timeout_cmd_t;
 
+/** @}*/
+
 /*---------------------------------------PKTCAP---------------------------------*/
 #define FPP_CMD_PKTCAP_IFSTATUS				0x0d02
 #define FPP_CMD_PKTCAP_FLF                              0x0d03
diff --git a/sw/xfci/libfci/public/fpp_ext.h b/sw/xfci/libfci/public/fpp_ext.h
index 753633b..9be8ee2 100644
--- a/sw/xfci/libfci/public/fpp_ext.h
+++ b/sw/xfci/libfci/public/fpp_ext.h
@@ -34,215 +34,340 @@
 #define FPP_ERR_INTERNAL_FAILURE				0xffff
 
 /**
- * @def FPP_CMD_PHY_IF
- * @brief FCI command for working with physical interfaces.
- * @note Command is defined as extension of the legacy fpp.h.
- * @details Interfaces are needed to be known to FCI to support insertion of routes and conntracks.
- *          Command can be used to get operation mode, mac address and operation flags (enabled, promisc).
- * @details Command can be used with various `.action` values:
- *          - @c FPP_ACTION_UPDATE: Updates properties of an existing physical interface.
- *          - @c FPP_ACTION_QUERY: Gets head of list of existing physical interfaces properties.
- *          - @c FPP_ACTION_QUERY_CONT: Gets next item from list of existing physical interfaces. Shall
- * 				be called after @ref FPP_ACTION_QUERY was called. On each call it replies with properties
- *              of the next interface in the list.
- *
- * @note Precondition to use the query is to atomically lock the access with @ref FPP_CMD_IF_LOCK_SESSION.
- *
- * Command Argument Type: @ref fpp_phy_if_cmd_t
- *
- * Action FPP_ACTION_UPDATE
- * --------------------------
- * Update interface properties. Set fpp_phy_if_cmd_t.action to @ref FPP_ACTION_UPDATE and fpp_phy_if_cmd_t.name
- * to name of the desired interface to be updated. Rest of the fpp_phy_if_cmd_t members will be considered
- * to be used as the new interface properties. It is recommended to use read-modify-write approach in
- * combination with @ref FPP_ACTION_QUERY and @ref FPP_ACTION_QUERY_CONT.
- *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Get interface properties. Set fpp_phy_if_cmd_t.action to @ref FPP_ACTION_QUERY to get first interface from
- * the list of physical interfaces or @ref FPP_ACTION_QUERY_CONT to get subsequent entries. Response data
- * type for query commands is of type @ref fpp_phy_if_cmd_t.
- *
- * For operation modes see @ref fpp_phy_if_op_mode_t. For operation flags see @ref fpp_if_flags_t.
+ * @def         FPP_CMD_PHY_IF
+ * @brief       FCI command for management of physical interfaces.
+ * @details     Related topics: @ref mgmt_phyif
+ * @details     Related data types: @ref fpp_phy_if_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of a physical interface.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) a physical interface query session and get properties 
+ *                   of the first physical interface from the internal list of physical interfaces.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next physical interface 
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
+ *
+ * @note
+ * All operations with physical interfaces require exclusive lock of the interface database.
+ * See @ref FPP_CMD_IF_LOCK_SESSION.
+ *
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of a physical interface. It is recommended to use the read-modify-write
+ * approach (see @ref mgmt_phyif). Some properties cannot be modified (see fpp_phy_if_cmd_t).
+ * @code{.c}
+ *  .............................................  
+ *  fpp_phy_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *    .name   = "...",              // Interface name (see chapter Physical Interface)
+ *    
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_phy_if_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_PHY_IF, sizeof(fpp_phy_if_cmd_t), 
+ *                                         (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Success.
- *     - @c FPP_ERR_IF_ENTRY_NOT_FOUND: Last entry in the query session.
- *     - @c FPP_ERR_IF_WRONG_SESSION_ID: Someone else is already working with the interfaces.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of a physical interface.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_phy_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_phy_if_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_PHY_IF,
+ *                  sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first physical interface from 
+ *  //  the internal list of physical interfaces.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_PHY_IF,
+ *                  sizeof(fpp_phy_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next physical interface from 
+ *  //  the internal list of physical interfaces.
+ *  .............................................  
+ * @endcode   
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_IF_ENTRY_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the physical interface query session (no more interfaces).
+ *        - For other ACTIONs: Unknown (nonexistent) physical interface was requested.
+ * - @c FPP_ERR_IF_WRONG_SESSION_ID <br>
+ *        Some other client has the interface database locked for exclusive access.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_PHY_IF					0xf100
 
 /**
- * @def FPP_CMD_LOG_IF
- * @brief FCI command for working with logical interfaces
- * @note    Command is defined as extension of the legacy fpp.h.
- * @details Command can be used to update match rules of logical interface or for adding egress interfaces.
- *          It can also update operational flags (enabled, promisc, match).
- *          Following values of `.action` are supported:
- *          - @c FPP_ACTION_REGISTER: Creates a new logical interface.
- *          - @c FPP_ACTION_DEREGISTER: Destroys an existing logical interface.
- *          - @c FPP_ACTION_UPDATE: Updates properties of an existing logical interface.
- *          - @c FPP_ACTION_QUERY: Gets head of list of existing logical interfaces parameters.
- *          - @c FPP_ACTION_QUERY_CONT: Gets next item from list of existing logical interfaces. Shall
- *            be called after @ref FPP_ACTION_QUERY was called. On each call it replies with properties
- *            of the next interface.
- *
- * Precondition to use the query is to atomic lock the access with @ref FPP_CMD_IF_LOCK_SESSION.
- *
- * Command Argument Type: @ref fpp_log_if_cmd_t
- *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * To create a new logical interface the @ref FPP_CMD_LOG_IF command expects following values to be set
- * in the command argument structure:
+ * @def         FPP_CMD_LOG_IF
+ * @brief       FCI command for management of logical interfaces.
+ * @details     Related topics: @ref mgmt_logif
+ * @details     Related data types: @ref fpp_log_if_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new logical interface.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing logical interface.
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of a logical interface.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) a logical interface query session and get properties 
+ *                   of the first logical interface from the internal collective list of all 
+ *                   logical interfaces (regardless of physical interface affiliation).
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next logical interface 
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
+ *
+ * @note
+ * All operations with logical interfaces require exclusive lock of the interface database.
+ * See @ref FPP_CMD_IF_LOCK_SESSION.
+ *
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new logical interface. The newly created interface is by default disabled and 
+ * without any configuration. For configuration, see the following FPP_ACTION_UPDATE.
  * @code{.c}
- *   fpp_log_if_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_REGISTER,   // Register new logical interface
- *     .name = "logif1",                // Name of the new logical interface
- *     .parent_name = "emac0"           // Name of the parent physical interface
- *   };
+ *  .............................................  
+ *  fpp_log_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action      = FPP_ACTION_REGISTER,  // Action
+ *    .name        = "...",                // Interface name (user-defined)
+ *    .parent_name = "..."                 // Parent physical interface name
+ *                                         // (see chapter Physical Interface)
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+ *                                         (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
- * The interface <i>logif1</i> will be created as child of <i>emac0</i> without any configuration
- * and disabled. Names of available physical interfaces can be obtained via @ref FPP_CMD_PHY_IF +
- * @ref FPP_ACTION_QUERY + @ref FPP_ACTION_QUERY_CONT.
+ * @warning Do not create multiple logical interfaces with the same name.
  *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * Items to be set in command argument structure to remove a logical interface:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing logical interface.
  * @code{.c}
- *   fpp_log_if_cmd_t cmd_data =
- *   {
- *     .action = FPP_ACTION_DEREGISTER,   // Destroy an existing logical interface
- *     .name = "logif1",                  // Name of the logical interface to destroy
- *   };
+ *  .............................................  
+ *  fpp_log_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *    .name   = "..."                   // Name of an existing logical interface.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+ *                                         (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_UPDATE
- * ------------------------
- * To update logical interface properties just set fpp_log_if_cmd_t.action to @ref FPP_ACTION_UPDATE and
- * fpp_log_if_cmd_t.name to the name of logical interface which you wish to update. Rest of the
- * fpp_log_if_cmd_t structure members will be considered to be used as the new interface properties. It
- * is recommended to use read-modify-write approach in combination with @ref FPP_ACTION_QUERY and @ref
- * FPP_ACTION_QUERY_CONT.
- *
- * For match rules see (@ref fpp_if_m_rules_t). For match rules arguments see (@ref fpp_if_m_args_t).
- *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Update successful.
- *     - @c FPP_ERR_IF_ENTRY_NOT_FOUND: If corresponding logical interface doesn't exit.
- *     - @c FPP_ERR_IF_RESOURCE_ALREADY_LOCKED: Someone else is already configuring the interfaces.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Get interface properties. Set fpp_log_if_cmd_t.action to @ref FPP_ACTION_QUERY to get first interface
- * from the list of all logical interfaces or @ref FPP_ACTION_QUERY_CONT to get subsequent entries.
- * Response data type for query commands is of type fpp_log_if_cmd_t.
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of a logical interface. It is recommended to use the read-modify-write
+ * approach (see @ref mgmt_logif). Some properties cannot be modified (see fpp_log_if_cmd_t).
+ * @code{.c}
+ *  .............................................  
+ *  fpp_log_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *    .name   = "...",              // Name of an existing logical interface.
+ *    
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_log_if_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_LOG_IF, sizeof(fpp_log_if_cmd_t), 
+ *                                         (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Success.
- *     - @c FPP_ERR_IF_ENTRY_NOT_FOUND: Last entry in the query session.
- *     - @c FPP_ERR_IF_WRONG_SESSION_ID: Someone else is already working with the interfaces.
- *     - @c FPP_ERR_IF_MATCH_UPDATE_FAILED: Update of match flags has failed.
- *     - @c FPP_ERR_IF_EGRESS_UPDATE_FAILED: Update of egress interfaces has failed.
- *     - @c FPP_ERR_IF_EGRESS_DOESNT_EXIST: Egress interface provided in command doesn't exist.
- *     - @c FPP_ERR_IF_OP_FLAGS_UPDATE_FAILED: Operation flags update has failed (PROMISC/ENABLE/MATCH).
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of a logical interface.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_log_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_log_if_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_LOG_IF,
+ *                  sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first logical interface from 
+ *  //  the internal collective list of all logical interfaces.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_LOG_IF,
+ *                  sizeof(fpp_log_if_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next logical interface from 
+ *  //  the internal collective list of all logical interfaces.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_IF_ENTRY_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the logical interface query session (no more interfaces).
+ *        - For other ACTIONs: Unknown (nonexistent) logical interface was requested.
+ * - @c FPP_ERR_IF_ENTRY_ALREADY_REGISTERED <br>
+ *        Requested logical interface already exists (is already registered).
+ * - @c FPP_ERR_IF_WRONG_SESSION_ID <br>
+ *        Some other client has the interface database locked for exclusive access.
+ * - @c FPP_ERR_IF_RESOURCE_ALREADY_LOCKED <br>
+ *        Same as FPP_ERR_IF_WRONG_SESSION_ID.
+ * - @c FPP_ERR_IF_MATCH_UPDATE_FAILED <br>
+ *        Update of match flags has failed.
+ * - @c FPP_ERR_IF_EGRESS_UPDATE_FAILED <br>
+ *        Update of the `.egress` bitset has failed.
+ * - @c FPP_ERR_IF_EGRESS_DOESNT_EXIST <br>
+ *        Invalid (nonexistent) egress physical interface in the `.egress` bitset.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_LOG_IF					0xf101
 
 /**
- * @def FPP_ERR_IF_ENTRY_ALREADY_REGISTERED
+ * @def         FPP_ERR_IF_ENTRY_ALREADY_REGISTERED
  * @hideinitializer
  */
 #define FPP_ERR_IF_ENTRY_ALREADY_REGISTERED		0xf103
 
 /**
- * @def FPP_ERR_IF_ENTRY_NOT_FOUND
+ * @def         FPP_ERR_IF_ENTRY_NOT_FOUND
  * @hideinitializer
  */
 #define FPP_ERR_IF_ENTRY_NOT_FOUND				0xf104
 
 /**
- * @def FPP_ERR_IF_EGRESS_DOESNT_EXIST
+ * @def         FPP_ERR_IF_EGRESS_DOESNT_EXIST
  * @hideinitializer
  */
 #define FPP_ERR_IF_EGRESS_DOESNT_EXIST			0xf105
 
 /**
- * @def FPP_ERR_IF_EGRESS_UPDATE_FAILED
+ * @def         FPP_ERR_IF_EGRESS_UPDATE_FAILED
  * @hideinitializer
  */
 #define FPP_ERR_IF_EGRESS_UPDATE_FAILED			0xf106
 
 /**
- * @def FPP_ERR_IF_MATCH_UPDATE_FAILED
+ * @def         FPP_ERR_IF_MATCH_UPDATE_FAILED
  * @hideinitializer
  */
 #define FPP_ERR_IF_MATCH_UPDATE_FAILED			0xf107
 
 /**
- * @def FPP_ERR_IF_OP_UPDATE_FAILED
+ * @def         FPP_ERR_IF_OP_UPDATE_FAILED
  * @hideinitializer
  */
 #define FPP_ERR_IF_OP_UPDATE_FAILED				0xf108
 
 /**
- * @def FPP_ERR_IF_OP_CANNOT_CREATE
+ * @def         FPP_ERR_IF_OP_CANNOT_CREATE
  * @hideinitializer
  */
 #define FPP_ERR_IF_OP_CANNOT_CREATE				0xf109
 
 /**
- * @def FPP_ERR_IF_RESOURCE_ALREADY_LOCKED
+ * @def         FPP_ERR_IF_RESOURCE_ALREADY_LOCKED
  * @hideinitializer
  */
 #define FPP_ERR_IF_RESOURCE_ALREADY_LOCKED		0xf110
 
 /**
- * @def FPP_ERR_IF_WRONG_SESSION_ID
+ * @def         FPP_ERR_IF_WRONG_SESSION_ID
  * @hideinitializer
  */
 #define FPP_ERR_IF_WRONG_SESSION_ID				0xf111
 
 /**
- * @def		FPP_CMD_IF_LOCK_SESSION
- * @brief	FCI command to perform lock on interface database.
- * @details	The reason for it is guaranteed atomic operation between fci/rpc/platform.
- *
- * @note	Command is defined as extension of the legacy fpp.h.
+ * @def         FPP_CMD_IF_LOCK_SESSION
+ * @brief       FCI command to get exclusive access to interface database.
+ * @details     Related topics: @ref mgmt_phyif, @ref mgmt_logif, @ref flex_router
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IF_LOCK_SESSION, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     -  FPP_ERR_OK: Lock successful
- *     -  FPP_ERR_IF_RESOURCE_ALREADY_LOCKED: Database was already locked by someone else
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_IF_RESOURCE_ALREADY_LOCKED <br>
+ *        Some other client has the interface database locked for exclusive access.
  *
  * @hideinitializer
  */
 #define FPP_CMD_IF_LOCK_SESSION					0x0015
 
 /**
- * @def		FPP_CMD_IF_UNLOCK_SESSION
- * @brief	FCI command to perform unlock on interface database.
- * @details	The reason for it is guaranteed atomic operation between fci/rpc/platform.
+ * @def         FPP_CMD_IF_UNLOCK_SESSION
+ * @brief       FCI command to cancel exclusive access to interface database.
+ * @details     Related topics: @ref mgmt_phyif, @ref mgmt_logif, @ref flex_router
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_IF_UNLOCK_SESSION, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * @note	Command is defined as extension of the legacy fpp.h.
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_IF_WRONG_SESSION_ID <br>
+ *        Either the database is not locked, or it is currently locked by some other client.
  *
- * Possible command return values are:
- *     -  FPP_ERR_OK: Lock successful
- *     -  FPP_ERR_IF_WRONG_SESSION_ID: The lock wasn't locked or was locked in different
- *     									 session and will not be unlocked.
  * @hideinitializer
  */
 #define FPP_CMD_IF_UNLOCK_SESSION				0x0016
 
 /**
- * @brief	Interface flags
+ * @brief       Interface flags
+ * @details     Related data types: @ref fpp_phy_if_cmd_t, @ref fpp_log_if_cmd_t
+ * @details     Some of these flags are applicable only for physical interfaces [phyif], 
+ *              some are applicable only for logical interfaces [logif] and some are applicable 
+ *              for both [phyif,logif].
  */
 typedef enum CAL_PACKED
 {
@@ -257,344 +382,343 @@ typedef enum CAL_PACKED
 	FPP_IF_PTP_PROMISC = (1 << 9),		/*!< Enable/Disable PTP promiscuous mode */
 	FPP_IF_LOOPBACK = (1 << 10),		/*!< If set, loopback mode is enabled */
 	FPP_IF_ALLOW_Q_IN_Q = (1 << 11),	/*!< If set, QinQ traffic is accepted */
-	FPP_IF_DISCARD_TTL = (1 << 12),		/*!< Discard packet with TTL<2 instead of passing to default logical interface */
 	FPP_IF_MAX = (int)(1U << 31U)
 } fpp_if_flags_t;
 
 /**
- * @typedef fpp_phy_if_op_mode_t
- * @brief	Physical if modes
+ * @brief       Physical interface operation mode.
+ * @details     Related data types: @ref fpp_phy_if_cmd_t
  */
 typedef enum CAL_PACKED
 {
-	FPP_IF_OP_DEFAULT = 0,			/*!< Default operational mode */
-	FPP_IF_OP_BRIDGE = 1,			/*!< L2 bridge */
-	FPP_IF_OP_ROUTER = 2,			/*!< L3 router */
-	FPP_IF_OP_VLAN_BRIDGE = 3,		/*!< L2 bridge with VLAN */
-	FPP_IF_OP_FLEXIBLE_ROUTER = 4,	/*!< Flexible router */
-	FPP_IF_OP_L2L3_BRIDGE = 5,		/*!< L2 bridge and L3 router combination*/
-	FPP_IF_OP_L2L3_VLAN_BRIDGE = 6,	/*!< L2 Vlan bridge and L3 router combination*/
+	FPP_IF_OP_DISABLED = 0,			/*!< Disabled */
+	FPP_IF_OP_DEFAULT = 1,			/*!< Default operational mode */
+	FPP_IF_OP_BRIDGE = 2,			/*!< L2 bridge */
+	FPP_IF_OP_ROUTER = 3,			/*!< L3 router */
+	FPP_IF_OP_VLAN_BRIDGE = 4,		/*!< L2 bridge with VLAN */
+	FPP_IF_OP_FLEXIBLE_ROUTER = 5,	/*!< Flexible router */
+	FPP_IF_OP_L2L3_BRIDGE = 6,		/*!< L2 bridge and L3 router combination*/
+	FPP_IF_OP_L2L3_VLAN_BRIDGE = 7,	/*!< L2 Vlan bridge and L3 router combination*/
 } fpp_phy_if_op_mode_t;
 
 /**
- * @brief	Match rules. Can be combined using bitwise OR.
+ * @brief       Match rules.
+ * @details     Related data types: @ref fpp_log_if_cmd_t, @ref fpp_if_m_args_t
+ * @note        L2/L3/L4 are layers of the OSI model.
  */
 typedef enum CAL_PACKED
 {
-	FPP_IF_MATCH_TYPE_ETH = (1 << 0),		/**< Match ETH Packets */
-	FPP_IF_MATCH_TYPE_VLAN = (1 << 1),		/**< Match VLAN Tagged Packets */
-	FPP_IF_MATCH_TYPE_PPPOE = (1 << 2),		/**< Match PPPoE Packets */
-	FPP_IF_MATCH_TYPE_ARP = (1 << 3),		/**< Match ARP Packets */
-	FPP_IF_MATCH_TYPE_MCAST = (1 << 4),		/**< Match Multicast (L2) Packets */
-	FPP_IF_MATCH_TYPE_IPV4 = (1 << 5),		/**< Match IPv4 Packets */
-	FPP_IF_MATCH_TYPE_IPV6 = (1 << 6),		/**< Match IPv6 Packets */
-	FPP_IF_MATCH_RESERVED7 = (1 << 7),		/**< Reserved */
-	FPP_IF_MATCH_RESERVED8 = (1 << 8),		/**< Reserved */
-	FPP_IF_MATCH_TYPE_IPX = (1 << 9),		/**< Match IPX Packets */
-	FPP_IF_MATCH_TYPE_BCAST = (1 << 10),	/**< Match Broadcast (L2) Packets */
-	FPP_IF_MATCH_TYPE_UDP = (1 << 11),		/**< Match UDP Packets */
-	FPP_IF_MATCH_TYPE_TCP = (1 << 12),		/**< Match TCP Packets */
-	FPP_IF_MATCH_TYPE_ICMP = (1 << 13),		/**< Match ICMP Packets */
-	FPP_IF_MATCH_TYPE_IGMP = (1 << 14),		/**< Match IGMP Packets */
-	FPP_IF_MATCH_VLAN = (1 << 15),			/**< Match VLAN ID */
-	FPP_IF_MATCH_PROTO = (1 << 16),			/**< Match IP Protocol */
-	FPP_IF_MATCH_SPORT = (1 << 20),			/**< Match L4 Source Port */
-	FPP_IF_MATCH_DPORT = (1 << 21),			/**< Match L4 Destination Port */
-	FPP_IF_MATCH_SIP6 = (1 << 22),			/**< Match Source IPv6 Address */
-	FPP_IF_MATCH_DIP6 = (1 << 23),			/**< Match Destination IPv6 Address */
-	FPP_IF_MATCH_SIP = (1 << 24),			/**< Match Source IPv4 Address */
-	FPP_IF_MATCH_DIP = (1 << 25),			/**< Match Destination IPv4 Address */
-	FPP_IF_MATCH_ETHTYPE = (1 << 26),		/**< Match EtherType */
-	FPP_IF_MATCH_FP0 = (1 << 27),			/**< Match Packets Accepted by Flexible Parser 0 */
-	FPP_IF_MATCH_FP1 = (1 << 28),			/**< Match Packets Accepted by Flexible Parser 1 */
-	FPP_IF_MATCH_SMAC = (1 << 29),			/**< Match Source MAC Address */
-	FPP_IF_MATCH_DMAC = (1 << 30),			/**< Match Destination MAC Address */
-	FPP_IF_MATCH_HIF_COOKIE = (int)(1U << 31U),	/**< Match HIF header cookie value */
-	/* Ensure proper size */
-	FPP_IF_MATCH_MAX = (int)(1U << 31U)
+    FPP_IF_MATCH_TYPE_ETH = (1 << 0),     /**< Match ETH packets */
+    FPP_IF_MATCH_TYPE_VLAN = (1 << 1),    /**< Match VLAN tagged packets */
+    FPP_IF_MATCH_TYPE_PPPOE = (1 << 2),   /**< Match PPPoE packets */
+    FPP_IF_MATCH_TYPE_ARP = (1 << 3),     /**< Match ARP packets */
+    FPP_IF_MATCH_TYPE_MCAST = (1 << 4),   /**< Match multicast (L2) packets */
+    FPP_IF_MATCH_TYPE_IPV4 = (1 << 5),    /**< Match IPv4 packets */
+    FPP_IF_MATCH_TYPE_IPV6 = (1 << 6),    /**< Match IPv6 packets */
+    FPP_IF_MATCH_RESERVED7 = (1 << 7),    /**< Reserved */
+    FPP_IF_MATCH_RESERVED8 = (1 << 8),    /**< Reserved */
+    FPP_IF_MATCH_TYPE_IPX = (1 << 9),     /**< Match IPX packets */
+    FPP_IF_MATCH_TYPE_BCAST = (1 << 10),  /**< Match L2 broadcast packets */
+    FPP_IF_MATCH_TYPE_UDP = (1 << 11),    /**< Match UDP packets */
+    FPP_IF_MATCH_TYPE_TCP = (1 << 12),    /**< Match TCP packets */
+    FPP_IF_MATCH_TYPE_ICMP = (1 << 13),   /**< Match ICMP packets */
+    FPP_IF_MATCH_TYPE_IGMP = (1 << 14),   /**< Match IGMP packets */
+    FPP_IF_MATCH_VLAN = (1 << 15),        /**< Match VLAN ID (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_PROTO = (1 << 16),       /**< Match IP Protocol Number (protocol ID) See fpp_if_m_args_t. */
+    FPP_IF_MATCH_SPORT = (1 << 20),       /**< Match L4 source port (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_DPORT = (1 << 21),       /**< Match L4 destination port (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_SIP6 = (1 << 22),        /**< Match source IPv6 address (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_DIP6 = (1 << 23),        /**< Match destination IPv6 address (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_SIP = (1 << 24),         /**< Match source IPv4 address (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_DIP = (1 << 25),         /**< Match destination IPv4 address (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_ETHTYPE = (1 << 26),     /**< Match EtherType (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_FP0 = (1 << 27),         /**< Match Ethernet frames accepted by Flexible Parser 0 (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_FP1 = (1 << 28),         /**< Match Ethernet frames accepted by Flexible Parser 1 (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_SMAC = (1 << 29),        /**< Match source MAC address (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_DMAC = (1 << 30),        /**< Match destination MAC address (see fpp_if_m_args_t) */
+    FPP_IF_MATCH_HIF_COOKIE = (int)(1U << 31U),  /**< Match HIF header cookie. HIF header cookie is a part of internal overhead data.
+                                                      It is attached to traffic data by a host's PFE driver. */
+    
+    /* Ensure proper size */
+    FPP_IF_MATCH_MAX = (int)(1U << 31U)
 } fpp_if_m_rules_t;
 
 /**
- * @brief	Match rules arguments.
- * @details Every value corresponds to specified match rule (@ref fpp_if_m_rules_t).
+ * @brief       Match rules arguments.
+ * @details     Related data types: @ref fpp_log_if_cmd_t, @ref fpp_if_m_rules_t
+ * @details     Each value is an argument for some match rule.
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp_ext.h  fpp_if_m_args_t
  */
+/* [fpp_if_m_args_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	/** VLAN ID (@ref FPP_IF_MATCH_VLAN) */
-	uint16_t vlan;
-	/** EtherType (@ref FPP_IF_MATCH_ETHTYPE) */
-	uint16_t ethtype;
-	/** L4 source port number (@ref FPP_IF_MATCH_SPORT) */
-	uint16_t sport;
-	/** L4 destination port number (@ref FPP_IF_MATCH_DPORT) */
-	uint16_t dport;
-	/* Source and destination addresses */
-	struct
-	{
-		/**	IPv4 source and destination address (@ref FPP_IF_MATCH_SIP, @ref FPP_IF_MATCH_DIP) */
-		struct
-		{
-			uint32_t sip;
-			uint32_t dip;
-		} v4;
-
-		/**	IPv6 source and destination address (@ref FPP_IF_MATCH_SIP6, @ref FPP_IF_MATCH_DIP6) */
-		struct
-		{
-			uint32_t sip[4];
-			uint32_t dip[4];
-		} v6;
-	} ipv;
-	/** IP protocol (@ref FPP_IF_MATCH_PROTO) */
-	uint8_t proto;
-	/** Source MAC Address (@ref FPP_IF_MATCH_SMAC) */
-	uint8_t smac[6];
-	/** Destination MAC Address (@ref FPP_IF_MATCH_DMAC) */
-	uint8_t dmac[6];
-	/** Flexible Parser table 0 (@ref FPP_IF_MATCH_FP0) */
-	char fp_table0[16];
-	/** Flexible Parser table 1 (@ref FPP_IF_MATCH_FP1) */
-	char fp_table1[16];
-	/** HIF header cookie (@ref FPP_IF_MATCH_HIF_COOKIE) */
-	uint32_t hif_cookie;
+    uint16_t vlan;     /*< VLAN ID. [NBO]. See FPP_IF_MATCH_VLAN. */
+    uint16_t ethtype;  /*< EtherType. [NBO]. See FPP_IF_MATCH_ETHTYPE. */
+    uint16_t sport;    /*< L4 source port. [NBO]. See FPP_IF_MATCH_SPORT. */
+    uint16_t dport;    /*< L4 destination port [NBO]. See FPP_IF_MATCH_DPORT. */
+    
+    /* Source and destination IP addresses */
+    struct
+    {
+        struct
+        {
+            uint32_t sip;     /*< IPv4 source address. [NBO]. See FPP_IF_MATCH_SIP. */
+            uint32_t dip;     /*< IPv4 destination address. [NBO]. See FPP_IF_MATCH_DIP. */
+        } v4;
+    
+        struct
+        {
+            uint32_t sip[4];  /*< IPv6 source address. [NBO]. See FPP_IF_MATCH_SIP6. */
+            uint32_t dip[4];  /*< IPv6 destination address. [NBO]. See FPP_IF_MATCH_DIP6. */
+        } v6;
+    } ipv;
+    
+    uint8_t proto;        /*< IP Protocol Number (protocol ID). See FPP_IF_MATCH_PROTO. */
+    uint8_t smac[6];      /*< Source MAC Address. See FPP_IF_MATCH_SMAC. */
+    uint8_t dmac[6];      /*< Destination MAC Address. See FPP_IF_MATCH_DMAC. */
+    char fp_table0[16];   /*< Flexible Parser table 0 (name). See FPP_IF_MATCH_FP0. */
+    char fp_table1[16];   /*< Flexible Parser table 1 (name). See FPP_IF_MATCH_FP1. */
+    uint32_t hif_cookie;  /*< HIF header cookie. [NBO]. See FPP_IF_MATCH_HIF_COOKIE. */
 } fpp_if_m_args_t;
+/* [fpp_if_m_args_t] */
 
 /**
- * @brief	Physical interface statistics
- * @details Statistics used by physical interfaces (EMAC, HIF).
- * @note All statistics counters are in network byte order.
+ * @brief       Physical interface statistics.
+ * @details     Related data types: @ref fpp_phy_if_cmd_t
+ * @note        @b All values are in a network byte order [@b NBO].
+ *
+ * @snippet     fpp_ext.h  fpp_phy_if_stats_t
  */
+/* [fpp_phy_if_stats_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	uint32_t ingress;	/*!< Number of ingress frames for the given interface  */
-	uint32_t egress;	/*!< Number of egress frames for the given interface */
-	uint32_t malformed;	/*!< Number of ingress frames with detected error (i.e. checksum) */
-	uint32_t discarded;	/*!< Number of ingress frames which were discarded */
+    uint32_t ingress;    /*< Count of ingress frames for the given interface. */
+    uint32_t egress;     /*< Count of egress frames for the given interface. */
+    uint32_t malformed;  /*< Count of ingress frames with detected error (e.g. checksum). */
+    uint32_t discarded;  /*< Count of ingress frames which were discarded. */
 } fpp_phy_if_stats_t;
+/* [fpp_phy_if_stats_t] */
 
 /**
- * @brief	Algorithm statistics
- * @details Statistics used by algorithms in class (eg. log ifs).
- * @note All statistics counters are in network byte order.
+ * @brief       Logical interface statistics.
+ * @details     Related data types: @ref fpp_log_if_cmd_t
+ * @note        @b All values are in a network byte order [@b NBO].
+ *
+ * @snippet     fpp_ext.h  fpp_algo_stats_t
  */
+/* [fpp_algo_stats_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	uint32_t processed;	/*!< Number of frames processed regardless the result */
-	uint32_t accepted;	/*!< Number of frames matching the selection criteria */
-	uint32_t rejected;	/*!< Number of frames not matching the selection criteria */
-	uint32_t discarded;	/*!< Number of frames marked to be dropped */
+    uint32_t processed;  /*< Count of frames processed (regardless of the result). */
+    uint32_t accepted;   /*< Count of frames matching the selection criteria. */
+    uint32_t rejected;   /*< Count of frames not matching the selection criteria. */
+    uint32_t discarded;  /*< Count of frames marked to be dropped. */
 } fpp_algo_stats_t;
+/* [fpp_algo_stats_t] */
 
 /**
- * @brief	Interface blocking state
+ * @brief       Physical interface blocking state.
+ * @details     Related data types: @ref fpp_phy_if_cmd_t
+ * @details     Used when a physical interface is configured in a Bridge-like mode.    
+ *              See @ref l2_bridge and @ref l2l3_bridge. Affects the following Bridge-related 
+ *              capabilities of a physical interface:
+ *              - Learning of MAC addresses from the interface's ingress traffic.
+ *              - Forwarding of the interface's ingress traffic.
  */
 typedef enum CAL_PACKED
 {
-	BS_NORMAL = 0,		/*!< Learning and forwarding enabled */
-	BS_BLOCKED = 1,		/*!< Learning and forwarding disabled */
-	BS_LEARN_ONLY = 2,	/*!< Learning enabled, forwarding disabled */
-	BS_FORWARD_ONLY = 3	/*!< Learning disabled, forwarding enabled */
+    BS_NORMAL = 0,       /**< Learning and forwarding enabled. */
+    BS_BLOCKED = 1,      /**< Learning and forwarding disabled. */
+    BS_LEARN_ONLY = 2,   /**< Learning enabled, forwarding disabled. */
+    BS_FORWARD_ONLY = 3  /**< Learning disabled, forwarding enabled. */
 } fpp_phy_if_block_state_t;
 
 /**
- * @brief		Data structure to be used for physical interface commands
- * @details		Usage:
- * 				- As command buffer in functions @ref fci_write, @ref fci_query or
- * 				  @ref fci_cmd, with @ref FPP_CMD_PHY_IF command.
- * 				- As reply buffer in functions @ref fci_query or @ref fci_cmd,
- * 				  with @ref FPP_CMD_PHY_IF command.
+ * @brief       Data structure for a physical interface.
+ * @details     Related FCI commands: @ref FPP_CMD_PHY_IF
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_phy_if_cmd_t
  */
+/* [fpp_phy_if_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	uint16_t action;			/**< Action */
-	char name[IFNAMSIZ];		/**< Interface name */
-	uint32_t id;				/**< Interface ID (network endian) */
-	fpp_if_flags_t flags;		/**< Interface flags (network endian) */
-	fpp_phy_if_op_mode_t mode;	/**< Phy if mode (network endian) */
-	fpp_phy_if_block_state_t block_state;	/**< Phy if block state */
-	fpp_phy_if_stats_t	stats;	/**< Physical interface statistics */
-	uint8_t mac_addr[6];		/**< Phy if MAC (network endian) */
-	char mirror[IFNAMSIZ];		/**< Name of interface to mirror the traffic to */
-	/**	Table to be used to filter ingress traffic. See @ref FPP_CMD_FP_TABLE. If
-	 	here is non-empty string then the filter is enabled. Empty string disables
-	 	the filter. */
-	char ftable[16];
+    uint16_t action;            /*< Action */
+    char name[IFNAMSIZ];        /*< Interface name. [ro] */
+    uint32_t id;                /*< Interface ID. [NBO,ro] */
+    fpp_if_flags_t flags;       /*< Interface flags. [NBO]. A bitset. */
+    fpp_phy_if_op_mode_t mode;  /*< Interface mode. */
+    fpp_phy_if_block_state_t block_state;  /*< Interface blocking state. */
+    fpp_phy_if_stats_t stats;   /*< Physical interface statistics. [ro] */
+    uint8_t mac_addr[6];        /*< Physical interface MAC. [ro] */
+    
+    char mirror[IFNAMSIZ];      /*< Name of a physical interface which shall receive 
+                                    a mirror of traffic. Empty string == no mirroring.
+                                    See also the related flag FPP_IF_MIRROR. */
+    
+    char ftable[16];            /*< Name of a Flexible Parser table which shall be used 
+                                    as a Flexible Filter of this physical interface.
+                                    Empty string == Flexible filter is disabled. 
+                                    See Flexible Parser for more info. */
 } fpp_phy_if_cmd_t;
+/* [fpp_phy_if_cmd_t] */
 
 /**
- * @brief		Data structure to be used for logical interface commands
- * @details		Usage:
- * 				- As command buffer in functions @ref fci_write, @ref fci_query or
- * 				  @ref fci_cmd, with @ref FPP_CMD_LOG_IF command.
- * 				- As reply buffer in functions @ref fci_query or @ref fci_cmd,
- * 				  with @ref FPP_CMD_LOG_IF command.
+ * @brief       Data structure for a logical interface.
+ * @details     Related FCI commands: @ref FPP_CMD_LOG_IF
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_log_if_cmd_t
  */
+/* [fpp_log_if_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	uint16_t action;			/**< Action */
-	uint8_t res[2];				/* Additional 2B to ensure correct alignment */
-	char name[IFNAMSIZ];		/**< Interface name */
-	uint32_t id;				/**< Interface ID (network endian) */
-	char parent_name[IFNAMSIZ];	/**< Parent physical interface name */
-	uint32_t parent_id;			/**< Parent physical interface ID (network endian) */
-	uint32_t egress;			/**< Egress interfaces in the form of mask (to get egress id: egress & (1 < id))
-								   must be stored in network order (network endian) */
-	fpp_if_flags_t flags;		/**< Interface flags from query or flags to be set (network endian) */
-	fpp_if_m_rules_t match;		/**< Match rules from query or match rules to be set (network endian) */
-	fpp_if_m_args_t CAL_PACKED_ALIGNED(4) arguments;	/**< Arguments for match rules (network endian) */
-	fpp_algo_stats_t CAL_PACKED_ALIGNED(4) stats;		/**< Logical interface statistics */
+    uint16_t action;            /*< Action */
+    uint8_t res[2];             /*< RESERVED (do not use) */
+    char name[IFNAMSIZ];        /*< Interface name. [ro] */
+    uint32_t id;                /*< Interface ID. [NBO,ro] */
+    char parent_name[IFNAMSIZ]; /*< Parent physical interface name. [ro] */
+    uint32_t parent_id;         /*< Parent physical interface ID. [NBO,ro] */
+    
+    uint32_t egress;            /*< Egress physical interfaces. [NBO]. A bitset.
+                                    Each physical interface is represented by a bitflag. 
+                                    Conversion between a physical interface ID and a corr-
+                                    esponding bitflag is (1uL << "physical interface ID"). */
+    
+    fpp_if_flags_t flags;       /*< Interface flags. [NBO]. A bitset. */
+    fpp_if_m_rules_t match;     /*< Match rules. [NBO]. A bitset. */
+    fpp_if_m_args_t CAL_PACKED_ALIGNED(4) arguments;  /*< Match rules arguments. */
+    fpp_algo_stats_t CAL_PACKED_ALIGNED(4) stats;     /*< Logical interface statistics [ro] */
 } fpp_log_if_cmd_t;
+/* [fpp_log_if_cmd_t] */
 
 /**
- * @def FPP_CMD_L2_BD
- * @brief VLAN-based L2 bridge domain management
- * @details Bridge domain can be used to include a set of physical interfaces and isolate them
- *          from another domains using VLAN. Command can be used with various `.action` values:
- *          - @c FPP_ACTION_REGISTER: Create a new bridge domain.
- *          - @c FPP_ACTION_DEREGISTER: Delete bridge domain.
- *          - @c FPP_ACTION_UPDATE: Update a bridge domain meaning that will rewrite domain properties except of VLAN ID.
- *          - @c FPP_ACTION_QUERY: Gets head of list of registered domains.
- *          - @c FPP_ACTION_QUERY_CONT: Get next item from list of registered domains. Shall be called after
- *               @c FPP_ACTION_QUERY was called. On each call it replies with parameters of next domain.
- *               It returns @c FPP_ERR_RT_ENTRY_NOT_FOUND when no more entries exist.
- *
- * Command Argument Type: @ref fpp_l2_bd_cmd_t
- *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * @def         FPP_CMD_L2_BD
+ * @brief       FCI command for management of L2 bridge domains.
+ * @details     Related topics: @ref l2_bridge, @ref l2l3_bridge
+ * @details     Related data types: @ref fpp_l2_bd_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new bridge domain.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing bridge domain.
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of a bridge domain.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) a bridge domain query session and get properties 
+ *                   of the first bridge domain from the internal list of bridge domains.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next bridge domain
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
+ *
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new bridge domain. When creating a new bridge domain, it is also possible to 
+ * simultaneously set its properties (using the same rules which apply to @ref FPP_ACTION_UPDATE).
  * @code{.c}
- *   fpp_l2_bd_cmd_t cmd_data =
- *   {
- *     // Register new bridge domain
- *     .action = FPP_ACTION_REGISTER,
- *     // VLAN ID associated with the domain (network endian)
- *     .vlan = ...,
- *     // Action to be taken when destination MAC address (uni-cast) of a packet
- *     // matching the domain is found in the MAC table: 0 - Forward, 1 - Flood,
- *     // 2 - Punt, 3 - Discard
- *     .ucast_hit = ...,
- *     // Action to be taken when destination MAC address (uni-cast) of a packet
- *     // matching the domain is not found in the MAC table.
- *     .ucast_miss = ...,
- *     // Multicast hit action
- *     .mcast_hit = ...,
- *     // Multicast miss action
- *     .mcast_miss = ...
- *   };
+ *  .............................................  
+ *  fpp_l2_bd_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_REGISTER,  // Action
+ *    .vlan   = ...,                  // VLAN ID of a new bridge domain. [NBO] (user-defined)
+ *    
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_l2_bd_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+ *                                        (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Domain added.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Unexpected argument.
- *     - @c FPP_ERR_L2_BD_ALREADY_REGISTERED: Given domain already registered.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- *
- * Action FPP_ACTION_DEREGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing bridge domain.
  * @code{.c}
- *   fpp_l2_bd_cmd_t cmd_data =
- *   {
- *     // Delete bridge domain
- *     .action = FPP_ACTION_DEREGISTER,
- *     // VLAN ID associated with the domain to be deleted (network endian)
- *     .vlan = ...,
- *   };
+ *  .............................................  
+ *  fpp_l2_bd_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *    .vlan   = ...,                    // VLAN ID of an existing bridge domain. [NBO]
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+ *                                        (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Domain removed.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Unexpected argument.
- *     - @c FPP_ERR_L2_BD_NOT_FOUND: Given domain not found.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- * Action FPP_ACTION_UPDATE
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of a logical interface. It is recommended to use the read-modify-write
+ * approach. Some properties cannot be modified (see fpp_l2_bd_cmd_t).
  * @code{.c}
- *   fpp_l2_bd_cmd_t cmd_data =
- *   {
- *     // Update bridge domain
- *     .action = FPP_ACTION_UPDATE,
- *     // VLAN ID associated with the domain to be updated (network endian)
- *     .vlan = ...,
- *     // New unicast hit action (0 - Forward, 1 - Flood, 2 - Punt, 3 - Discard)
- *     .ucast_hit = ...,
- *     // New unicast miss action
- *     .ucast_miss = ...,
- *     // New multicast hit action
- *     .mcast_hit = ...,
- *     // New multicast miss action
- *     .mcast_miss = ...,
- *     // New port list (network endian). Bitmask where every set bit represents
- *     // ID of physical interface being member of the domain. For instance bit
- *     // (1 << 3), if set, says that interface with ID=3 is member of the domain.
- *     // Only valid interface IDs are accepted by the command. If flag is set,
- *     // interface is added to the domain. If flag is not set and interface
- *     // has been previously added, it is removed. The IDs are given by the
- *     // related FCI endpoint and related networking HW. Interface IDs can be
- *     // obtained via FPP_CMD_PHY_IF.
- *     .if_list = ...,
- *     // Flags marking interfaces listed in @c if_list to be 'tagged' or
- *     // 'untagged' (network endian). If respective flag is set, corresponding
- *     // interface within the @c if_list is treated as 'untagged' meaning that
- *     // the VLAN tag will be removed. Otherwise it is configured as 'tagged'.
- *     // Note that only interfaces listed within the @c if_list are taken into
- *     // account.
- *     .untag_if_list = ...,
- *   };
+ *  .............................................  
+ *  fpp_log_if_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *    .vlan   = ...,                // VLAN ID of an existing bridge domain. [NBO]
+ *    
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_l2_bd_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_BD, sizeof(fpp_l2_bd_cmd_t), 
+ *                                        (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Domain updated.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Unexpected argument.
- *     - @c FPP_ERR_L2_BD_NOT_FOUND: Given domain not found.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of a bridge domain.
  * @code{.c}
- *   fpp_l2_bd_cmd_t cmd_data =
- *   {
- *     .action = ...    // Either FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT
- *   };
- * @endcode
- *
- * Response data type for queries: @ref fpp_l2_bd_cmd_t
- *
- * Response data provided (all values in network byte order):
- * @code{.c}
- *     // VLAN ID associated with domain (network endian)
- *     rsp_data.vlan;
- *     // Action to be taken when destination MAC address (uni-cast) of a packet
- *     // matching the domain is found in the MAC table: 0 - Forward, 1 - Flood,
- *     // 2 - Punt, 3 - Discard
- *     rsp_data.ucast_hit;
- *     // Action to be taken when destination MAC address (uni-cast) of a packet
- *     // matching the domain is not found in the MAC table.
- *     rsp_data.ucast_miss;
- *     // Multicast hit action.
- *     rsp_data.mcast_hit;
- *     // Multicast miss action.
- *     rsp_data.mcast_miss;
- *     // Bitmask where every set bit represents ID of physical interface being member
- *     // of the domain. For instance bit (1 << 3), if set, says that interface with ID=3
- *     // is member of the domain.
- *     rsp_data.if_list;
- *     // Similar to @c if_list but this interfaces are configured to be VLAN 'untagged'.
- *     rsp_data.untag_if_list;
- *     // See the fpp_l2_bd_flags_t.
- *     rsp_data.flags;
- * @endcode
- *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Response buffer written.
- *     - @c FPP_ERR_L2_BD_NOT_FOUND: No more entries.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
+ *  .............................................  
+ *  fpp_l2_bd_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_l2_bd_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_L2_BD,
+ *                  sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first bridge domain from 
+ *  //  the internal list of bridge domains.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_L2_BD,
+ *                  sizeof(fpp_l2_bd_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next bridge domain from 
+ *  //  the internal list of bridge domains.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_L2_BD_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the bridge domain query session (no more bridge domains).
+ *        - For other ACTIONs: Unknown (nonexistent) bridge domain was requested.
+ * - @c FPP_ERR_L2_BD_ALREADY_REGISTERED <br>
+ *        Requested bridge domain already exists (is already registered).
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
+ * 
  * @hideinitializer
  */
 #define FPP_CMD_L2_BD						0xf200
@@ -603,463 +727,592 @@ typedef struct CAL_PACKED_ALIGNED(4)
 #define FPP_ERR_L2_BD_NOT_FOUND				0xf202
 
 /**
- * @brief	L2 bridge domain flags
+ * @brief       L2 bridge domain flags
+ * @details     Related data types: @ref fpp_l2_bd_cmd_t
  */
 typedef enum CAL_PACKED
 {
-	FPP_L2_BD_DEFAULT = (1 << 0),	/*!< Domain type is default */
-	FPP_L2_BD_FALLBACK = (1 << 1)	/*!< Domain type is fallback */
+    FPP_L2_BD_DEFAULT = (1 << 0),   /*!< Domain type is default */
+    FPP_L2_BD_FALLBACK = (1 << 1)   /*!< Domain type is fallback */
 } fpp_l2_bd_flags_t;
 
 /**
- * @brief   Data structure to be used for command buffer for L2 bridge domain control commands
- * @details It can be used:
- *          - for command buffer in functions @ref fci_write or @ref fci_cmd,
- *            with commands: @ref FPP_CMD_L2_BD.
+ * @brief       Data structure for L2 bridge domain.
+ * @details     Related FCI commands: @ref FPP_CMD_L2_BD
+ * @details     Bridge domain actions (what to do with a frame):
+ *              | value | meaning |
+ *              |-------|---------|
+ *              | 0     | Forward |
+ *              | 1     | Flood   |
+ *              | 2     | Punt    |
+ *              | 3     | Discard |
+ *
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_l2_bd_cmd_t
  */
-typedef struct CAL_PACKED_ALIGNED(2)
-{
-	/**	Action to be executed (register, unregister, query, ...) */
-	uint16_t action;
-	/**	VLAN ID associated with the bridge domain (network endian) */
-	uint16_t vlan;
-	/**	Action to be taken when destination MAC address (uni-cast) of a packet matching the domain
-		is found in the MAC table (network endian): 0 - Forward, 1 - Flood, 2 - Punt, 3 - Discard */
-	uint8_t ucast_hit;
-	/**	Action to be taken when destination MAC address (uni-cast) of a packet matching the domain
-		is not found in the MAC table */
-	uint8_t ucast_miss;
-	/**	Multicast hit action */
-	uint8_t mcast_hit;
-	/**	Multicast miss action */
-	uint8_t mcast_miss;
-	/**	Port list (network endian). Bitmask where every set bit represents ID of physical interface
-		being member of the domain. For instance bit (1 « 3), if set, says that interface with ID=3
-		is member of the domain. Only valid interface IDs are accepted by the command. If flag is set,
-		interface is added to the domain. If flag is not set and interface has been previously added,
-		it is removed. The IDs are given by the related FCI endpoint and related networking HW. Interface
-		IDs can be obtained via FPP_CMD_PHY_IF. */
-	uint32_t if_list;
-	/**	Flags marking interfaces listed in @c if_list to be 'tagged' or 'untagged' (network endian).
-		If respective flag is set, corresponding interface within the @c if_list is treated as 'untagged'
-		meaning that the VLAN tag will be removed. Otherwise it is configured as 'tagged'. Note that
-		only interfaces listed within the @c if_list are taken into account. */
-	uint32_t untag_if_list;
-	/**	See the @ref fpp_l2_bd_flags_t */
-	fpp_l2_bd_flags_t flags;
+/* [fpp_l2_bd_cmd_t] */
+typedef struct CAL_PACKED_ALIGNED(2){
+    uint16_t action;    /*< Action */
+    uint16_t vlan;      /*< Bridge domain VLAN ID. [NBO,ro] */
+    
+    uint8_t ucast_hit;  /*< Bridge domain action when the destination MAC of an inspected 
+                            frame is an unicast MAC and it matches some entry in the 
+                            Bridge MAC table. */
+    
+    uint8_t ucast_miss; /*< Bridge domain action when the destination MAC of an inspected 
+                            frame is an unicast MAC and it does NOT match any entry in the 
+                            Bridge MAC table. */
+    
+    uint8_t mcast_hit;  /*< Similar to ucast_hit, but for frames which have a multicast 
+                            destination MAC address. */
+    
+    uint8_t mcast_miss; /*< Similar to ucast_miss, but for frames which have a multicast 
+                            destination MAC address. */
+    
+    uint32_t if_list;   /*< Bridge domain ports. [NBO]. A bitset.
+                            Ports are represented by physical interface bitflags.
+                            If a bitflag of some physical interface is set here, the interface
+                            is then considered a port of the given bridge domain.
+                            Conversion between a physical interface ID and a corresponding
+                            bitflag is (1uL << "physical interface ID"). */
+    
+    uint32_t untag_if_list; /*< A bitset [NBO], denoting which bridge domain ports from 
+                                '.if_list' are considered untagged (their egress frames 
+                                have the VLAN tag removed).
+                                Ports which are present in both the '.if_list' bitset and 
+                                this bitset are considered untagged.
+                                Ports which are present only in the '.if_list' bitset are
+                                considered tagged. */
+    
+    fpp_l2_bd_flags_t flags;  /*< Bridge domain flags [NBO,ro] */
 } fpp_l2_bd_cmd_t;
+/* [fpp_l2_bd_cmd_t] */
 
 /**
- * @def FPP_CMD_L2_STATIC_ENT
- * @brief VLAN-based L2 bridge static entry management
- * @note When using this command MAC entry learning should be disabled.
- * @details Command can be used with various `.action` values:
- *          - @c FPP_ACTION_REGISTER: Create a new static entry.
- *          - @c FPP_ACTION_DEREGISTER: Delete static entry.
- *          - @c FPP_ACTION_UPDATE: Update static entry. It is possible to update forward list only.
- *          - @c FPP_ACTION_QUERY: Gets head of list of registered static entries.
- *          - @c FPP_ACTION_QUERY_CONT: Get next item from list of static entries. Shall be called after
- *               @c FPP_ACTION_QUERY was called. On each call it replies with parameters of next domain.
- *               It returns @c FPP_ERR_RT_ENTRY_NOT_FOUND when no more entries exist.
- *
- * Command Argument Type: @ref fpp_l2_static_ent_cmd_t
- *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * @def         FPP_CMD_L2_STATIC_ENT
+ * @brief       FCI command for management of L2 static entries.
+ * @details     Related topics: @ref l2_bridge, @ref l2l3_bridge
+ * @details     Related data types: @ref fpp_l2_static_ent_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new static entry.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing static entry.
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of a static entry.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) static entry query session and get properties 
+ *                   of the first static entry from the internal collective list of all 
+ *                   L2 static entries (regardless of bridge domain affiliation).
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next static entry
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
+ *
+ * @note
+ * When using this command, it is recommended to disable dynamic learning of MAC addresses on all 
+ * physical interfaces which are configured to be a part of @ref l2_bridge or @ref l2l3_bridge.
+ * See @ref FPP_CMD_PHY_IF and @ref fpp_phy_if_block_state_t.
+ *
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new L2 static entry.
  * @code{.c}
- *   fpp_l2_static_ent_cmd_t cmd_data =
- *   {
- *     // Register new static entry
- *     .action = FPP_ACTION_REGISTER,
- *     // VLAN ID associated with the domain (network endian)
- *     .vlan = ...,
- *     // MAC address
- *     .mac = {...} ;
- *     //Forward list (network endian). Bitmask where traffic matching source MAC will be forwarded to.
- *     //The bitmask itself is constructed by setting bit corresponding to the egress ID of physical.
- *     // For instance bit (1 « 3), if set, says that all traffic matching configured source MAC
- *     //will be transmitted to physical interface ID=3. If flag is set, given physical interface will be used to
- *     //transmit matching traffic. If flag is cleared and interface has been previously added, all new matching traffic will not
- *     //be transmitted to this interface. The IDs are given by the related FCI endpoint and related networking HW.
- *     //Interface IDs can be obtained via FPP_CMD_PHY_IF.
- *     .forward_list = ..,
- *     // Configure the static entry as Local MAC address for L2L3 Bridge mode
- *     .local = 1
- *     // Do not discard frames sent from the MAC address
- *     .src_discard = 0
- *     // Do not discard frames sent to the MAC address
- *     .dst_discard = 0
- *   };
+ *  .............................................  
+ *  fpp_l2_static_ent_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_REGISTER,  // Action
+ *    .vlan   = ...,                  // VLAN ID of an associated bridge domain. [NBO]
+ *    .mac    = ...,                  // Static entry MAC address.
+ *    .forward_list = ...             // Egress physical interfaces. [NBO]
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t), 
+ *                                                (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Static entry added.
- *     - @c FPP_ERR_L2_STATIC_ENT_ALREADY_REGISTERED: Given static entry already registered.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- *
- * Action FPP_ACTION_DEREGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing L2 static entry.
  * @code{.c}
- *   fpp_l2_static_ent_cmd_t cmd_data =
- *   {
- *     // Delete bridge domain
- *     .action = FPP_ACTION_DEREGISTER,
- *     // VLAN ID associated with the domain (network endian)
- *     .vlan = ...,
- *     // MAC address
- *     .mac = {...} ;
- *   };
+ *  .............................................  
+ *  fpp_l2_static_ent_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *    .vlan   = ...,                    // VLAN ID of an associated bridge domain. [NBO]
+ *    .mac    = ...                     // Static entry MAC address.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t), 
+ *                                                (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Static entry removed.
- *     - @c FPP_ERR_L2_STATIC_EN_NOT_FOUND: Given  static entry not found.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- * Action FPP_ACTION_UPDATE
- * --------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of L2 static entry. It is recommended to use the read-modify-write
+ * approach. Some properties cannot be modified (see fpp_l2_static_ent_cmd_t).
  * @code{.c}
- *   fpp_l2_static_ent_cmd_t cmd_data =
- *   {
- *     // Register new static entry
- *     .action = FPP_ACTION_REGISTER,
- *     // VLAN ID associated with the domain (network endian). This VLAN+MAC have to be already registered for update.
- *     .vlan = ...,
- *     // MAC address. This VLAN+MAC have to be already registered for update.
- *     .mac = {...},
- *     //Forward list (network endian). Bitmask where traffic matching source MAC will be forwarded to.
- *     //The bitmask itself is constructed by setting bit corresponding to the egress ID of physical.
- *     // For instance bit (1 « 3), if set, says that all traffic matching configured source MAC
- *     //will be transmitted to physical interface ID=3. If flag is set, given physical interface will be used to
- *     //transmit matching traffic. If flag is cleared and interface has been previously added, all new matching traffic will not
- *     //be transmitted to this interface. The IDs are given by the related FCI endpoint and related networking HW.
- *     //Interface IDs can be obtained via FPP_CMD_PHY_IF.
- *     .forward_list = ..,
- *     // Configure the static entry as Local MAC address for L2L3 Bridge mode
- *     .local = 1
- *   };
+ *  .............................................  
+ *  fpp_l2_static_ent_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *    .vlan   = ...,                // VLAN ID of an associated bridge domain. [NBO]
+ *    .mac    = ...,                // Static entry MAC address.
+ *    
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_l2_static_ent_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_STATIC_ENT, sizeof(fpp_l2_static_ent_cmd_t), 
+ *                                                (unsigned short*)(&cmd_to_fci));
+ *  ............................................. 
  * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Static entry updated.
- *     - @c FPP_ERR_L2_STATIC_EN_NOT_FOUND: Given static entry not found.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *
- * Action FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
- * -------------------------------------------------
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_l2_static_ent_cmd_t cmd_data =
- *   {
- *     .action = ...    // Either FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT
- *   };
- * @endcode
- *
- * Response data type for queries: @ref fpp_l2_static_ent_cmd_t
- *
- * Response data provided (all values in network byte order):
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of L2 static entry.
  * @code{.c}
- *     // Register new static entry
- *     .action = FPP_ACTION_REGISTER,
- *     // VLAN ID associated with the domain (network endian)
- *     .vlan = ...,
- *     // MAC address
- *     .mac = {...} ;
- *     //Forward list (network endian).
- *     .forward_list = ..;
- *     // Is the static entry used as Local MAC address for L2L3 Bridge mode
- *     .local = ... ; //1 = yes, 0 = no
-
- * @endcode
- *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Response buffer written.
- *     - @c FPP_ERR_L2_STATIC_EN_NOT_FOUND: No more entries.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ *  .............................................  
+ *  fpp_l2_static_ent_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_l2_static_ent_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_L2_STATIC_ENT,
+ *                  sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first static entry from
+ *  //  the internal collective list of all static entries.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_L2_STATIC_ENT,
+ *                  sizeof(fpp_l2_static_ent_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next static entry from 
+ *  //  the internal collective list of all static entries.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_L2_STATIC_EN_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the L2 static entry query session (no more L2 static entries).
+ *        - For other ACTIONs: Unknown (nonexistent) L2 static entry was requested.
+ * - @c FPP_ERR_L2_STATIC_ENT_ALREADY_REGISTERED <br>
+ *        Requested L2 static entry already exists (is already registered).
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
-
 #define FPP_CMD_L2_STATIC_ENT						0xf340
+
 #define FPP_ERR_L2_STATIC_ENT_ALREADY_REGISTERED	0xf341
 #define FPP_ERR_L2_STATIC_EN_NOT_FOUND				0xf342
 
+/**
+ * @brief       Data structure for L2 static entry.
+ * @details     Related FCI commands: @ref FPP_CMD_L2_STATIC_ENT
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_l2_static_ent_cmd_t
+ */
+/* [fpp_l2_static_ent_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	/**	Action to be executed (register, unregister, query, ...) */
-	uint16_t action;
-	/**	VLAN ID associated with the mac address (network endian). If the vlan shouldn't be matched
-	    this field should be configured to default vlan.*/
-	uint16_t vlan;
-	/** MAC Address */
-	uint8_t mac[6];
-	/** Forward list (network endian). Bitmask where traffic matching source MAC will be forwarded to.
-	    The bitmask itself is constructed by setting bit corresponding to the egress ID of physical.
-	    For instance bit (1 « 3), if set, says that all traffic matching configured source MAC
-	    will be transmitted to physical interface ID=3. If flag is set, given physical interface will be used to
-	    transmit matching traffic. If flag is cleared and interface has been previously added, all new matching traffic will not
-	    be transmitted to this interface. The IDs are given by the related FCI endpoint and related networking HW.
-	    Interface IDs can be obtained via FPP_CMD_PHY_IF. */
-	uint32_t forward_list;
-	/** Local MAC address (1 = true, 0 = false). The forward list is ignored and the frames with corresponding destination
-        MAC address are passed to the IP router algorithm when the value is 1 and the ingress physical interface is configured
-        into the L2L3 bridge mode. Other traffic is handle by L2 bridge algorithm. */
-	uint8_t local;
-	/** Frames with this destination MAC address (and VLAN tag) shall be discarded (1 = enable, 0 = disable). */
-	uint8_t dst_discard;
-	/** Frames with this source MAC address (and VLAN tag) shall be discarded (1 = enable, 0 = disable). */
-	uint8_t src_discard;
+    uint16_t action;        /*< Action */
+    
+    uint16_t vlan;          /*< VLAN ID of an associated bridge domain. [NBO,ro] 
+                                VLAN-aware static entries are applied only on frames 
+                                which have a matching VLAN tag.
+                                For non-VLAN aware static entries, use VLAN ID of 
+                                the Default BD (Default Bridge Domain). */
+    
+    uint8_t mac[6];         /*< Static entry MAC address. [ro] */
+    
+    uint32_t forward_list;  /*< Egress physical interfaces. [NBO]. A bitset.
+                                Frames with matching destination MAC address (and VLAN tag)
+                                are forwarded through all physical interfaces which are a part
+                                of this bitset. Physical interfaces are represented by 
+                                bitflags. Conversion between a physical interface ID and 
+                                a corresponding bitflag is (1uL << "physical interface ID").*/
+    
+    uint8_t local;          /*< Local MAC address. (0 == false, 1 == true)
+                                A part of L2L3 Bridge feature. If true, then the forward list 
+                                of such a static entry is ignored and frames with 
+                                a corresponding destination MAC address are passed to 
+                                the IP router algorithm. See chapter about L2L3 Bridge. */
+    
+    uint8_t dst_discard;    /*< Frames with matching destination MAC address (and VLAN tag)
+                                shall be discarded. (0 == disabled, 1 == enabled) */
+    
+    uint8_t src_discard;    /*< Frames with matching source MAC address (and VLAN tag)
+                                shall be discarded. (0 == disabled, 1 == enabled) */
 } fpp_l2_static_ent_cmd_t;
+/* [fpp_l2_static_ent_cmd_t] */
 
 /**
- * @def FPP_CMD_L2_FLUSH_LEARNED
- * @brief FCI command to flush learned MAC table entries
- * @details	Command will remove all adresses from the L2 bridge MAC table
- *          which were added within the learning process.
+ * @def         FPP_CMD_L2_FLUSH_LEARNED
+ * @brief       FCI command to remove all dynamically learned MAC table entries.
+ * @details     Related topics: @ref l2_bridge, @ref l2l3_bridge
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_FLUSH_LEARNED, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     -  FPP_ERR_OK: Flush successful.
- *     -  FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_L2_FLUSH_LEARNED					0xf380
 
 /**
- * @def FPP_CMD_L2_FLUSH_STATIC
- * @brief FCI command to flush static MAC table entries
- * @details	Command will remove all addresses from the L2 bridge MAC table
- *          which were added as static entries via @ref FPP_CMD_L2_STATIC_ENT.
+ * @def         FPP_CMD_L2_FLUSH_STATIC
+ * @brief       FCI command to remove all static MAC table entries.
+ * @details     Related topics: @ref l2_bridge, @ref l2l3_bridge, @ref FPP_CMD_L2_STATIC_ENT
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_FLUSH_STATIC, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     -  FPP_ERR_OK: Flush successful.
- *     -  FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_L2_FLUSH_STATIC						0xf390
 
 /**
- * @def FPP_CMD_L2_FLUSH_ALL
- * @brief FCI command to flush all MAC table entries
- * @details	Command will remove all addresses from the L2 bridge MAC table.
+ * @def         FPP_CMD_L2_FLUSH_ALL
+ * @brief       FCI command to remove all MAC table entries (clear the whole MAC table).
+ * @details     Related topics: @ref l2_bridge, @ref l2l3_bridge
+ * @details     Supported `.action` values: ---
+ * <br>
+ * @code{.c}
+ *  .............................................  
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_L2_FLUSH_ALL, 0, NULL); 
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     -  FPP_ERR_OK: Flush successful.
- *     -  FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * Command return values
+ * ---------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
 #define FPP_CMD_L2_FLUSH_ALL						0xf3a0
 
 /**
- * @def FPP_CMD_FP_TABLE
- * @brief Administers the Flexible Parser tables
- * @details The Flexible Parser table is an ordered set of Flexible Parser rules which
- *          are matched in the order of appearance until match occurs or end of the table
- *          is reached. The following actions can be done on the table:
- *          - @c FPP_ACTION_REGISTER: Create a new table with a given name.
- *          - @c FPP_ACTION_DEREGISTER: Destroy an existing table.
- *          - @c FPP_ACTION_USE_RULE: Add a rule into the table at specified position.
- *          - @c FPP_ACTION_UNUSE_RULE: Remove a rule from the table.
- *          - @c FPP_ACTION_QUERY: Return the first rule in the table.
- *          - @c FPP_ACTION_QUERY_CONT: Return the next rule in the table.
- *
- * The Flexible Parser starts processing the table from the 1st rule in the table. If there is no match
- * the Flexible Parser always continues with the rule following the currently processed rule.
- * The processing ends once rule match happens and the rule action is one of the FP_ACCEPT
- * or FP_REJECT and the respective value is returned.
- * REJECT is also returned after the last rule in the table was processed without any match.
- * The Flexible Parser may branch to arbitrary rule in the table if some rule matches and the
- * action is FP_NEXT_RULE. Note that loops are forbidden.
- *
- * See the FPP_CMD_FP_RULE and @ref fpp_fp_rule_props_t for the detailed description
- * of how the rules are being matched.
- *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
+ * @def         FPP_CMD_FP_TABLE
+ * @brief       FCI command for management of Flexible Parser tables.
+ * @details     Related topics: @ref flex_parser
+ * @details     Related data types: @ref fpp_fp_table_cmd_t, @ref fpp_fp_rule_props_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new FP table.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing FP table.
+ *              - @c FPP_ACTION_USE_RULE <br>
+ *                   Insert an FP rule into an FP table at the specified position.
+ *              - @c FPP_ACTION_UNUSE_RULE <br>
+ *                   Remove an FP rule from an FP table.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) an FP table query session and get properties 
+ *                   of the first FP @b rule from the requested FP table.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next FP @b rule
+ *                   from the requested FP table. Intended to be called in a loop 
+ *                   (to iterate through the requested FP table).
+ *
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new FP table.
  * @code{.c}
- *   fpp_fp_table_cmd_t cmd_data =
- *   {
- *      .action = FPP_ACTION_REGISTER,    // Add a new table
- *      .t.table_name = "table_name",     // Unique up-to-15-character table identifier
- *   };
- * @endcode
- *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_fp_table_cmd_t cmd_data =
- *   {
- *      .action = FPP_ACTION_DEREGISTER,  // Remove an existing table
- *      .t.table_name = "table_name",     // Identifier of the table to be destroyed
- *   };
- * @endcode
- *
- * Action FPP_ACTION_USE_RULE
- * --------------------------
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_fp_table_cmd_t cmd_data =
- *   {
- *      .action = FPP_ACTION_USE_RULE,    // Add existing rule into specified table
- *      .t.table_name = "table_name",     // Identifier of the table to add the rule
- *      .t.rule_name = "rule_name",       // Identifier of the rule to be added into the table
- *      .t.position = ...                 // Desired position of the rule within the table
- *   };
+ *  .............................................  
+ *  fpp_fp_table_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_REGISTER,    // Action
+ *    .table_info.t.table_name = "..."  // Name of a new FP table.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+ *                                                  (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
- * @note Single rule can be member of only one table.
  *
- * Action FPP_ACTION_UNUSE_RULE
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing FP table.
  * @code{.c}
- *   fpp_flexible_parser_table_cmd cmd_data =
- *   {
- *      .action = FPP_ACTION_UNUSE_RULE,  // Remove an existing rule from a table
- *      .t.rule_name = "rule_name",       // Identifier of the rule to be removed from the table
- *   };
+ *  .............................................  
+ *  fpp_fp_table_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *    .table_info.t.table_name = "..."  // Name of an existing FP table.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+ *                                                  (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
- *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * Items to be set in command argument structure:
+ * @note FP table cannot be destroyed if it is in use by some PFE feature.
+ *       First remove the table from use, then destroy it.
+ *
+ * FPP_ACTION_USE_RULE
+ * -------------------
+ * Insert an FP rule at the specified position in an FP table.
+ * - If there are already some rules in the table, they are shifted accordingly to make room
+ *   for the newly inserted rule.
+ * - If the desired position is greater than the count of all rules in the table, the newly 
+ *   inserted rule is placed as the last rule of the table.
+ * 
  * @code{.c}
- *   fpp_flexible_parser_table_cmd cmd_data =
- *   {
- *      .action = FPP_ACTION_QUERY,       // Start query of the table rules
- *      .t.table_name = "table_name",     // Identifier of the table to be queried
- *   };
+ *  .............................................  
+ *  fpp_fp_table_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_USE_RULE,     // Action
+ *    .table_info.t.table_name = "...",  // Name of an existing FP table.
+ *    .table_info.t.rule_name  = "...",  // Name of an existing FP rule.
+ *    .table_info.t.position   = ...     // Desired position of the rule in the table.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+ *                                                  (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
+ * @note Each FP rule can be assigned only to one FP table (cannot be simultaneously a member of multiple FP tables).
  *
- * Response data type for queries: @ref fpp_fp_rule_cmd_t
- *
- * Response data provided:
+ * FPP_ACTION_UNUSE_RULE
+ * ---------------------
+ * Remove an FP rule from an FP table.
  * @code{.c}
- *   rsp_data.r.name;             // Name of the rule
- *   rsp_data.r.data;             // Expected data value (network endian)
- *   rsp_data.r.mask;             // Mask to be applied on frame data (network endian)
- *   rsp_data.r.offset;           // Offset of the data in the frame (network endian)
- *   rsp_data.r.invert;           // Invert match or not
- *   rsp_data.r.match_action;     // Action to be done on match
- *   rsp_data.r.next_rule_name;   // Next rule to be examined if match_action == FP_NEXT_RULE
+ *  .............................................  
+ *  fpp_fp_table_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UNUSE_RULE,   // Action
+ *    .table_info.t.table_name = "...",  // Name of an existing FP table.
+ *    .table_info.t.rule_name  = "...",  // Name of an FP rule which is a member of the table.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FP_TABLE, sizeof(fpp_fp_table_cmd_t), 
+ *                                                  (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
- * @note All data is provided in the network byte order.
  *
- * Action FPP_ACTION_QUERY_CONT
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of an FP @b rule from the requested FP table.
+ * Query result (properties of the @b rule) is stored in the member `.table_info.r`.
  * @code{.c}
- *   fpp_flexible_parser_table_cmd cmd_data =
- *   {
- *      .action = FPP_ACTION_QUERY_CONT,    // Continue query of the table rules by the next rule
- *      .t.table_name = "table_name",       // Identifier of the table to be queried
- *   };
- * @endcode
- *
- * Response data is provided in the same form as for FPP_ACTION_QUERY action.
- *
+ *  .............................................  
+ *  fpp_fp_table_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY         // Action
+ *    .table_info.t.table_name = "...",  // Name of an existing FP table.
+ *  };
+ *    
+ *  fpp_fp_table_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_FP_TABLE,
+ *                  sizeof(fpp_fp_table_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci.table_info.r' now holds properties of the first FP rule from
+ *  //  the requested FP table.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_FP_TABLE,
+ *                  sizeof(fpp_fp_table_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci.table_info.r' now holds properties of the next FP rule from 
+ *  //  the requested FP table.
+ *  .............................................  
+ * @endcode 
+ * @note There is currently no way to read a list of existing FP tables from PFE.
+ * 
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c ENOENT @c (-2)
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the FP table query session (no more FP @b rules in the requested table).
+ *        - For other ACTIONs: Unknown (nonexistent) FP table was requested.
+ * - @c EEXIST @c (-17) <br>
+ *        Requested FP table already exists (is already registered).
+ * - @c EACCES @c (-13) <br>
+ *        Requested FP table cannot be destroyed (is probably in use by some PFE feature).
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
+ * 
  * @hideinitializer
  */
 #define FPP_CMD_FP_TABLE						0xf220
 
 /**
- * @def FPP_CMD_FP_RULE
- * @brief Administers the Flexible Parser rules
- * @details Each Flexible Parser rule consists of a condition specified by @c data, @c mask and @c offset triplet and
- *          action to be performed. If 32-bit frame data at given @c offset masked by @c mask is equal to the specified
- *          @c data masked by the same @c mask then the condition is true. An invert flag may be set to invert the condition
- *          result. The rule action may be either @c accept, @c reject or @c next_rule which means to continue with a specified rule.
- *
- *          The rule administering command may be one of the following actions:
- *           - @c FPP_ACTION_REGISTER: Create a new rule.
- *           - @c FPP_ACTION_DEREGISTER: Delete an existing rule.
- *           - @c FPP_ACTION_QUERY: Return the first rule (among all existing rules).
- *           - @c FPP_ACTION_QUERY_CONT: Return the next rule.
- *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_fp_rule_cmd_t cmd_data =
- *   {
- *      // Creates a new rule
- *      .action = FPP_ACTION_REGISTER,
- *      // Unique up-to-15-character rule identifier
- *      .r.rule_name = "rule_name",
- *      // 32-bit data to match with the frame data at given offset (network endian)
- *      .r.data = htonl(0x08000000),
- *      // 32-bit mask to apply on the frame data and .r.data before comparison (network endian)
- *      .r.mask = htonl(0xFFFF0000),
- *      // Offset of the frame data to be compared (network endian)
- *      .r.offset = htonl(12),
- *      // Invert match or not (values 0 or 1)
- *      .r.invert = 0,
- *      // How to calculate the offset
- *      .r.match_action = FP_OFFSET_FROM_L2_HEADER,
- *      // Action to be done on match
- *      .r.offset_from = FP_ACCEPT,
- *      // Identifier of the next rule to use when match_action == FP_NEXT_RULE
- *      .r.next_rule_name = "rule_name2"
- *   };
- * @endcode
- * This example is used to match and accept all IPv4 frames (16-bit value 0x0800 at bytes 12 and 13,
- * when starting bytes counting from 0).
- * @note All values are specified in the network byte order.
- * @warning It is forbidden to create rule loops using the @a next_rule feature.
- *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_fp_rule_cmd_t cmd_data =
- *   {
- *      .action = FPP_ACTION_DEREGISTER,   // Deletes an existing rule
- *      .r.rule_name = "rule_name",        // Identifier of the rule to be deleted
- *   };
- * @endcode
- *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * Items to be set in command argument structure:
+ * @def         FPP_CMD_FP_RULE
+ * @brief       FCI command for management of Flexible Parser rules.
+ * @details     Related topics: @ref flex_parser
+ * @details     Related data types: @ref fpp_fp_rule_cmd_t, @ref fpp_fp_rule_props_t
+ * @details     Each FP rule consists of a condition specified by the following properties:
+ *              `.data`, `.mask` and `.offset` + `.offset_from`. FP rule then works as follows: 
+ *              32-bit data value from the inspected Ethernet frame (at given @c offset_from + 
+ *              @c offset position, masked by the @c mask) is compared with the @c data value 
+ *              (masked by the same @c mask). If the values are equal, then condition of the FP rule 
+ *              is true. An invert flag may be set to invert the condition result.
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new FP rule.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing FP rule.
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of an FP rule.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) an FP rule query session and get properties 
+ *                   of the first FP rule from the internal collective list of all 
+ *                   FP rules (regardless of FP table affiliation).
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next FP rule
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
+ *
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new FP rule. For detailed info about FP rule properties, see fpp_fp_rule_cmd_t.
  * @code{.c}
- *   fpp_flexible_parser_rule_cmd cmd_data =
- *   {
- *      .action = FPP_ACTION_QUERY       // Start the rules query
- *   };
+ *  .............................................  
+ *  fpp_fp_rule_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_REGISTER,  // Action
+ *    .r.rule_name = "...",           // Rule name. A string of up to 15 characters + '\0'.
+ *    .r.data      = ...,             // Expected data. [NBO]
+ *    .r.mask      = ...,             // Bitmask. [NBO]
+ *    .r.offset    = ...,             // Offset (in bytes). [NBO]
+ *    .r.invert    = ...,             // Invert the match result.
+ *    
+ *    .r.next_rule_name = "...",      // Name of the FP rule to jump to if '.match_action' ==
+ *                                    // FP_NEXT_RULE. Set all-zero if unused.
+ *    
+ *    .r.match_action = ...,          // Action to do if the inspected frame matches
+ *                                    // the FP rule criteria.
+ *    
+ *    .r.offset_from = ...            // Header for offset calculation.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FP_RULE, sizeof(fpp_fp_rule_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Response data type for queries: @ref fpp_fp_rule_cmd_t
- *
- * Response data provided:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing FP rule.
  * @code{.c}
- *   rsp_data.r.name;             // Name of the rule
- *   rsp_data.r.data;             // Expected data value (network endian)
- *   rsp_data.r.mask;             // Mask to be applied on frame data (network endian)
- *   rsp_data.r.offset;           // Offset of the data in the frame (network endian)
- *   rsp_data.r.invert;           // Invert match or not
- *   rsp_data.r.match_action;     // Action to be done on match
- *   rsp_data.r.next_rule_name;   // Next rule to be examined if match_action == FP_NEXT_RULE
+ *  .............................................  
+ *  fpp_fp_rule_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_DEREGISTER,  // Action
+ *    .r.rule_name = "...",             // Name of an existing FP rule.
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FP_RULE, sizeof(fpp_fp_rule_cmd_t), 
+ *                                                 (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
- * @note All data is provided in the network byte order.
+ * @note FP rule cannot be destroyed if it is a member of some FP table.
+ *       First remove the rule from the table, then destroy the rule.
  *
- * Action FPP_ACTION_QUERY_CONT
- * ----------------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of an FP rule. Query result is stored in the member `.r`.
  * @code{.c}
- *   fpp_flexible_parser_rule_cmd cmd_data =
- *   {
- *      .action = FPP_ACTION_QUERY_CONT    // Continue with the rules query
- *   };
- * @endcode
- *
- * Response data is provided in the same form as for FPP_ACTION_QUERY action.
+ *  .............................................  
+ *  fpp_fp_rule_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_fp_rule_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_FP_RULE,
+ *                  sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci.r' now holds properties of the first FP rule from
+ *  //  the internal collective list of all FP rules.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_FP_RULE,
+ *                  sizeof(fpp_fp_rule_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci.r' now holds properties of the next FP rule from 
+ *  //  the internal collective list of all FP rules.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c ENOENT @c (-2)
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the FP rule query session (no more FP rules).
+ *        - For other ACTIONs: Unknown (nonexistent) FP rule was requested.
+ * - @c EEXIST @c (-17) <br>
+ *        Requested FP rule already exists (is already registered).
+ * - @c EACCES @c (-13) <br>
+ *        Requested FP rule cannot be destroyed (is probably a member of some FP table).
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
@@ -1068,106 +1321,128 @@ typedef struct CAL_PACKED_ALIGNED(4)
 #define FPP_ERR_FP_RULE_NOT_FOUND			0xf222
 
 /**
- * @def FPP_ACTION_USE_RULE
- * @brief Flexible Parser specific 'use' action for FPP_CMD_FP_TABLE.
+ * @def     FPP_ACTION_USE_RULE
+ * @brief   Flexible Parser specific 'use' action for FPP_CMD_FP_TABLE.
  * @hideinitializer
  */
 #define FPP_ACTION_USE_RULE 10
 
 /**
- * @def FPP_ACTION_UNUSE_RULE
- * @brief Flexible Parser specific 'unuse' action for FPP_CMD_FP_TABLE.
+ * @def     FPP_ACTION_UNUSE_RULE
+ * @brief   Flexible Parser specific 'unuse' action for FPP_CMD_FP_TABLE.
  * @hideinitializer
  */
 #define FPP_ACTION_UNUSE_RULE 11
 
 /**
- * @brief Specifies the Flexible Parser result on the rule match
+ * @brief       Action to do with an inspected Ethernet frame if the frame matches FP rule criteria.
+ * @details     Related data types: @ref fpp_fp_rule_props_t
+ * @details     Exact meaning of FP_ACCEPT and FP_REJECT (what happens with the inspected frame)
+ *              depends on the context in which the parent FP table is used. See @ref flex_parser.
+ *              Generally (without any further logic inversions), FP_ACCEPT means the frame is
+ *              accepted and processed by PFE, while FP_REJECT means the frame is discarded.
  */
 typedef enum CAL_PACKED
 {
-    FP_ACCEPT,   /**< Flexible parser result on rule match is ACCEPT */
-    FP_REJECT,   /**< Flexible parser result on rule match is REJECT */
-    FP_NEXT_RULE /**< On rule match continue matching by the specified rule */
+    FP_ACCEPT,    /**< Flexible Parser accepts the frame. */
+    FP_REJECT,    /**< Flexible Parser rejects the frame. */
+    FP_NEXT_RULE  /**< Flexible Parser continues with the matching process, but jumps to 
+                       a specific FP rule in the FP table. */
 } fpp_fp_rule_match_action_t;
 
 /**
- * @brief Specifies how to calculate the frame data offset
- * @details The offset may be calculated either from the L2, L3 or L4 header beginning.
- *          The L2 header beginning is also the Ethernet frame beginning because the Ethernet
- *          frame begins with the L2 header. This offset is always valid however if the L3 or
- *          L4 header is not recognized then the rule is always skipped as not-matching.
+ * @brief       Header for offset calculation.
+ * @details     Related data types: @ref fpp_fp_rule_props_t <br>
+ * @details     Offset can be calculated either from the L2, L3 or L4 header beginning.
+ *              The L2 header is also the beginning of an Ethernet frame.
+ * @details     L2 header is always a valid header for offset calculation. Other headers may be missing
+ *              in some Ethernet frames. If an FP rule expects L3/L4 header (for offset calculation) 
+ *              but the given header is missing in the inspected Ethernet frame, then the result 
+ *              of the matching process is "frame does not match FP rule criteria".
  */
 typedef enum CAL_PACKED
 {
-    FP_OFFSET_FROM_L2_HEADER = 2, /**< Calculate offset from the L2 header (frame beginning) */
-    FP_OFFSET_FROM_L3_HEADER = 3, /**< Calculate offset from the L3 header */
-    FP_OFFSET_FROM_L4_HEADER = 4  /**< Calculate offset from the L4 header */
+    FP_OFFSET_FROM_L2_HEADER = 2,  /**< Calculate offset from the L2 header (frame beginning). */
+    FP_OFFSET_FROM_L3_HEADER = 3,  /**< Calculate offset from the L3 header. */
+    FP_OFFSET_FROM_L4_HEADER = 4   /**< Calculate offset from the L4 header. */
 } fpp_fp_offset_from_t;
 
 /**
- * @brief Properties of the Flexible parser rule
- * @details The rule match can be described as:
- * @code{.c}
- *  ((frame_data[offset] & mask) == (data & mask)) ? match = true : match = false;
- *  match = (invert ? !match : match);
- * @endcode
- * Value of match being equal to true causes:
- * - Flexible Parser to stop and return ACCEPT
- * - Flexible Parser to stop and return REJECT
- * - Flexible Parser to set the next rule to rule specified in next_rule_name
+ * @brief       Properties of an FP rule (Flexible Parser rule)
+ * @details     Related data types: @ref fpp_fp_table_cmd_t, @ref fpp_fp_rule_cmd_t
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp_ext.h  fpp_fp_rule_props_t
  */
+/* [fpp_fp_rule_props_t] */
 typedef struct CAL_PACKED
 {
-	/*	Unique identifier of the rule. It is a string up to 15 characters + '\0' */
-    uint8_t rule_name[16];
-	/*	Expected data (network endian) to be found in the frame to match the rule. */
-    uint32_t data;
-	/*	Mask (network endian) to be applied on both expected data and frame data */
-    uint32_t mask;
-	/*	Offset (network endian) of the data in the frame (from L2, L3, or L4 header
-		- see @c offset_from) */
-    uint16_t offset;
-	/*	Invert the match result after match is calculated */
-    uint8_t invert;
-	/*	Specifies a rule to continue matching if this rule matches and the @c match_action
-		is @c FP_NEXT_RULE */
-    uint8_t next_rule_name[16];
-	/*	Specifies the Flexible Parser behavior on rule match */
-    fpp_fp_rule_match_action_t match_action;
-	/*	Specifies layer from which header beginning is @c offset calculated */
-    fpp_fp_offset_from_t offset_from;
+    uint8_t rule_name[16];  /*< Rule name. A string of up to 15 characters + '\0'. */
+    
+    uint32_t data;          /*< Expected data. [NBO]. This value is expected to be found
+                                at the specified offset in the inspected Ethernet frame. */
+    
+    uint32_t mask;          /*< Bitmask [NBO], selecting which bits of a 32bit value shall
+                                be used for data comparison. This bitmask is applied on both
+                                '.data' value and the inspected value for the frame. */
+    
+    uint16_t offset;        /*< Offset (in bytes) of the inspected value in the frame. [NBO]
+                                This offset is calculated from the '.offset_from' header. */
+    
+    uint8_t invert;         /*< Invert the match result before match action is selected. */
+    
+    uint8_t next_rule_name[16];  /*< Name of the FP rule to jump to if '.match_action' ==
+                                     FP_NEXT_RULE. Set all-zero if unused. This next rule must
+                                     be in the same FP table (cannot jump across tables). */
+    
+    fpp_fp_rule_match_action_t match_action;  /*< Action to do if the inspected frame 
+                                                  matches the FP rule criteria. */
+    
+    fpp_fp_offset_from_t offset_from;  /*< Header for offset calculation. */
 } fpp_fp_rule_props_t;
+/* [fpp_fp_rule_props_t] */
 
 /**
- * @brief Arguments for the FPP_CMD_FP_RULE command
+ * @brief       Data structure for an FP rule.
+ * @details     Related FCI commands: @ref FPP_CMD_FP_RULE
+ *
+ * @snippet     fpp_ext.h  fpp_fp_rule_cmd_t
  */
+/* [fpp_fp_rule_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(2)
 {
-    uint16_t action;        /**< Action to be done */
-    fpp_fp_rule_props_t r;  /**< Parameters of the rule */
+    uint16_t action;        /*< Action */
+    fpp_fp_rule_props_t r;  /*< Properties of the rule. */
 } fpp_fp_rule_cmd_t;
+/* [fpp_fp_rule_cmd_t] */
 
 /**
- * @brief Arguments for the FPP_CMD_FP_TABLE command
+ * @brief       Data structure for an FP table.
+ * @details     Related FCI commands: @ref FPP_CMD_FP_TABLE
+ * @note        Some values are in a network byte order [NBO].
+ *
+ * @snippet     fpp_ext.h  fpp_fp_table_cmd_t
  */
+/* [fpp_fp_table_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(2)
 {
-    uint16_t action;                  /**< Action to be done */
+    uint16_t action;                 /*< Action */
     union
     {
         struct
         {
-            uint8_t table_name[16];   /**< Name of the table to be administered by the action */
-            uint8_t rule_name[16];    /**< Name of the rule to be added/removed to/from the table */
-            uint16_t position;        /**< Position where to add rule (network endian) */
+            uint8_t table_name[16];  /*< Name of the FP table to be administered. */
+            uint8_t rule_name[16];   /*< Name of the FP rule to be added/removed. */
+            uint16_t position;       /*< Position in the table where to add the rule. [NBO] */
         } t;
-        fpp_fp_rule_props_t r; /**< Properties of the rule - used as query result */
+        fpp_fp_rule_props_t r;       /*< Query result - properties of a rule from the table */
     } table_info;
 } fpp_fp_table_cmd_t;
-
+/* [fpp_fp_table_cmd_t] */
 
 /**
+ * @cond DOXYGEN__EXCLUDE_THIS_FROM_REFERENCE_MANUAL
+ *
  * @def FPP_CMD_FP_FLEXIBLE_FILTER
  * @brief Uses flexible parser to filter out frames from further processing.
  * @details Allows registration of a Flexible Parser table (see @ref FPP_CMD_FP_TABLE) as a
@@ -1205,12 +1480,18 @@ typedef struct CAL_PACKED_ALIGNED(2)
  * @endcode
  *
  * @hideinitializer
+ *
+ * @endcond
  */
 #define FPP_CMD_FP_FLEXIBLE_FILTER 0xf225
 
-/*
-* @brief Arguments for the FPP_CMD_FP_FLEXIBLE_FILTER command
-*/
+/**
+ * @cond DOXYGEN__EXCLUDE_THIS_FROM_REFERENCE_MANUAL
+ *
+ * @brief Arguments for the FPP_CMD_FP_FLEXIBLE_FILTER command
+ *
+ * @endcond
+ */
 typedef struct CAL_PACKED
 {
     uint16_t action;         /**< Action to be done on Flexible Filter */
@@ -1277,172 +1558,267 @@ typedef struct CAL_PACKED
 } fpp_buf_cmd_t;
 
 /**
- * @def FPP_CMD_SPD
- * @brief Configures the SPD (Security Policy Database) for IPsec
- * @note The feature is available only for some Premium firmware versions and it shall not be used
- *       with firmware not supporting the IPsec to avoid undefined behavior.
- * @details The command is connected with @c fpp_spd_cmd_t type and allows complete SPD management
- *          which involves insertion of an entry at a given position (@c FPP_ACTION_REGISTER), removal
- *          of an entry at a given position (@c FPP_ACTION_DEREGISTER) and reading the database data
- *          (@c FPP_ACTION_QUERY and @c FPP_ACTION_QUERY_CONT).
- *
- * Action FPP_ACTION_REGISTER
- * --------------------------
- * The FPP_ACTION_REGISTER action adds an entry at a given position into the SPD belonging
- * to a given physical interface. The SPD is created if the entry is the 1st one and the position
- * is ignored in such case. Creation of the SPD enables the IPsec processing for given interface.
- *
- * Items to be set in command argument structure:
+ * @def         FPP_CMD_SPD
+ * @brief       FCI command for management of the IPsec offload (SPD entries).
+ * @details     Related topics: @ref ipsec_offload
+ * @details     Related data types: @ref fpp_spd_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_REGISTER <br>
+ *                   Create a new SPD entry.
+ *              - @c FPP_ACTION_DEREGISTER <br>
+ *                   Remove (destroy) an existing SPD entry.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) an SPD entry query session and get properties 
+ *                   of the first SPD entry from the SPD database of a target physical interface.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next SPD entry
+ *                   from the SPD database of the target physical interface.
+ *                   Intended to be called in a loop (to iterate through the database).
+ *
+ *              @b WARNING: <br>
+ *              The IPsec offload feature is available only for some Premium versions of PFE firmware.
+ *              The feature should @b not be used with a firmware which does not support it.
+ *              Failure to adhere to this warning will result in an undefined behavior of PFE.
+ *
+ * FPP_ACTION_REGISTER
+ * -------------------
+ * Create a new SPD entry in the SPD database of a target physical interface.
  * @code{.c}
- *   fpp_spd_cmd_t cmd_data =
- *   {
- *      // Set the new rule in SPD
- *      .action = FPP_ACTION_REGISTER,
- *      // Name of the physical interface which SPD shall be modified
- *      .name = "emac0",
- *      // Add as a 4th rule (1st rule used position 0), current 4th rule will follow the newly added rule
- *      .position = 3,
- *      // Set the traffic matching criteria
- *      .saddr = 0xC0A80101, //192.168.1.1
- *      .daddr = 0xC0A80102, //192.168.1.2
- *      .protocol = 17,      //UDP
- *      .sport = 0,          //Source port - not set, see the .flags
- *      .dport = 0,          //Destination port - not set, see the .flags
- *      // Set ports as opaque i.e. ignored, missing FPP_SPD_FLAG_IPv6 means IPv4 traffic
- *      .flags = FPP_SPD_FLAG_SPORT_OPAQUE | FPP_SPD_FLAG_DPORT_OPAQUE
- *      .spi = 1,            //SPI to match in ESP or AH header (used only for action FPP_SPD_ACTION_PROCESS_DECODE)
- *      // Set action for matching traffic
- *      .spd_action = FPP_SPD_ACTION_PROCESS_DECODE, //Do IPsec decoding
- *      .sa_id = 1,          //HSE SAD entry ID to be used to process the traffic
- *   }
+ *  .............................................  
+ *  fpp_spd_cmd_t cmd_to_fci = 
+ *  {
+ *    .action   = FPP_ACTION_REGISTER,  // Action
+ *      
+ *    .name     = "...",  // Physical interface name (see chapter Physical Interface).
+ *    .flags    =  ...,   // SPD entry flags. A bitset.
+ *    .position =  ...,   // Entry position. [NBO]
+ *    .saddr    = {...},  // Source IP address. [NBO]
+ *    .daddr    = {...},  // Destination IP address. [NBO]
+ *      
+ *    .sport    =  ...,   // Source port. [NBO]
+ *                        // Optional (does not have to be set). See '.flags'.
+ *      
+ *    .dport    =  ...,   // Destination port. [NBO]
+ *                        // Optional (does not have to be set). See '.flags'.
+ *      
+ *    .protocol =  ...,   // IANA IP Protocol Number (protocol ID).
+ *      
+ *    .sa_id    =  ...,   // SAD entry identifier for HSE. [NBO]
+ *                        // Used only when '.spd_action' == SPD_ACT_PROCESS_ENCODE). 
+ *      
+ *    .spi      =  ...    // SPI to match in the ingress traffic. [NBO]
+ *                        // Used only when '.spd_action' == SPD_ACT_PROCESS_DECODE).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(cliet, FPP_CMD_SPD, sizeof(fpp_spd_cmd_t), 
+ *                                     (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_DEREGISTER
- * ----------------------------
- * The FPP_ACTION_DEREGISTER action removes an entry at a given position in the SPD belonging
- * to a given physical interface. The SPD is destroyed if the entry is the last one which disables
- * the IPsec support on the given interface.
- *
- * Items to be set in command argument structure:
+ * FPP_ACTION_DEREGISTER
+ * ---------------------
+ * Remove (destroy) an existing SPD entry.
  * @code{.c}
- *   fpp_flexible_filter_cmd_t cmd_data =
- *   {
- *      // Disable the Flexible Filter
- *      .action = FPP_ACTION_DEREGISTER,
- *      // Name of the physical interface which SPD shall be modified
- *      .name = "emac0",
- *      // Remove the 4th rule (1st rule used position 0)
- *      .position = 3,
- *   }
+ *  .............................................  
+ *  fpp_spd_cmd_t cmd_to_fci = 
+ *  {
+ *    .action   = FPP_ACTION_DEREGISTER,  // Action
+ *    .name     = "...",  // Physical interface name (see chapter Physical Interface).
+ *    .position =  ...,   // Entry position. [NBO]
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(cliet, FPP_CMD_SPD, sizeof(fpp_spd_cmd_t), 
+ *                                     (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
  * @endcode
  *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * Items to be set in command argument structure:
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of an SPD entry.
  * @code{.c}
- *   fpp_spd_cmd_t cmd_data =
- *   {
- *      .action = FPP_ACTION_QUERY       // Start the rules query
- *      // Name of the physical interface which SPD shall be queried
- *      .name = "emac0",
- *   };
+ *  .............................................  
+ *  fpp_spd_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *    .name   = "...",  // Physical interface name (see chapter Physical Interface).
+ *  };
+ *    
+ *  fpp_spd_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_SPD,
+ *                  sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first SPD entry from 
+ *  //  the SPD database of the target physical interface..
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_SPD,
+ *                  sizeof(fpp_spd_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next SPD entry from 
+ *  //  the SPD database of the target physical interface.
+ *  .............................................  
  * @endcode
  *
- * Response data type for queries: @ref fpp_spd_cmd_t
- *
- * Response data provided has the same format as FPP_ACTION_REGISTER action.
- * @note All data is provided in the network byte order.
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_IF_ENTRY_NOT_FOUND
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the SPD entry query session (no more SPD entries).
+ *        - For other ACTIONs: Unknown (nonexistent) SPD entry was requested.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
- * Action FPP_ACTION_QUERY_CONT
- * ----------------------------
- * Items to be set in command argument structure:
- * @code{.c}
- *   fpp_spd_cmd_t cmd_data =
- *   {
- *      .action = FPP_ACTION_QUERY_CONT    // Continue with the rules query
- *      // Name of the physical interface which SPD shall be queried
- *      .name = "emac0",
- *   };
- * @endcode
  * @hideinitializer
  */
 #define FPP_CMD_SPD 0xf226
 
 /**
-* @brief Sets the action to be done for frames matching the SPD entry criteria
-*/
+ * @brief       Action to be done for frames matching the SPD entry criteria.
+ * @details     Related data types: @ref fpp_spd_cmd_t
+ */
 typedef enum CAL_PACKED
 {
-	FPP_SPD_ACTION_INVALID = 0U,	/* Undefined action - do not set this one */
-	FPP_SPD_ACTION_DISCARD,			/* Discard the frame */
-	FPP_SPD_ACTION_BYPASS,			/* Bypass IPsec and forward normally */
-	FPP_SPD_ACTION_PROCESS_ENCODE,	/* Process IPsec */
-	FPP_SPD_ACTION_PROCESS_DECODE	/* Process IPsec */
+    FPP_SPD_ACTION_INVALID = 0U,    /**< RESERVED (do not use) */
+    FPP_SPD_ACTION_DISCARD,         /**< Discard the frame. */
+    FPP_SPD_ACTION_BYPASS,          /**< Bypass IPsec and forward normally. */
+    FPP_SPD_ACTION_PROCESS_ENCODE,  /**< Send to HSE for encoding. */
+    FPP_SPD_ACTION_PROCESS_DECODE   /**< Send to HSE for decoding. */
 } fpp_spd_action_t;
 
 /**
-* @brief Flags values to be used in fpp_spd_cmd_t structure .flags field.
-*/
+ * @brief       Flags for SPD entry.
+ * @details     Related data types: @ref fpp_spd_cmd_t
+ */
 typedef enum CAL_PACKED
 {
-	FPP_SPD_FLAG_IPv6 = (1U << 1U),			/* IPv4 if not set, IPv6 if set */
-	FPP_SPD_FLAG_SPORT_OPAQUE = (1U << 2U),	/* Do not match Source PORT */
-	FPP_SPD_FLAG_DPORT_OPAQUE = (1U << 3U),	/* Do not match Destination PORT */
+    FPP_SPD_FLAG_IPv6 = (1U << 1U),         /**< IPv4 if this flag @b not set. IPv6 if set. */
+    FPP_SPD_FLAG_SPORT_OPAQUE = (1U << 2U), /**< Do @b not match @c fpp_spd_cmd_t.sport. */
+    FPP_SPD_FLAG_DPORT_OPAQUE = (1U << 3U), /**< Do @b not match @c fpp_spd_cmd_t.dport. */
 } fpp_spd_flags_t;
 
 /**
- * @brief Argument structure for the FPP_CMD_SPD command
+ * @brief       Data structure for an SPD entry.
+ * @details     Related FCI commands: @ref FPP_CMD_SPD
+ * @note        Some values are in a network byte order [NBO].
+ * @note        HSE is a Hardware Security Engine, a separate HW accelerator.
+ *              Its configuration is outside the scope of this document.
+ *
+ * @snippet     fpp_ext.h  fpp_spd_cmd_t
  */
+/* [fpp_spd_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	uint16_t action;			/**< Action */
-	char name[IFNAMSIZ];		/**< Interface name */
-	fpp_spd_flags_t flags;
-	uint16_t position;			/**< Rule position (0 = 1st one, X = insert before Xth rule, if X > count then add as a last one) */
-	uint32_t saddr[4];			/**< Source IP address (IPv4 uses only 1st word) */
-	uint32_t daddr[4];			/**< Destination IP address (IPv4 uses only 1st word) */
-	uint16_t sport;				/**< Source port */
-	uint16_t dport;				/**< Destination port */
-	uint8_t protocol;			/**< Protocol ID: TCP, UDP */
-	uint32_t sa_id;				/**< SAD entry identifier (used only for actions SPD_ACT_PROCESS_ENCODE) */
-	uint32_t spi;				/**< SPI to match if action is FPP_SPD_ACTION_PROCESS_DECODE */
-	fpp_spd_action_t spd_action;	/**< Action to be done on the frame */
+    uint16_t action;        /*< Action */
+    char name[IFNAMSIZ];    /*< Physical interface name. */
+    fpp_spd_flags_t flags;  /*< SPD entry flags. A bitset. */
+    
+    uint16_t position;      /*< Entry position. [NBO]
+                                0 : insert as the first entry of the SPD table.
+                                N : insert as the Nth entry of the SPD table, starting from 0.
+                                Entries are inserted (not overwritten). Already existing 
+                                entries are shifted to make room for the newly inserted one.
+                                If (N > current count of SPD entries) then the new entry
+                                gets inserted as the last entry of the SPD table. */
+    
+    uint32_t saddr[4];      /*< Source IP address. [NBO]
+                                IPv4 uses only element [0]. Address type is set in '.flags' */
+    
+    uint32_t daddr[4];      /*< Destination IP address. [NBO]
+                                IPv4 uses only element [0]. Address type is set in '.flags' */
+    
+    uint16_t sport;         /*< Source port. [NBO]
+                                Optional (does not have to be set). See '.flags' */
+    
+    uint16_t dport;         /*< Destination port. [NBO]
+                                Optional (does not have to be set). See '.flags' */
+                                
+    uint8_t protocol;       /*< IANA IP Protocol Number (protocol ID). */
+    
+    uint32_t sa_id;         /*< SAD entry identifier for HSE. [NBO]
+                                Used only when '.spd_action' == SPD_ACT_PROCESS_ENCODE).
+                                Corresponding SAD entry must exist in HSE. */
+                                
+    uint32_t spi;           /*< SPI to match in the ingress traffic. [NBO]
+                                Used only when '.spd_action' == SPD_ACT_PROCESS_DECODE). */
+    
+    fpp_spd_action_t spd_action;  /*< Action to be done on the frame. */
 } fpp_spd_cmd_t;
+/* [fpp_spd_cmd_t] */
 
 /**
- * @def FPP_CMD_QOS_QUEUE
- * @brief Management of QoS queues
- * @details Command can be used with following `.action` values:
- *          - @c FPP_ACTION_UPDATE: Update queue configuration
- *          - @c FPP_ACTION_QUERY: Get queue properties
- *
- * Command Argument Type: @ref fpp_qos_queue_cmd_t
- *
- * Action FPP_ACTION_UPDATE
- * ------------------------
- * To update queue properties just set
- *   - `fpp_qos_queue_cmd_t.action` to @ref FPP_ACTION_QUERY
- *   - `fpp_qos_queue_cmd_t.if_name` to name of the physical interface and
- *   - `fpp_qos_queue_cmd_t.id` to the queue ID.
- *
- * Rest of the fpp_qos_queue_cmd_t structure members will be considered to be used as the new
- * queue properties. It is recommended to use read-modify-write approach in combination with
- * @ref FPP_ACTION_QUERY.
- *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * Get current queue properties. Set
- *   - `fpp_qos_queue_cmd_t.action` to @ref FPP_ACTION_QUERY
- *   - `fpp_qos_queue_cmd_t.if_name` to name of the physical interface and
- *   - `fpp_qos_queue_cmd_t.id` to the queue ID.
- *
- * Response data type for the query command is fpp_qos_scheduler_cmd_t.
+ * @def         FPP_CMD_QOS_QUEUE
+ * @brief       FCI command for management of Egress QoS queues.
+ * @details     Related topics: @ref egress_qos
+ * @details     Related data types: @ref fpp_qos_queue_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of Egress QoS queue.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Get properties of a target Egress QoS queue.
+ *
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of an Egress QoS queue.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_qos_queue_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_UPDATE,  // Action
+ *    .if_name = "...",              // Physical interface name.
+ *    .id      =  ...,               // Queue ID.
+ *      
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_qos_queue_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_QOS_QUEUE, sizeof(fpp_qos_queue_cmd_t), 
+ *                                            (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Success.
- *     - @c FPP_ERR_QUEUE_NOT_FOUND: Queue not found.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Invalid argument/value.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * FPP_ACTION_QUERY
+ * ----------------
+ * Get properties of a target Egress QoS queue.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_qos_queue_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_QUERY  // Action
+ *    .if_name = "...",            // Physical interface name.
+ *    .id      =  ...              // Queue ID.
+ *  };
+ *    
+ *  fpp_qos_queue_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_QOS_QUEUE,
+ *                  sizeof(fpp_qos_queue_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the target Egress QoS queue.
+ *  .............................................  
+ * @endcode 
+ *
+  * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_QOS_QUEUE_NOT_FOUND <br>
+ *        Unknown (nonexistent) Egress QoS queue was requested.
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
@@ -1455,81 +1831,121 @@ typedef struct CAL_PACKED_ALIGNED(4)
 #define FPP_ERR_QOS_QUEUE_NOT_FOUND	0xf401
 
 /**
- * @brief Argument of the @ref FPP_CMD_QOS_QUEUE command.
+ * @brief       Data structure for QoS queue.
+ * @details     Related FCI commands: @ref FPP_CMD_QOS_QUEUE
+ * @details     Related topics: @ref egress_qos
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_qos_queue_cmd_t
  */
+/* [fpp_qos_queue_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	/**	Action */
-	uint16_t action;
-	/**	Interface name */
-	char if_name[IFNAMSIZ];
-	/**	Queue ID. IDs start with 0 and maximum value depends on the number of
-		available queues within the given interface `.if_name`. See @ref egress_qos. */
-	uint8_t id;
-	/**	Queue mode:
-		- 0 - Disabled. Queue will drop all packets.
-		- 1 - Default. HW implementation-specific. Normally not used.
-		- 2 - Tail drop
-		- 3 - WRED */
-	uint8_t mode;
-	/**	Minimum threshold (network endian). Value is `.mode`-specific:
-		- Disabled, Default: n/a
-		- Tail drop: n/a
-		- WRED: Threshold in number of packets in the queue at which the WRED lowest
-				drop probability zone starts, i.e. if queue fill level is below
-				this threshold the drop probability is 0%.
-	*/
-	uint32_t min;
-	/**	Maximum threshold (network endian). Value is `.mode`-specific:
-		- Disabled, Default: n/a
-		- Tail drop: The queue length in number of packets. Queue length
-					 is the number of packets the queue can accommodate before
-					 drops will occur.
-		- WRED: Threshold in number of packets in the queue at which the WRED highest
-				drop probability zone ends, i.e. if queue fill level is above this
-				threshold the drop probability is 100%.
-	*/
-	uint32_t max;
-	/** WRED drop probabilities for all probability zones in [%]. The lowest probability zone
-		is `.zprob[0]`. Only valid for `.mode = WRED`. Value 255 means 'invalid'. Number of zones
-		per queue is implementation-specific. See the @ref egress_qos. */
-	uint8_t zprob[32];
+    uint16_t action;         /*< Action */
+    char if_name[IFNAMSIZ];  /*< Physical interface name. [ro] */
+    
+    uint8_t id;         /*< Queue ID. [ro]
+                            minimal ID == 0
+                            maximal ID is implementation defined. See Egress QoS. */
+    
+    uint8_t mode;       /*< Queue mode: 
+                            0 == Disabled. Queue will drop all packets.
+                            1 == Default. HW implementation-specific. Normally not used.
+                            2 == Tail drop
+                            3 == WRED */
+    
+    uint32_t min;       /*< Minimum threshold. [NBO]. Value is `.mode`-specific:
+                            - Disabled, Default: n/a
+                            - Tail drop: n/a
+                            - WRED: Threshold in number of packets in the queue at which 
+                                    the WRED lowest drop probability zone starts. 
+                                    While the queue fill level is below this threshold, 
+                                    the drop probability is 0%. */
+    
+    uint32_t max;       /*< Maximum threshold. [NBO]. Value is `.mode`-specific: 
+                            - Disabled, Default: n/a
+                            - Tail drop: The queue length in number of packets. Queue length
+                                         is the number of packets the queue can accommodate 
+                                         before drops will occur.
+                            - WRED: Threshold in number of packets in the queue at which 
+                                    the WRED highest drop probability zone ends.
+                                    While the queue fill level is above this threshold,
+                                    the drop probability is 100%. */
+    
+    uint8_t zprob[32];  /*< WRED drop probabilities for all probability zones in [%]. 
+                            The lowest probability zone is `.zprob[0]`. Only valid for 
+                            `.mode = WRED`. Value 255 means 'invalid'. Number of zones
+                            per queue is implementation-specific. See Egress QoS. */
 } fpp_qos_queue_cmd_t;
+/* [fpp_qos_queue_cmd_t] */
 
 /**
- * @def FPP_CMD_QOS_SCHEDULER
- * @brief Management of QoS scheduler
- * @details Command can be used with following `.action` values:
- *          - @c FPP_ACTION_UPDATE: Update scheduler configuration
- *          - @c FPP_ACTION_QUERY: Get scheduler properties
- *
- * Command Argument Type: @ref fpp_qos_scheduler_cmd_t
- *
- * Action FPP_ACTION_UPDATE
- * ------------------------
- * To update scheduler properties just set
- *   - `fpp_qos_scheduler_cmd_t.action` to @ref FPP_ACTION_QUERY
- *   - `fpp_qos_scheduler_cmd_t.if_name` to name of the physical interface and
- *   - `fpp_qos_scheduler_cmd_t.id` to the scheduler ID.
- *
- * Rest of the fpp_qos_scheduler_cmd_t structure members will be considered to be used as the new
- * scheduler properties. It is recommended to use read-modify-write approach in combination with
- * @ref FPP_ACTION_QUERY.
- *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * Get current scheduler properties. Set
- *   - `fpp_qos_scheduler_cmd_t.action` to @ref FPP_ACTION_QUERY
- *   - `fpp_qos_scheduler_cmd_t.if_name` to name of the physical interface and
- *   - `fpp_qos_scheduler_cmd_t.id` to the scheduler ID.
- *
- * Response data type for the query command is fpp_qos_scheduler_cmd_t.
+ * @def         FPP_CMD_QOS_SCHEDULER
+ * @brief       FCI command for management of Egress QoS schedulers.
+ * @details     Related topics: @ref egress_qos
+ * @details     Related data types: @ref fpp_qos_scheduler_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of Egress QoS scheduler.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Get properties of a target Egress QoS scheduler.
+ *
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of an Egress QoS scheduler.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_qos_scheduler_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_UPDATE,  // Action
+ *    .if_name = "...",              // Physical interface name.
+ *    .id      =  ...,               // Scheduler ID.
+ *      
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_qos_scheduler_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_QOS_SCHEDULER, sizeof(fpp_qos_scheduler_cmd_t), 
+ *                                                (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Success.
- *     - @c FPP_ERR_SCHEDULER_NOT_FOUND: Scheduler not found.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Invalid argument/value.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * FPP_ACTION_QUERY
+ * ----------------
+ * Get properties of a target Egress QoS scheduler.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_qos_scheduler_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_QUERY  // Action
+ *    .if_name = "...",            // Physical interface name.
+ *    .id      =  ...              // Scheduler ID.
+ *  };
+ *    
+ *  fpp_qos_scheduler_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_QOS_SCHEDULER,
+ *                  sizeof(fpp_qos_scheduler_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the target Egress QoS scheduler.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_QOS_SCHEDULER_NOT_FOUND <br>
+ *        Unknown (nonexistent) Egress QoS scheduler was requested.
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
@@ -1542,77 +1958,117 @@ typedef struct CAL_PACKED_ALIGNED(4)
 #define FPP_ERR_QOS_SCHEDULER_NOT_FOUND	0xf411
 
 /**
- * @brief Argument of the @ref FPP_CMD_QOS_SCHEDULER command.
+ * @brief       Data structure for QoS scheduler.
+ * @details     Related FCI commands: @ref FPP_CMD_QOS_SCHEDULER
+ * @details     Related topics: @ref egress_qos
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_qos_scheduler_cmd_t
  */
+/* [fpp_qos_scheduler_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	/**	Action */
-	uint16_t action;
-	/**	Name of physical interface owning the scheduler */
-	char if_name[IFNAMSIZ];
-	/**	Scheduler ID. IDs start with 0 and maximum value depends on the number of
-		available schedulers within the given interface `.if_name`. See @ref egress_qos. */
-	uint8_t id;
-	/**	Scheduler mode:
-		- 0 - Scheduler disabled
-		- 1 - Data rate (payload length)
-		- 2 - Packet rate (number of packets) */
-	uint8_t mode;
-	/**	Scheduler algorithm:
-			- 0 - PQ (Priority Queue). Input with the highest priority
-				  is serviced first. Input 0 has the @b lowest priority.
-			- 1 - DWRR (Deficit Weighted Round Robin)
-			- 2 - RR (Round Robin)
-			- 3 - WRR (Weighted Round Robin) */
-	uint8_t algo;
-	/**	Input enable bitfield (network endian). When a bit `n` is
-		set it means that scheduler input `n` is enabled and connected
-		to traffic source defined by `.source[n]`. Number of inputs is
-		implementation-specific. See the @ref egress_qos. */
-	uint32_t input_en;
-	/**	Input weight (network endian). Scheduler algorithm-specific:
-			- PQ, RR - n/a
-			- WRR, DWRR - Weight in units given by scheduler `.mode` */
-	uint32_t input_w[32];
-	/**	Traffic source ID per scheduler input. Scheduler traffic sources
-		are implementation-specific. See the @ref egress_qos. */
-	uint8_t input_src[32];
+    uint16_t action;        /*< Action */
+    char if_name[IFNAMSIZ]; /*< Physial interface name. [ro] */
+    
+    uint8_t id;             /*< Scheduler ID. [ro]
+                                minimal ID == 0
+                                maximal ID is implementation defined. See Egress QoS. */
+    
+    uint8_t mode;           /*< Scheduler mode: 
+                                0 == Scheduler disabled
+                                1 == Data rate (payload length)
+                                2 == Packet rate (number of packets) */
+    
+    uint8_t algo;           /*< Scheduler algorithm:
+                                0 == PQ (Priority Queue). Input with the highest priority
+                                     is serviced first. Input 0 has the @b lowest priority.
+                                1 == DWRR (Deficit Weighted Round Robin).
+                                2 == RR (Round Robin).
+                                3 == WRR (Weighted Round Robin). */
+    
+    uint32_t input_en;      /*< Input enable bitfield. [NBO]
+                                When a bit `n` is set it means that scheduler input `n`
+                                is enabled and connected to traffic source defined by 
+                                `.source[n]`. Number of inputs is implementation-specific.
+                                See Egress QoS. */
+    
+    uint32_t input_w[32];   /*< Input weight. [NBO]. Scheduler algorithm-specific:
+                                - PQ, RR - n/a
+                                - WRR, DWRR - Weight in units given by `.mode` */
+    
+    uint8_t input_src[32];  /*< Traffic source for each scheduler input. Traffic sources
+                                are implementation-specific. See Egress QoS. */
 } fpp_qos_scheduler_cmd_t;
+/* [fpp_qos_scheduler_cmd_t] */
 
 /**
- * @def FPP_CMD_QOS_SHAPER
- * @brief Management of QoS shaper
- * @details Command can be used with following `.action` values:
- *          - @c FPP_ACTION_UPDATE: Update scheduler configuration
- *          - @c FPP_ACTION_QUERY: Get scheduler properties
- *
- * Command Argument Type: @ref fpp_qos_shaper_cmd_t
- *
- * Action FPP_ACTION_UPDATE
- * ------------------------
- * To update scheduler properties just set
- *   - `fpp_qos_shaper_cmd_t.action` to @ref FPP_ACTION_QUERY
- *   - `fpp_qos_shaper_cmd_t.if_name` to name of the physical interface and
- *   - `fpp_qos_shaper_cmd_t.id` to the shaper ID.
- *
- * Rest of the fpp_qos_shaper_cmd_t structure members will be considered to be used as the new
- * shaper properties. It is recommended to use read-modify-write approach in combination with
- * @ref FPP_ACTION_QUERY.
- *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * Get current scheduler properties. Set
- *   - `fpp_qos_shaper_cmd_t.action` to @ref FPP_ACTION_QUERY
- *   - `fpp_qos_shaper_cmd_t.if_name` to name of the physical interface and
- *   - `fpp_qos_shaper_cmd_t.id` to the shaper ID.
- *
- * Response data type for the query command is fpp_qos_shaper_cmd_t.
+ * @def         FPP_CMD_QOS_SHAPER
+ * @brief       FCI command for management of Egress QoS shapers.
+ * @details     Related topics: @ref egress_qos
+ * @details     Related data types: @ref fpp_qos_shaper_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Modify properties of Egress QoS shaper.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Get properties of a target Egress QoS shaper.
+ *
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Modify properties of an Egress QoS shaper.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_qos_shaper_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_UPDATE,  // Action
+ *    .if_name = "...",              // Physical interface name.
+ *    .id      =  ...,               // Shaper ID.
+ *      
+ *    ... = ...  // Properties (data fields) to be updated, and their new (modified) values.
+ *               // Some properties cannot be modified (see fpp_qos_shaper_cmd_t).
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_QOS_SHAPER, sizeof(fpp_qos_shaper_cmd_t), 
+ *                                             (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Success.
- *     - @c FPP_ERR_SHAPER_NOT_FOUND: Shaper not found.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Invalid argument/value.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
+ * FPP_ACTION_QUERY
+ * ----------------
+ * Get properties of a target Egress QoS shaper.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_qos_shaper_cmd_t cmd_to_fci = 
+ *  {
+ *    .action  = FPP_ACTION_QUERY  // Action
+ *    .if_name = "...",            // Physical interface name.
+ *    .id      =  ...,             // Shaper ID.
+ *  };
+ *    
+ *  fpp_qos_shaper_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_QOS_SHAPER,
+ *                  sizeof(fpp_qos_shaper_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the target Egress QoS shaper.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c FPP_ERR_QOS_SHAPER_NOT_FOUND <br>
+ *        Unknown (nonexistent) Egress QoS shaper was requested.
+ * - @c FPP_ERR_WRONG_COMMAND_PARAM <br>
+ *        Unexpected value of some property.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
@@ -1625,64 +2081,116 @@ typedef struct CAL_PACKED_ALIGNED(4)
 #define FPP_ERR_QOS_SHAPER_NOT_FOUND	0xf421
 
 /**
- * @brief Argument of the @ref FPP_CMD_QOS_SHAPER command.
+ * @brief       Data structure for QoS shaper.
+ * @details     Related FCI commands: @ref FPP_CMD_QOS_SHAPER
+ * @details     Related topics: @ref egress_qos
+ * @note        - Some values are in a network byte order [NBO].
+ * @note        - Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_qos_shaper_cmd_t
  */
+/* [fpp_qos_shaper_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(4)
 {
-	/**	Action */
-	uint16_t action;
-	/**	Interface name */
-	char if_name[IFNAMSIZ];
-	/**	Shaper ID. IDs start with 0 and maximum value depends on the number of
-		available shapers within the given interface `.if_name`. See @ref egress_qos. */
-	uint8_t id;
-	/**	Position of the shaper */
-	uint8_t position;
-	/**	Idle slope in units per second (network endian) */
-	uint32_t isl;
-	/**	Max credit (network endian) */
-	int32_t max_credit;
-	/**	Min credit (network endian) */
-	int32_t min_credit;
-	/**	Shaper mode:
-		- 0 - Shaper disabled
-		- 1 - Data rate. The `isl` is in units of bits-per-second and
-			  `max_credit` with `min_credit` are numbers of bytes.
-		- 2 - Packet rate. The `isl` is in units of packets-per-second
-			  and `max_credit` with `min_credit` are number of packets.*/
-	uint8_t mode;
+    uint16_t action;        /*< Action */
+    char if_name[IFNAMSIZ]; /*< Physial interface name. [ro] */
+    
+    uint8_t id;             /*< Shaper ID. [ro] 
+                                minimal ID == 0
+                                maximal ID is implementation defined. See Egress QoS. */
+    
+    uint8_t position;       /*< Position of the shaper.
+                                Positions are implementation defined. See Egress QoS. */
+    
+    uint32_t isl;           /*< Idle slope in units per second (see `.mode`). [NBO] */
+    int32_t max_credit;     /*< Max credit. [NBO] */
+    int32_t min_credit;     /*< Min credit. [NBO] */
+    
+    uint8_t mode;           /*< Shaper mode:
+                                0 == Shaper disabled
+                                1 == Data rate.
+                                     `.isl` is in bits-per-second.
+                                     `.max_credit` and `.min_credit` are in number of bytes.
+                                2 == Packet rate.
+                                     `isl` is in packets-per-second.
+                                     `.max_credit` and `.min_credit` are in number of packets.
+                                */
 } fpp_qos_shaper_cmd_t;
+/* [fpp_qos_shaper_cmd_t] */
 
 
 /**
- * @def FPP_CMD_FW_FEATURE
- * @brief Management of configurable firmware features
- * @details Command can be used with following `.action` values:
- *          - @c FPP_ACTION_UPDATE: Enable or disable the firmware feature
- *          - @c FPP_ACTION_QUERY: Get information about available features
- *
- * Command Argument Type: @ref fpp_fw_features_cmd_t
- *
- * Action FPP_ACTION_UPDATE
- * ------------------------
- * To enable/disable the selected feature set
- *   - `fpp_fw_features_cmd_t.action` to @ref FPP_ACTION_UPDATE
- *   - `fpp_fw_features_cmd_t.name` to name of the selected feature
- *   - `fpp_fw_features_cmd_t.val` to 0 to disable or 1 to enable the feature.
- *
- * Rest of the fpp_fw_features_cmd_t structure members will be ignored.
- *
- * Action FPP_ACTION_QUERY
- * -----------------------
- * To get information about features set:
- *   - `fpp_fw_features_cmd_t.action` to @ref FPP_ACTION_QUERY or @ref FPP_ACTION_QUERY_CONT
- * Response data type for the query command is fpp_fw_features_cmd_t.
+ * @def         FPP_CMD_FW_FEATURE
+ * @brief       FCI command for management of configurable FW features.
+ * @details     Related topics: ---
+ * @details     Related data types: @ref fpp_fw_features_cmd_t
+ * @details     Supported `.action` values:
+ *              - @c FPP_ACTION_UPDATE <br>
+ *                   Enable/disable a FW feature.
+ *              - @c FPP_ACTION_QUERY <br>
+ *                   Initiate (or reinitiate) a FW feature query session and get properties 
+ *                   of the first FW feature from the internal list of FW features.
+ *              - @c FPP_ACTION_QUERY_CONT <br> 
+ *                   Continue the query session and get properties of the next FW feature
+ *                   from the list. Intended to be called in a loop (to iterate through the list).
+ *
+ * FPP_ACTION_UPDATE
+ * -----------------
+ * Enable/disable a FW feature.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_fw_features_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_UPDATE,  // Action
+ *    .val    = ...                 // 0 == disabled ; 1 == enabled
+ *  };
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_write(client, FPP_CMD_FW_FEATURE, sizeof(fpp_fw_features_cmd_t), 
+ *                                             (unsigned short*)(&cmd_to_fci));
+ *  .............................................  
+ * @endcode
  *
- * Possible command return values are:
- *     - @c FPP_ERR_OK: Success.
- *     - @c FPP_ERR_WRONG_COMMAND_PARAM: Invalid argument/value.
- *     - @c FPP_ERR_INTERNAL_FAILURE: Internal FCI failure.
- *     - @c FPP_ERR_ENTRY_NOT_FOUND: No more entries.
+ * FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT
+ * ------------------------------------------
+ * Get properties of a FW feature.
+ * @code{.c}
+ *  .............................................  
+ *  fpp_fw_features_cmd_t cmd_to_fci = 
+ *  {
+ *    .action = FPP_ACTION_QUERY  // Action
+ *  };
+ *    
+ *  fpp_fw_features_cmd_t reply_from_fci = {0};
+ *  unsigned short reply_length = 0u; 
+ *    
+ *  int rtn = 0;
+ *  rtn = fci_query(client, FPP_CMD_FW_FEATURE,
+ *                  sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the first FW feature from 
+ *  //  the internal list of FW features.
+ *    
+ *  cmd_to_fci.action = FPP_ACTION_QUERY_CONT;
+ *  rtn = fci_query(client, FPP_CMD_FW_FEATURE,
+ *                  sizeof(fpp_fw_features_cmd_t), (unsigned short*)(&cmd_to_fci),
+ *                  &reply_length, (unsigned short*)(&reply_from_fci));
+ *    
+ *  // 'reply_from_fci' now holds properties of the next FW feature from 
+ *  //  the internal list of FW features.
+ *  .............................................  
+ * @endcode 
+ *
+ * Command return values (for all applicable ACTIONs)
+ * --------------------------------------------------
+ * - @c FPP_ERR_OK <br>
+ *        Success
+ * - @c ENOENT @c (-2)
+ *        - For FPP_ACTION_QUERY or FPP_ACTION_QUERY_CONT: The end of the FW feature query session (no more FW features).
+ *        - For other ACTIONs: Unknown (nonexistent) FW feature was requested.
+ * - @c FPP_ERR_INTERNAL_FAILURE <br>
+ *        Internal FCI failure.
  *
  * @hideinitializer
  */
@@ -1691,18 +2199,32 @@ typedef struct CAL_PACKED_ALIGNED(4)
 #define FPP_FEATURE_DESC_SIZE 128
 
 /**
- * @brief Argument of the @ref FPP_CMD_FW_FEATURE command.
+ * @brief       Data structure for FW feature setting.
+ * @details     Related FCI commands: @ref FPP_CMD_FW_FEATURE
+ * @note        Some values cannot be modified by FPP_ACTION_UPDATE [ro].
+ *
+ * @snippet     fpp_ext.h  fpp_fw_features_cmd_t
  */
+/* [fpp_fw_features_cmd_t] */
 typedef struct CAL_PACKED_ALIGNED(2)
 {
-    uint16_t action;                       /**< Action to be done */
-    char name[FPP_FEATURE_NAME_SIZE + 1];  /**< Feature name (only queries, cannot be modified) */
-    char desc[FPP_FEATURE_DESC_SIZE + 1];  /**< Feature description (only queries, cannot be modified) */
-    uint8_t val;                           /**< Value update: to be set / query: which is currently set for the feature */
-    uint8_t variant;                       /**< Feature configuration variant 0=always disabled, 1=always enabled, 2=configurable */
-    uint8_t def_val;                       /**< Default value for configurable variant */
-    uint8_t reserved;                      /**< Reserved value */
+    uint16_t action;                       /*< Action */
+    char name[FPP_FEATURE_NAME_SIZE + 1];  /*< Feature name. [ro] */
+    char desc[FPP_FEATURE_DESC_SIZE + 1];  /*< Feature description. [ro] */
+    
+    uint8_t val;        /*< Feature current state.
+                            0 == disabled ; 1 == enabled */
+    
+    uint8_t variant;    /*< Feature configuration variant. [ro]
+                            0 == ignores '.val' and is always disabled
+                            1 == ignores '.val' and is always enabled
+                            2 == feature is runtime-configurable */
+    
+    uint8_t def_val;    /*< Factory default value of the '.val' property. [ro] */
+    
+    uint8_t reserved;   /*< RESERVED (do not use) */
 } fpp_fw_features_cmd_t;
+/* [fpp_fw_features_cmd_t] */
 
 #endif /* FPP_EXT_H_ */
 
diff --git a/sw/xfci/libfci/public/libfci.h b/sw/xfci/libfci/public/libfci.h
index 69cacbc..f02ef9c 100644
--- a/sw/xfci/libfci/public/libfci.h
+++ b/sw/xfci/libfci/public/libfci.h
@@ -8,35 +8,36 @@
  * ========================================================================= */
 
 /**
- * @defgroup    dxgrLibFCI LibFCI
- * @brief       This is the Fast Control Interface available to host applications to
+ * @defgroup    dxgrLibFCI  LibFCI
+ * @brief       This is Fast Control Interface available for host applications to
  *              communicate with the networking engine.
  * @details     The FCI is intended to provide a generic configuration and monitoring interface
- *              to networking acceleration HW. Provided API shall remain the same within all
+ *              for the networking acceleration HW. Provided API shall remain the same within all
  *              HW/OS-specific implementations to keep dependent applications portable across
  *              various systems.
  *
  *              The LibFCI is not directly touching the HW. Instead, it only passes commands to
- *              dedicated software component (OS/HW-specific endpoint) and receives return values.
+ *              a dedicated software component (OS/HW-specific endpoint) and receives return values.
  *              The endpoint is then responsible for HW configuration. This approach supports
- *              kernel-user space deployment where user space contains only API and the logic is
+ *              a kernel-user space deployment where the user space contains only API and the logic is
  *              implemented in kernel.
  *
  *              Implementation uses appropriate transport mechanism to pass data between
- *              LibFCI user and the endpoint. For reference, in Linux netlink socket will be used,
- *              in QNX it will be a message.
- *
- *              Usage scenario example - FCI command execution:
- *              -# User calls @ref fci_open() to get the @ref FCI_CLIENT instance, use FCI_GROUP_NONE
- *                 as multicast group mask.
- *              -# User calls @ref fci_cmd() to send a command with arguments to the endpoint.
- *              -# Endpoint receives the command and performs requested actions.
- *              -# Endpoint generates response and sends it back to the client.
- *              -# Client receives the response and informs the caller.
- *              -# User calls @ref fci_close() to finalize the @ref FCI_CLIENT instance.
+ *              LibFCI user and the endpoint. For reference: in Linux a netlink socket is used;
+ *              in QNX a message is used.
+ *
+ * @section     how_to_use  How to use the FCI API
+ * @subsection  fciuse_cmd Sending FCI commands
+ *              -# Call @ref fci_open() to get an @ref FCI_CLIENT instance, using @ref FCI_GROUP_NONE
+ *                 as a multicast group mask. This opens a connection to an FCI endpoint.
+ *              -# Call @ref fci_write() or @ref fci_query() to send a command to the endpoint. <br> See @ref fci_cs.
+ *                 - Endpoint receives the command and executes requested actions.
+ *                 - Endpoint generates a response and sends it back to the client.
+ *              -# [optional] Repeat the previous step to send all requested FCI commands.
+ *              -# Call @ref fci_close() to finalize the @ref FCI_CLIENT instance.
  *
  * @if INCLUDE_ASYNC_DESC
- *              Usage scenario example - asynchronous message processing:
+ * @subsection  fciuse_msg  Asynchronous message processing
  *              -# User calls @ref fci_open() to get the @ref FCI_CLIENT instance. It is
  *                 important to set @ref FCI_GROUP_CATCH bit in multicast group mask.
  *              -# User calls @ref fci_register_cb() to register custom function for handling
@@ -51,34 +52,36 @@
  *              -# User calls fci_close() to finalize the @ref FCI_CLIENT instance.
  * @endif
  *
- * @section a_and_d Acronyms and Definitions
- *              - <b>Physical Interface:</b> Interface physically able to send and receive data
- *                (EMAC, HIF). Physical interfaces are pre-defined and can't be added or removed in
- *                runtime. Every physical interface has associated a @b default logical interface and
- *                set of properties like classification algorithm.
- *              - <b>Logical Interface:</b> Extension of physical interface defined by set of rules
- *                which describes Ethernet traffic. Intended to be used to dispatch traffic being
- *                received via particular physical interfaces using 1:N association i.e. traffic
- *                received by a physical interface can be classified and distributed to N logical
- *                interfaces. These can be either connected to SW stack running in host system or
- *                just used to distribute traffic to an arbitrary physical interface(s). Logical
- *                interfaces are dynamic objects and can be created and destroyed in runtime.
- *              - <b>Classification Algorithm:</b> Way how ingress traffic is being processed by
- *                the PFE firmware.
- *              - <b>Route:</b> Routes are representing direction where matching traffic shall be
- *                forwarded to. Every route specifies egress physical interface and MAC address
- *                of next network node.
- *              - <b>Conntrack:</b> "Tracked connection", a data structure containing information
- *                about a connection. In context of this document it always refers
- *                to an IP connection (TCP, UDP, other). Term is equal to 'routing table entry'.
- *                Conntracks contain reference to routes which shall be used in case when a packet
- *                is matching the conntrack properties.
- *
- * @section lfs Functions Summary
+ * @section     a_and_d  Acronyms and Definitions
+ *              - <b>PFE:</b> <br>
+ *                Packet Forwarding Engine. A dedicated HW component (networking accelerator) 
+ *                which is configured by this FCI API.
+ *              - <b>NBO:</b> <br>
+ *                Network Byte Order. When working with values or properties which are stored in [NBO], 
+ *                consider using appropriate endianess conversion functions.
+ *              - <b>L2/L3/L4:</b> <br>
+ *                Layers of the OSI model.
+ *              - <b>Physical Interface:</b> <br>
+ *                See @ref mgmt_phyif.
+ *              - <b>Logical Interface:</b> <br> 
+ *                See @ref mgmt_logif.
+ *              - <b>Classification Algorithm:</b> <br>
+ *                Method how ingress traffic is processed by the PFE firmware.
+ *              - <b>Route:</b> <br> @anchor ref__route
+ *                In the context of PFE, a route represents a direction where the matching 
+ *                traffic shall be forwarded to. Every route specifies an egress physical interface
+ *                and a MAC address of the next network node.
+ *              - <b>Conntrack:</b> <br> @anchor ref__conntrack
+ *                "Tracked connection", a data structure with information about a connection.
+ *                In the context of PFE, it always refers to an IP connection (TCP, UDP, other).
+ *                The term is equal to a 'routing table entry'. Each conntrack is linked with some @b route.
+ *                The route is used to forward traffic that matches the conntrack's properties.
+ *
+ * @section     lfs  Functions Summary
  *              - @ref fci_open() <br>
- *                <i>Connect to endpoint and create client instance.</i>
+ *                <i>Connect to endpoint and create a client instance.</i>
  *              - @ref fci_close() <br>
- *                <i>Close connection and destroy the client instance.</i>
+ *                <i>Close a connection to endpoint and destroy the client instance.</i>
  *              - @ref fci_write() <br>
  *                <i>Execute FCI command without data response.</i>
  *              - @ref fci_cmd() <br>
@@ -88,47 +91,47 @@
  *              - @ref fci_catch() <br>
  *                <i>Poll for and process received asynchronous messages.</i>
  *              - @ref fci_register_cb() <br>
- *                <i>Register callback to be called in case of received message.</i>
+ *                <i>Register a callback to be called in case of a received message.</i>
  *
- * @section fci_cs Commands Summary
+ * @section     fci_cs  Commands Summary
  *              - @ref FPP_CMD_PHY_IF <br>
  *                <i>Management of physical interfaces.</i>
  *              - @ref FPP_CMD_LOG_IF <br>
  *                <i>Management of logical interfaces.</i>
  *              - @ref FPP_CMD_IF_LOCK_SESSION <br>
- *                <i>Get exclusive access to interfaces.</i>
+ *                <i>Get exclusive access to interface database.</i>
  *              - @ref FPP_CMD_IF_UNLOCK_SESSION <br>
- *                <i>Cancel exclusive access to interfaces.</i>
+ *                <i>Cancel exclusive access to interface database.</i>
  *              - @ref FPP_CMD_L2_BD <br>
- *                <i>L2 bridge domains management.</i>
+ *                <i>Management of L2 bridge domains.</i>
+ *              - @ref FPP_CMD_L2_STATIC_ENT <br>
+ *                <i>Management of L2 static entries.</i>
  *              - @ref FPP_CMD_L2_FLUSH_LEARNED <br>
- *                <i>Remove all learned MAC table entries.</i>
+ *                <i>Remove all dynamically learned MAC table entries.</i>
  *              - @ref FPP_CMD_L2_FLUSH_STATIC <br>
  *                <i>Remove all static MAC table entries.</i>
  *              - @ref FPP_CMD_L2_FLUSH_ALL <br>
  *                <i>Remove all MAC table entries.</i>
  *              - @ref FPP_CMD_FP_TABLE <br>
- *                <i>Administration of @ref flex_parser tables.</i>
+ *                <i>Management of @ref flex_parser tables.</i>
  *              - @ref FPP_CMD_FP_RULE <br>
- *                <i>Administration of @ref flex_parser rules.</i>
- *              - @ref FPP_CMD_FP_FLEXIBLE_FILTER <br>
- *                <i>Utilization of @ref flex_parser to filter out (drop) frames.</i>
+ *                <i>Management of @ref flex_parser rules.</i>
  *              - @ref FPP_CMD_IPV4_RESET <br>
- *                <i>Reset IPv4 (routes, conntracks, ...).</i>
+ *                <i>Remove all IPv4 routes and conntracks.</i>
  *              - @ref FPP_CMD_IPV6_RESET <br>
- *                <i>Reset IPv6 (routes, conntracks, ...).</i>
+ *                <i>Remove all IPv6 routes and conntracks.</i>
  *              - @ref FPP_CMD_IP_ROUTE <br>
  *                <i>Management of IP routes.</i>
  *              - @ref FPP_CMD_IPV4_CONNTRACK <br>
- *                <i>Management of IPv4 connections.</i>
+ *                <i>Management of IPv4 conntracks.</i>
  *              - @ref FPP_CMD_IPV6_CONNTRACK <br>
- *                <i>Management of IPv6 connections.</i>
+ *                <i>Management of IPv6 conntracks.</i>
  *              - @ref FPP_CMD_IPV4_SET_TIMEOUT <br>
- *                <i>Configuration of connection timeouts.</i>
+ *                <i>Configuration of conntrack timeouts.</i>
  *              - @ref FPP_CMD_DATA_BUF_PUT <br>
  *                <i>Send arbitrary data to the accelerator.</i>
  *              - @ref FPP_CMD_SPD <br>
- *                <i>Configure the IPsec offload.</i>
+ *                <i>Management of the IPsec offload.</i>
  *              - @ref FPP_CMD_QOS_QUEUE <br>
  *                <i>Management of @ref egress_qos queues.</i>
  *              - @ref FPP_CMD_QOS_SCHEDULER <br>
@@ -136,545 +139,763 @@
  *              - @ref FPP_CMD_QOS_SHAPER <br>
  *                <i>Management of @ref egress_qos shapers.</i>
  *
- * @section cbks Events summary
+ * @section     cbks  Events summary
  * @if FCI_EVENTS_IMPLEMENTED
  *              - @ref FPP_CMD_IPV4_CONNTRACK_CHANGE <br>
- *                <i>Endpoint reports event related to IPv4 connection.</i>
+ *                <i>Endpoint reports events related to IPv4 conntracks.</i>
  *              - @ref FPP_CMD_IPV6_CONNTRACK_CHANGE <br>
- *                <i>Endpoint reports event related to IPv6 connection.</i>
+ *                <i>Endpoint reports events related to IPv6 conntracks.</i>
  * @endif
  *              - @ref FPP_CMD_DATA_BUF_AVAIL <br>
- *                <i>Network accelerator sends a data buffer to host.</i>
- *
- * @section if_mgmt Interface Management
- *              Physical Interface
- *              ------------------
- *              Physical interfaces are static objects and are defined at startup.
- *              LibFCI client can get a list of currently available physical interfaces using query
- *              option of the @ref FPP_CMD_PHY_IF command. Every physical interface contains
- *              a list of logical interfaces. Without any configuration all physical interfaces are
- *              in default operation mode. It means that all ingress traffic is processed using only
- *              associated @b default logical interface. Default logical interface is always the tail
- *              of the list of associated logical interfaces. When new logical interface is associated,
- *              it is placed at head position of the list so the default one remains on tail. User
- *              can change the used classification algorithm via update option of the
- *              @ref FPP_CMD_PHY_IF command.
- *
- *              Here are supported operations related to physical interfaces:
+ *                <i>Network accelerator sends a data buffer to a host.</i>
+ *
+ * @section     if_mgmt  Interface Management
+ * @subsection  mgmt_phyif  Physical Interface
+ *              Physical interfaces are static objects (defined at startup), which represent hardware
+ *              interfaces of PFE. They are used by PFE for ingress/egress of network traffic. 
+ *
+ *              Physical interfaces have several configurable properties. See @ref FPP_CMD_PHY_IF 
+ *              and @ref fpp_phy_if_cmd_t. Among all these properties, a `.mode` property
+ *              is especially important. Mode of a physical interface specifies which classification 
+ *              algorithm shall be applied on ingress traffic of the interface.
+ *
+ *              Every physical interface can have a list of logical interfaces.
+ *              By default, all physical interfaces are in a default mode (@ref FPP_IF_OP_DEFAULT).
+ *              In the default mode, ingress traffic of a given physical interface is processed using
+ *              only the associated @b default @ref mgmt_logif.
+ *
+ *              <br>
+ *              Supported FCI operations related to physical interfaces:
  *
  *              To @b list available physical interfaces:
- *              -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *              -# Read first interface via @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_QUERY.
- *              -# Read next interface(s) via @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_QUERY_CONT.
- *              -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
- *
- *              To @b modify a physical interface (read-modify-write):
- *              -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *              -# Read interface properties via @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_QUERY +
- *                 @ref FPP_ACTION_QUERY_CONT.
- *              -# Modify desired properties.
- *              -# Write modifications using @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE.
- *              -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
- *
- *              Logical Interface
- *              -----------------
- *              Logical interfaces specify traffic endpoints. They are connected to respective
- *              physical interfaces and contain information about which traffic can they accept
- *              and how the accepted traffic shall be processed (where, resp. to which @b physical
- *              interface(s) the matching traffic shall be forwarded). For example, there can be two
- *              logical interfaces associated with an EMAC1, one accepting traffic with VLAN ID = 10
- *              and the second one accepting all remaining traffic. First one can be configured to
- *              forward the matching traffic to EMAC1 and the second one to drop the rest.
- *
- *              Logical interfaces can be created and destroyed in runtime using actions related
- *              to the @ref FPP_CMD_LOG_IF command. Note that first created logical interface
- *              on a physical interface becomes the default one (tail). All subsequent logical
- *              interfaces are added at head position of list of interfaces.
- *
- *              \image latex flexible_router.eps "Configuration Example" width=7cm
- *              The example shows scenario when physical interface EMAC1 is configured in
- *              @ref FPP_IF_OP_FLEXIBLE_ROUTER operation mode:
- *              -# Packet is received via EMAC1 port of the PFE.
- *              -# Classifier walks through list of Logical Interfaces associated with the ingress
- *                 Physical Interface. Every Logical Interface contains a set of classification rules
- *                 (see @ref fpp_if_m_rules_t) the classification process is using to match the ingress
- *                 packet. Note that the list is searched from head to tail, where tail is the default
- *                 logical interface.
- *              -# Information about matching Logical Interface and Physical Interface is passed to
- *                 the Routing and Forwarding Algorithm. The algorithm reads the Logical Interface
- *                 and retrieves forwarding properties.
- *              -# The matching Logical Interface is configured to forward the packet to EMAC2 and
- *                 HIF so the forwarding algorithm ensures that. Optionally, here the packet can be
- *                 modified according to interface setup (VLAN insertion, source MAC address
- *                 replacement, ...).
- *              -# Packet is physically transmitted via dedicated interfaces. Packet replica sent
- *                 to HIF carries metadata describing the matching Logical and Physical interface
- *                 so the host driver can easily dispatch the traffic.
- *
- *              Here are supported operations related to logical interfaces:
- *
- *              To @b create new logical interface:
- *              -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *              -# Create logical interface via @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_REGISTER.
- *              -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Read out properties of physical interface(s).
+ *                 <br> (@ref FPP_CMD_PHY_IF + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              -# Unlock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_UNLOCK_SESSION)
+ *
+ *              To @b modify properties of a physical interface (read-modify-write):
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Read out properties of the target physical interface.
+ *                 <br> (@ref FPP_CMD_PHY_IF + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              -# Locally modify the properties. See fpp_phy_if_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_PHY_IF + FPP_ACTION_UPDATE)
+ *              -# Unlock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_UNLOCK_SESSION)
+ *
+ *              <br>
+ *              Hardcoded physical interface names and physical interface IDs:
+ *              | name     | ID | comment                                                |
+ *              | -------- | -- | ------------------------------------------------------ |
+ *              | emac0    | 0  | Representation of real physical ports connected to PFE.
+ *              | emac1    | 1  | ^
+ *              | emac2    | 2  | ^
+ *              | ---      | -- | ---reserved---
+ *              | util     | 5  | Special internal port for communication with the util firmware. <br> (fully functional only with the PREMIUM firmware)
+ *              | hif0     | 6  | Host Interfaces. Used for traffic forwarding between PFE and a host.
+ *              | hif1     | 7  | ^
+ *              | hif2     | 8  | ^
+ *              | hif3     | 9  | ^
+ *
+ * @subsection  mgmt_logif  Logical Interface
+ *              Logical interfaces are dynamic objects (definable at runtime) which represent traffic endpoints.
+ *              They are associated with their respective parent physical interfaces. Logical interfaces
+ *              can be used for the following purposes:
+ *              - To forward traffic from PFE to a host.
+ *              - To forward traffic or its replicas between physical interfaces (1:N distribution).
+ *              - To serve as classification & forwarding rules for @ref flex_router.
+ *
+ *              Logical interfaces have several configurable properties. See @ref FPP_CMD_LOG_IF 
+ *              and @ref fpp_log_if_cmd_t.
+ *
+ *              Logical interfaces can be created and destroyed at runtime. Every @e physical interface
+ *              can have a list of associated @e logical interfaces. The very first logical interface
+ *              in the list (tail position) is considered the @b default logical interface of the given 
+ *              physical interface. New logical interfaces are always added to the top of the list (head position),
+ *              creating a sequence which is ordered from the head (the newest one) back to the tail (the default one).
+ *              This forms a classification sequence, which is important if the parent physical interface 
+ *              operates in the Flexible Router mode.
+ *
+ *              Similar to physical interfaces, the logical interfaces can be set to a @b promiscuous mode.
+ *              For logical interfaces, a promiscuous mode means a logical interface will accept all
+ *              ingress traffic it is asked to classify, regardless of the interface's active match rules.
+ *
+ *              <br>
+ *              Supported operations related to logical interfaces:
+ *
+ *              To @b create a new logical interface in PFE:
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Create a new logical interface.
+ *                 <br> (@ref FPP_CMD_LOG_IF + FPP_ACTION_REGISTER)
+ *              -# Unlock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_UNLOCK_SESSION)
+ *
+ *              To @b remove a logical interface from PFE:
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Remove the logical interface.
+ *                 <br> (@ref FPP_CMD_LOG_IF + FPP_ACTION_DEREGISTER)
+ *              -# Unlock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_UNLOCK_SESSION)
  *
  *              To @b list available logical interfaces:
- *              -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *              -# Read first interface via @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_QUERY.
- *              -# Read next interface(s) via @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_QUERY_CONT.
- *              -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
- *
- *              To @b modify an interface (read-modify-write):
- *              -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *              -# Read interface properties via @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_QUERY +
- *                 @ref FPP_ACTION_QUERY_CONT.
- *              -# Modify desired properties.
- *              -# Write modifications using @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_UPDATE.
- *              -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
- *
- *              To @b remove logical interface:
- *              -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *              -# Remove logical interface via @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_DEREGISTER.
- *              -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
- *
- * @section feature Features
- * @subsection l3_router IPv4/IPv6 Router (TCP/UDP)
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Read out properties of logical interface(s).
+ *                 <br> (@ref FPP_CMD_LOG_IF + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              -# Unlock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_UNLOCK_SESSION)
+ *
+ *              To @b modify properties of a logical interface (read-modify-write):
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Read out properties of the target logical interface.
+ *                 <br> (@ref FPP_CMD_LOG_IF + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              -# Locally modify the properties. See fpp_log_if_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_LOG_IF + FPP_ACTION_UPDATE)
+ *              -# Unlock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_UNLOCK_SESSION)
+ *
+ * @section     features  Features
+ * @subsection  l3_router  IPv4/IPv6 Router (TCP/UDP)
  *              Introduction
  *              ------------
- *              The IPv4/IPv6 Forwarder is a dedicated feature to offload the host CPU from tasks
- *              related to forwarding of specific IP traffic between physical interfaces. Normally,
- *              the ingress IP traffic is passed to the host CPU running TCP/IP stack which is responsible
- *              for routing of the packets. Once the stack identifies that a packet does not belong to any
- *              of local IP endpoints it performs lookup in routing table to determine how to process such
- *              traffic. If the routing table contains entry associated with the packet (5-tuple search)
- *              the stack modifies and forwards the packet to another interface to reach its intended
- *              destination node. The PFE can be configured to identify flows which do not need to enter
- *              the host CPU using its internal routing table, and to ensure that the right packets are
- *              forwarded to the right destination interfaces.
+ *              IPv4/IPv6 Router is a dedicated feature to offload a host from tasks
+ *              related to forwarding of specific IP packets between physical interfaces.
+ *              Without the offload, IP packets are passed to the host's TCP/IP stack and 
+ *              the host is responsible for routing of packets. That is "slow path" routing.
+ *              PFE can be configured to provide "fast path" routing, identifying IP packets
+ *              which can be forwarded directly by PFE (using its internal routing table)
+ *              without host intervention.
  *
  *              Configuration
  *              -------------
- *              The FCI contains mechanisms to setup particular Physical Interfaces to start classifying
- *              packets using Router classification algorithm as well as to manage PFE routing tables.
- *              The router configuration then consists of following steps:
- *              -# Optionally use @ref FPP_CMD_IPV4_RESET or @ref FPP_CMD_IPV6_RESET to initialize the
- *                 router. All previous configuration changes will be discarded.
- *              -# Create one or more routes (@ref FPP_CMD_IP_ROUTE + @ref FPP_ACTION_REGISTER). Once
- *                 created, every route has an unique identifier. Creating route on an physical
- *                 interface causes switch of operation mode of that interface to @ref FPP_IF_OP_ROUTER.
- *              -# Create one or more IPv4 routing table entries (@ref FPP_CMD_IPV4_CONNTRACK +
- *                 @ref FPP_ACTION_REGISTER).
- *              -# Create one or more IPv6 routing table entries (@ref FPP_CMD_IPV6_CONNTRACK +
- *                 @ref FPP_ACTION_REGISTER).
- *              -# Set desired physical interface(s) to router mode @ref FPP_IF_OP_ROUTER using
- *                 @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE. This selects interfaces which
- *                 will use routing algorithm to classify ingress traffic.
- *              -# Enable physical interface(s) by setting the @ref FPP_IF_ENABLED flag via the
- *                 @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE.
- *              -# Optionally change MAC address(es) via @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE.
- *
- *              From this point the traffic matching created conntracks is processed according to
- *              conntrack properties (e.g. NAT) and fast-forwarded to configured physical interfaces.
- *              Conntracks are subject of aging. When no traffic has been seen for specified time
- *              period (see @ref FPP_CMD_IPV4_SET_TIMEOUT) the conntracks are removed.
- *
- *              Routes and conntracks can be listed using query commands:
- *              - @ref FPP_CMD_IP_ROUTE + @ref FPP_ACTION_QUERY + @ref FPP_ACTION_QUERY_CONT.
- *              - @ref FPP_CMD_IPV4_CONNTRACK + @ref FPP_ACTION_QUERY + @ref FPP_ACTION_QUERY_CONT.
- *              - @ref FPP_CMD_IPV6_CONNTRACK + @ref FPP_ACTION_QUERY + @ref FPP_ACTION_QUERY_CONT.
- *
- *              When conntrack or route are no more required, they can be deleted via corresponding
- *              command:
- *              - @ref FPP_CMD_IP_ROUTE + @ref FPP_ACTION_DEREGISTER,
- *              - @ref FPP_CMD_IPV4_CONNTRACK + @ref FPP_ACTION_DEREGISTER, and
- *              - @ref FPP_CMD_IPV6_CONNTRACK + @ref FPP_ACTION_DEREGISTER.
- *
- *              Deleting route causes deleting all associated conntracks. When the latest route on
- *              an interface is deleted, the interface is put to default operation mode
- *              @ref FPP_IF_OP_DEFAULT.
- *
- *              The conntracks are created default with TTL decrement option. That option can be 
- *              changed using update command:
- *              - @ref FPP_CMD_IPV4_CONNTRACK + @ref FPP_ACTION_UPDATE, and
- *              - @ref FPP_CMD_IPV6_CONNTRACK + @ref FPP_ACTION_UPDATE.
- *
- * @subsection l2_bridge L2 Bridge (Switch)
+ *              -# [optional] Reset the Router.
+ *                 <br> This clears all existing IPv4/IPv6 routes and conntracks in PFE.
+ *                 <br> (@ref FPP_CMD_IPV4_RESET)
+ *                 <br> (@ref FPP_CMD_IPV6_RESET)
+ *              -# Create one or more IPv4/IPv6 routes.
+ *                 <br> (@ref FPP_CMD_IP_ROUTE + FPP_ACTION_REGISTER)
+ *              -# Create one or more IPv4/IPv6 conntracks.
+ *                 <br> (@ref FPP_CMD_IPV4_CONNTRACK + FPP_ACTION_REGISTER)
+ *                 <br> (@ref FPP_CMD_IPV6_CONNTRACK + FPP_ACTION_REGISTER)
+ *              -# Configure the physical interfaces which shall classify their ingress traffic 
+ *                 by the Router classification algorithm. Use steps described in
+ *                 @ref mgmt_phyif (section @b modify) and do the following for each desired physical interface:
+ *                 - Set mode of the interface to @ref FPP_IF_OP_ROUTER.
+ *                 - Enable the interface by setting the flag @ref FPP_IF_ENABLED.
+ *
+ *              Once the Router is operational, all ingress IP packets of the Router-configured physical 
+ *              interfaces are matched against existing conntracks using a 5-tuple match (protocol, source IP,
+ *              destination IP, source port, destination port). If a packet matches some existing conntrack,
+ *              it is processed and modified according to conntrack's properties (destination MAC, NAT, PAT, etc.)
+ *              and then gets fast-forwarded to an egress physical interface as specified by the conntrack's route.
+ *
+ *              Additional operations
+ *              ---------------------
+ *              Conntracks are subjected to aging. If no matching packets are detected on a conntrack
+ *              for a specified time period, the conntrack is automatically removed from PFE.
+ *              To @b set the @b timeout period, use the following command (shared for both 
+ *              IPv4 and IPv6 conntracks):
+ *              <br> (@ref FPP_CMD_IPV4_SET_TIMEOUT)
+ *
+ *              <br>
+ *              To @b remove a route or a conntrack:
+ *              - (@ref FPP_CMD_IP_ROUTE + FPP_ACTION_DEREGISTER)
+ *              - (@ref FPP_CMD_IPV4_CONNTRACK + FPP_ACTION_DEREGISTER)
+ *              - (@ref FPP_CMD_IPV6_CONNTRACK + FPP_ACTION_DEREGISTER)
+ *
+ *              <small>
+ *              Note: <br>
+ *              Removing a route which is used by some conntracks causes the associated connntracks 
+ *              to be removed as well.
+ *              </small> <br>
+ *
+ *              To @b list available routes or conntracks:
+ *              - (@ref FPP_CMD_IP_ROUTE + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              - (@ref FPP_CMD_IPV4_CONNTRACK + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              - (@ref FPP_CMD_IPV6_CONNTRACK + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *
+ *              By default, PFE conntracks decrement TTL of processed IP packets. This behavior can be
+ *              set/unset for individual conntracks by their flag @ref CTCMD_FLAGS_TTL_DECREMENT.
+ *              To @b modify an already existing conntrack:
+ *              - (@ref FPP_CMD_IPV4_CONNTRACK + FPP_ACTION_UPDATE)
+ *              - (@ref FPP_CMD_IPV6_CONNTRACK + FPP_ACTION_UPDATE)
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_router_simple.c, @ref demo_feature_router_nat.c
+ *
+ * @subsection  l2_bridge  L2 Bridge (Switch)
  *              Introduction
  *              ------------
- *              The L2 Bridge functionality covers forwarding of packets based on MAC addresses. It
- *              provides possibility to move bridging-related tasks from host CPU to the PFE and thus
- *              offloads the host-based networking stack. The L2 Bridge feature represents a network
- *              switch device implementing following functionality:
- *              - <b>MAC table and address learning:</b>
- *                The L2 bridging functionality is based on determining to which interface an ingress
- *                packet shall be forwarded. For this purpose a network switch device implements so
- *                called bridging table (MAC table) which is searched to get target interface for each
- *                packet entering the switch. If received source MAC address does not match any MAC
- *                table entry then a new entry, containing the Physical Interface which the packet has
- *                been received on, is added - learned. Destination MAC address of an ingress packet
- *                is then used to search the table to determine the target interface.
- *              - <b>Static entries:</b>
- *                Bridge table can also contain static entry that are not aged. This entry is otherwise
- *                the same as standard entry. The main usage of static entry is to configure
- *                bridge in forward only mode and configure all entries manually. In this case only
- *                predetermined traffic matching to the static entries will be forwarded.
+ *              L2 Bridge is a dedicated feature to offload a host from tasks related
+ *              to MAC address-based forwarding of Ethernet frames. PFE can be configured 
+ *              to act as a network switch, implementing the following functionality:
+ *              - <b>MAC table:</b>
+ *                L2 Bridge uses its own MAC table to keep track of encountered MAC addresses.
+ *                Each MAC table entry consists of a MAC address and a physical interface 
+ *                which should be used to reach the given MAC address. MAC table entries can 
+ *                be dynamic (learned) or static.
+ *              - <b>MAC address learning:</b>
+ *                L2 Bridge is capable of automatically adding (learning) new MAC table entries from
+ *                ingress frames with new (not yet encountered) source MAC addresses.
  *              - <b>Aging:</b>
- *                Each MAC table entry gets default timeout value once learned. In time this timeout is
- *                being decreased until zero is reached. Entries with zero timeout value are automatically
- *                removed from the table. The timeout value is re-set each time the corresponding table
- *                entry is used to process a packet. The static entries are not affected by aging.
+ *                MAC table entries are subjected to aging. If a MAC table entry is not used for
+ *                a certain (hardcoded) time period, it is automatically removed from the MAC table.
+ *                Static entries are not affected by aging.
+ *              - <b>Static entries:</b>
+ *                It is possible to manually add static (non-aging) entries to the MAC table.
+ *                Static entries can be used as a part of L2 Bridge forward-only configuration
+ *                (with MAC learning disabled). With such a setup, only a predetermined
+ *                traffic (matching the static entries) will be forwarded.
+ *              - <b>Blocking states of physical interfaces:</b>
+ *                Each physical interface which is configured to be a part of the L2 Bridge can
+ *                be finetuned to allow/deny MAC learning or frame forwarding of its ingress traffic.
+ *                See @ref fpp_phy_if_block_state_t.
  *              - <b>Port migration:</b>
- *                When a MAC address is seen on one interface of the switch and an entry has been created,
- *                it is automatically updated when the MAC address is seen on another interface.
+ *                If there is already a learned MAC table entry (a MAC address + a target physical interface)
+ *                and the MAC address is detected on another interface, then the entry is automatically
+ *                updated (new target physical interface is set).
  *              - <b>VLAN Awareness:</b>
- *                The bridge implements VLAN table. This table is used to implement VLAN-based policies
- *                like Ingress and Egress port membership. Feature includes configurable VLAN tagging
- *                and un-tagging functionality per bridge interface (Physical Interface). The bridge
- *                utilizes PFE HW accelerators to perform MAC and VLAN table lookup thus this operation
- *                is highly optimized. Host CPU SW is only responsible for correct bridge configuration
- *                using the dedicated API.
+ *                The L2 Bridge uses its own VLAN table to support VLAN-based policies
+ *                like Ingress or Egress port membership. It also supports configuration of bridge
+ *                domain ports (represented by physical interfaces) to provide VLAN tagging and 
+ *                untagging services, effectively allowing creation of access / trunk ports.
+ *
+ *              The L2 Bridge utilizes PFE HW accelerators to perform highly optimized MAC and VLAN
+ *              table lookups. Host is responsible only for the initial bridge configuration via
+ *              the FCI API.
  *
  *              L2 Bridge VLAN Awareness and Domains
- *              --------------------------
- *              The VLAN awareness is based on entities called Bridge Domains (BD) which are visible to
- *              both classifier firmware, and the driver, and are used to abstract particular VLANs.
- *              Every BD contains configurable set of properties:
+ *              ------------------------------------
+ *              The VLAN awareness is based on entities called Bridge Domains (BD), which are visible to
+ *              both the classifier firmware and the driver. BDs are used to abstract particular VLANs.
+ *              Every BD has a configurable set of properties (see @ref fpp_l2_bd_cmd_t):
  *              - Associated VLAN ID.
- *              - Set of Physical Interfaces which are members of the domain.
- *              - Information about which of the member interfaces are ’tagged’ or ’untagged’.
- *              - Instruction how to process matching uni-cast packets (forward, flood, discard, ...).
- *              - Instruction how to process matching multi-cast packets.
- *
- *              The L2 Bridge then consists of multiple BD types:
- *              - <b>The Default BD:</b>
- *                Default domain is used by the classification process when a packet has been received
- *                with default VLAN ID. This can happen either if the packet does not contain VLAN tag
- *                or the VLAN tag is equal to the default VLAN configured within the bridge.
- *              - <b>The Fall-back BD:</b>
- *                This domain is used when packet with an unknown VLAN ID (does not match any standard
- *                or default domain) is received in @ref FPP_IF_OP_VLAN_BRIDGE mode. It is also used
- *                as representation of simple L2 bridge when VLAN awareness is disabled (in case of
- *                the @ref FPP_IF_OP_BRIDGE mode).
- *              - <b>Set of particular Standard BDs:</b>
- *                Standard domain. Specifies what to do when packet with VLAN ID matching the Standard
- *                BD is received.
- *
- *              Configuration (Bridge Domain)
- *              ----------------------------
- *              Here are steps needed to configure VLAN-aware switch:
- *              -# Optionally get list of available physical interfaces and their IDs. See the
- *                 @ref if_mgmt.
- *              -# Create a bridge domain (VLAN domain) (@ref FPP_CMD_L2_BD +
- *                 @ref FPP_ACTION_REGISTER).
- *              -# Configure domain hit/miss actions (@ref FPP_CMD_L2_BD + @ref FPP_ACTION_UPDATE)
- *                 to let the bridge know how to process matching traffic.
- *              -# Add physical interfaces as members of that domain (@ref FPP_CMD_L2_BD +
- *                 @ref FPP_ACTION_UPDATE). Adding interface to a bridge domain causes switch of its
- *                 operation mode to @ref FPP_IF_OP_VLAN_BRIDGE and enabling promiscuous mode on MAC
- *                 level. There is also a preconfigured default domain that identifies with VLAN 1.
- *              -# Set physical interface(s) to VLAN bridge mode @ref FPP_IF_OP_VLAN_BRIDGE using
- *                 @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE.
- *              -# Set promiscuous mode and enable physical interface(s) by setting the
- *                 @ref FPP_IF_ENABLED and @ref FPP_IF_PROMISC flags via the @ref FPP_CMD_PHY_IF +
- *                 @ref FPP_ACTION_UPDATE.
- *
- *              For simple, non-VLAN aware switch do:
- *              -# Optionally get list of available physical interfaces and their IDs. See the
- *                 @ref if_mgmt.
- *              -# Add physical interfaces as members of fall-back BD (@ref FPP_CMD_L2_BD +
- *                 @ref FPP_ACTION_UPDATE). The fall-back BD is identified by VLAN 0 and exists
- *                 automatically.
- *              -# Configure domain hit/miss actions (@ref FPP_CMD_L2_BD + @ref FPP_ACTION_UPDATE)
- *                 to let the bridge know how to process matching traffic.
- *              -# Set physical interface(s) to simple bridge mode @ref FPP_IF_OP_BRIDGE using
- *                 @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE.
- *              -# Set promiscuous mode and enable physical interface(s) by setting the
- *                 @ref FPP_IF_ENABLED and @ref FPP_IF_PROMISC flags via the @ref FPP_CMD_PHY_IF +
- *                 @ref FPP_ACTION_UPDATE.
- *
- *              Once interfaces are in bridge domain, all ingress traffic is processed according
- *              to bridge domain setup. Unknown source MAC addresses are being learned and after
- *              specified time period without traffic are being aged.
- *
- *              An interface can be added to or removed from BD at any time via
- *              @ref FPP_CMD_L2_BD + @ref FPP_ACTION_UPDATE. When interface is removed
- *              from all bridge domains (is not associated with any BD), its operation mode is
- *              automatically switched to @ref FPP_IF_OP_DEFAULT and MAC promiscuous mode is disabled.
- *
- *              List of available bridge domains with their properties can be retrieved using
- *              @ref FPP_CMD_L2_BD + @ref FPP_ACTION_QUERY + @ref FPP_ACTION_QUERY_CONT.
- *
- *              Static mac entries can be added once the bridge domain is configured. To add or update use
- *              @ref FPP_CMD_L2_STATIC_ENT + @ref FPP_ACTION_REGISTER + @ref FPP_ACTION_UPDATE.
- *              A static entry can be deleted using @ref FPP_CMD_L2_STATIC_ENT + @ref FPP_ACTION_DEREGISTER
- *              or all entries using @ref FPP_CMD_L2_FLUSH_STATIC.
- *
- *
- * @subsection l2l3_bridge L2L3 Bridge
- *             Introduction
- *             ------------
- *             The L2L3 Bridge is an extension of the available L2 bridge and IPv4/IPv6 Router algorithms.
- *             It requires both algorithms to be configured and (at least one) static entry with local
- *             MAC address flag being set, which denotes that the MAC address belongs to the IP Router.
- *
- *             Whenever a frame arrives it is checked against the local MAC addresses and it is passed
- *             to the IP Router algorithm when the frame destination address equals to one of local MAC
- *             addresses. Otherwise, it is passed to the L2 bridge.
- *
- *             Note that static entry forward list is ignored when the frame is passed to the IP router.
- *
- *             Configuration
- *             -------------
- *             To run the L2L3 Bridge mode
- *             -# Configure L2 Bridge and IP Router algorithms as described in respective sections.
- *             -# Create at least one static entry with local address flag being set.
- *             -# Set physical interface(s) to L2L3 Bridge mode using
- *                 @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE.
- *
- * @subsection flex_parser Flexible Parser
- *             Introduction
- *             ------------
- *             The Flexible Parser is PFE firmware-based feature allowing user to extend standard
- *             ingress packet classification process by set of customizable classification rules.
- *             According to the rules the Flexible Parser can mark frames as ACCEPTED or REJECTED.
- *             The rules are configurable by user and exist in form of tables. Every classification
- *             table entry consist of following fields:
- *             - 32-bit Data field to be compared with value from the ingress frame.
- *             - 32-bit Mask field (active bits are ’1’) specifying which bits of the data field will
- *                be used to perform the comparison.
- *             - 16-bit Configuration field specifying rule properties including the offset to the frame
- *               data which shall be compared.
- *
- *             The number of entries within the table is configurable by user. The table is processed
- *             sequentially starting from entry index 0 until the last one is reached or classification
- *             is terminated by a rule configuration. When none of rules has decided that the packet
- *             shall be accepted or rejected the default result is REJECT.
- *
- *             Example
- *             -------
- *             This is example of how Flexible Parser table can be configured. Every row contains single
- *             rule and processing starts with rule 0. ACCEPT/REJECT means that the classification is
- *             terminated with given result, CONTINUE means that next rule (sequentially) will be
- *             evaluated. CONTINUE with N says that next rule to be evaluated is N. Evaluation of the
- *             latest rule not resulting in ACCEPT or REJECT results in REJECT.
- *
- *             Rule|Flags                         |Mask |Next|Condition
- *             ----|------------------------------|-----|----|-----------------------------------------
- *             0   |FP_FL_INVERT<br>FP_FL_REJECT  |!= 0 |n/a |if ((PacketData&Mask) != (RuleData&Mask))<br> then REJECT<br> else CONTINUE
- *             1   |FP_FL_ACCEPT                  |!= 0 |n/a |if ((PacketData&Mask) == (RuleData&Mask))<br> then ACCEPT<br> else CONTINUE
- *             2   | -                            |!= 0 |4   |if ((PacketData&Mask) == (RuleData&Mask))<br> then CONTINUE with 4<br> else CONTINUE
- *             3   |FP_FL_REJECT                  |= 0  |n/a |REJECT
- *             4   |FP_FL_INVERT                  |!= 0 |6   |if ((PacketData&Mask) != (RuleData&Mask))<br> then CONTINUE with 6<br> else CONTINUE
- *             5   |FP_FL_ACCEPT                  |= 0  |n/a |ACCEPT
- *             6   |FP_FL_INVERT<br>FP_FL_ACCEPT  |!= 0 |n/a |if ((PacketData&Mask) != (RuleData&Mask))<br> then ACCEPT<br> else CONTINUE
- *             7   |FP_FL_REJECT                  |= 0  |n/a |REJECT
- *
- *             Configuration
- *             -------------
- *             -# Create a Flexible Parser table using @ref FPP_CMD_FP_TABLE + @ref FPP_ACTION_REGISTER.
- *             -# Create one or multiple rules with @ref FPP_CMD_FP_RULE + @ref FPP_ACTION_REGISTER.
- *             -# Assing rules to tables via @ref FPP_CMD_FP_TABLE + @ref FPP_ACTION_USE_RULE.
- *                Rules can be removed from table with @ref FPP_ACTION_UNUSE_RULE.
- *
- *             Created table can be used for instance as argument of @ref flex_router. When not needed
- *             the table can be deleted with @ref FPP_CMD_FP_TABLE + @ref FPP_ACTION_DEREGISTER
- *             and particular rules with @ref FPP_CMD_FP_RULE + @ref FPP_ACTION_DEREGISTER. This
- *             cleanup should be always considered since tables and rules are stored in limited PFE
- *             internal memory.
- *
- *             Flexible parser classification introduces performance penalty which is proportional
- *             to number of rules and complexity of the table.
- *
- * @subsection flex_router Flexible Router
- *             Introduction
- *             ------------
- *             Flexible router specifies behavior when ingress packets are classified and routed
- *             according to custom rules different from standard L2 Bridge (Switch) or IPv4/IPv6
- *             Router processing. Feature allows definition of packet distribution rules using physical
- *             and logical interfaces. The classification hierarchy is given by ingress physical
- *             interface containing a configurable set of logical interfaces. Every time a packet is
- *             received via the respective physical interface, which is configured to use the Flexible
- *             Router classification, a walk through the list of associated logical interfaces is
- *             performed. Every logical interface is used to match the packet using interface-specific
- *             rules (@ref fpp_if_m_rules_t). In case of match the matching packet is processed
- *             according to the interface configuration (e.g. forwarded via specific physical
- *             interface(s), dropped, sent to host, ...). In case when more rules are specified, the
- *             logical interface can be configured to apply logical AND or OR to get the match result.
- *             Please see the example within @ref if_mgmt.
- *
- *             Configuration
- *             -------------
- *             -# Lock interface database with @ref FPP_CMD_IF_LOCK_SESSION.
- *             -# Use @ref FPP_CMD_PHY_IF + @ref FPP_ACTION_UPDATE to set a physical interface(s)
- *                to @ref FPP_IF_OP_FLEXIBLE_ROUTER operation mode.
- *             -# Use @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_REGISTER to create new logical
- *                interface(s) if needed.
- *             -# Optionally, if @ref flex_parser is desired to be used as a classification rule,
- *                create table(s) according to @ref flex_parser description.
- *             -# Configure existing logical interface(s) (set match rules and arguments) via
- *                @ref FPP_CMD_LOG_IF + @ref FPP_ACTION_UPDATE.
- *             -# Unlock interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
- *
- *             Note that Flexible Router can be used to implement certain form of @ref l3_router as
- *             well as @ref l2_bridge. Such usage is of course not recommended since both mentioned
- *             features exist as fully optimized implementation and usage of Flexible Router this way
- *             would pointlessly affect forwarding performance.
- *
- * @subsection ipsec_offload IPsec Offload
- *             Introduction
- *             ------------
- *             The IPsec offload feature is a premium one and requires a special premium firmware version
- *             to be available for use. It allows the chosen IP frames to be transparently encoded by the IPsec and
- *             IPsec frames to be transparently decoded without the CPU intervention using just the PFE and HSE engines.
- *
- *             The SPD database needs to be established on an interface which contains entries describing frame
- *             match criteria together with the SA ID reference to the SA established within the HSE describing
- *             the IPsec processing criteria. Frames matching the criteria are then processed by the HSE according
- *             to the chosen SA and returned for the classification via physical interface of UTIL PE. Normal
- *             classification follows the IPsec processing thus the decrypted packets can be e.g. routed.
- *
- *             Configuration
- *             -------------
- *             -# Use (repeatedly) the @ref FPP_CMD_SPD command with FPP_ACTION_REGISTER action to set the SPD entries
- *             -# Optionally the @ref FPP_CMD_SPD command with FPP_ACTION_DEREGISTER action can be used to delete SPD entries
- *
- *             The HSE also requires the configuration via interfaces of the HSE firmware which is out of the scope of this
- *             document. The SAs referenced within the SPD entries must exist prior creation of the respective SPD entry.
- *
- * @subsection egress_qos Egress QoS
- *             Introduction
- *             ------------
- *             The egress QoS allows user to prioritize, aggregate and shape traffic intended to
- *             leave the accelerator via physical interface. Each physical interface contains dedicated
- *             QoS block with specific number of schedulers, shapers and queues.
- *             @if S32G2
- *                Following applies for the S32G2/PFE:
- *                - Number of queues: 8
- *                - Maximum queue depth: 255
- *                - Probability zones per queue: 8
- *                - Number of schedulers: 2
- *                - Number of scheduler inputs: 8
- *                - Allowed data sources which can be connected to the scheduler inputs:
- *
- *                  Source|Description
- *                  ------|----------------------
- *                  0 - 7 | Queue 0 - 7
- *                  8     | Output of Scheduler 0
- *                  255   | Invalid
- *
- *                - Number of shapers: 4
- *                - Allowed shaper positions:
- *
- *                  Position  |Description
- *                  ----------|------------------------------------------
- *                  0         | Output of Scheduler 1 (QoS master output)
- *                  1 - 8     | Input 0 - 7 of Scheduler 1
- *                  9 - 16    | Input 0 - 7 of Scheduler 0
- *                  255       | Invalid, Shaper disconnected
- *
- *                  Note that only shapers connected to a common scheduler inputs are aware
- *                  of each other and do share the 'conflicting transmission' signal.
- *
- *                Configuration
- *                -------------
- *                By default, the egress QoS topology looks like this:
- *                @verbatim
-                           SCH1
-                           (RR)
-                        +--------+
-                  Q0--->| 0      |
-                  Q1--->| 1      |
-                  Q2--->| 2      |
-                  Q3--->| 3      +--->
-                  Q4--->| 4      |
-                  ...   | ...    |
-                  Q7--->| 7      |
-                        +--------+
-                  @endverbatim
- *                meaning that all queues are connected to Scheduler 1 and the scheduler discipline
- *                is set to Round Robin. Rate mode is set to Data Rate (bps). Queues are in Tail Drop
- *                Mode.
- *
- *                To <b> list queue </b> properties:
- *                -# Read queue properties via @ref FPP_CMD_QOS_QUEUE + @ref FPP_ACTION_QUERY.
- *
- *                To <b> list scheduler </b> properties:
- *                -# Read scheduler properties via @ref FPP_CMD_QOS_SCHEDULER + @ref FPP_ACTION_QUERY.
- *
- *                To <b> list shaper </b> properties:
- *                -# Read shaper properties via @ref FPP_CMD_QOS_SHAPER + @ref FPP_ACTION_QUERY.
- *
- *                To <b> modify queue </b> properties:
- *                -# Read scheduler properties via @ref FPP_CMD_QOS_QUEUE + @ref FPP_ACTION_QUERY.
- *                -# Modify desired properties.
- *                -# Write modifications using @ref FPP_CMD_QOS_QUEUE + @ref FPP_ACTION_UPDATE.
- *
- *                To <b> modify scheduler </b> properties (read-modify-write):
- *                -# Read scheduler properties via @ref FPP_CMD_QOS_SCHEDULER + @ref FPP_ACTION_QUERY.
- *                -# Modify desired properties.
- *                -# Write modifications using @ref FPP_CMD_QOS_SCHEDULER + @ref FPP_ACTION_UPDATE.
- *
- *                To <b> modify shaper </b> properties (read-modify-write):
- *                -# Read shaper properties via @ref FPP_CMD_QOS_SHAPER + @ref FPP_ACTION_QUERY.
- *                -# Modify desired properties.
- *                -# Write modifications using @ref FPP_CMD_QOS_SCHEDULER + @ref FPP_ACTION_UPDATE.
- *
- *                To <b> change QoS topology </b> to following example form:
- *                @verbatim
-                           SCH0
-                           (WRR)
-                        +--------+
-                  Q0--->| 0      |           SCH1
-                  Q1--->| 1      |           (PQ)
-                  Q2--->| 2      |        +--------+
-                  Q3--->| 3      +------->| 0      |
-                  Q4--->| 4      |        | 1      |
-                        | ...    |        | 2      |
-                        | 7      |        | 3      +--->
-                        +--------+        | ...    |
-                                    Q6--->| 6      |
-                                    Q7--->| 7      |
-                                          +--------+
-                  @endverbatim
- *                -# Please see the @ref FPP_CMD_QOS_SCHEDULER for full C example
- *                (@ref fpp_cmd_qos_scheduler.c).
- *
- *                To <b> add traffic shapers </b>:
- *                @verbatim
-                           SCH0
-                           (WRR)
-                        +--------+
-                  Q0--->| 0      |               SCH1
-                  Q1--->| 1      |               (PQ)
-                  Q2--->| 2      |            +--------+
-                  Q3--->| 3      +--->SHP0--->| 0      |
-                  Q4--->| 4      |            | 1      |
-                        | ...    |            | 2      |
-                        | 7      |            | 3      +--->SHP2--->
-                        +--------+            | ...    |
-                                 Q6---SHP1--->| 6      |
-                                 Q7---------->| 7      |
-                                              +--------+
-                  @endverbatim
- *                -# Please see the @ref FPP_CMD_QOS_SHAPER for full C example
- *                (@ref fpp_cmd_qos_shaper.c).
- *             @else
- *                Device is unknown...
- *             @endif
+ *              - Set of physical interfaces which represent ports of the BD.
+ *              - Information about which ports are tagged or untagged.
+ *                - Tagged port adds a VLAN tag to egressed frames if they are not VLAN tagged, or keeps 
+ *                  the tag of the frames intact if they are already VLAN tagged.
+ *                - Untagged port removes the VLAN tag from egressed frames if the frames are VLAN tagged.
+ *              - Instruction how to process matching uni-cast frames. 
+ *              - Instruction how to process matching multi-cast frames. 
+ *
+ *              The L2 Bridge recognizes several BD types:
+ *              - <b>Default BD:</b> @anchor ref__default_bd
+ *                Factory default VLAN ID of this bridge domain is @b 1.
+ *                - For a VLAN-aware Bridge, this domain is used to process ingress frames which
+ *                  either have a VLAN tag equal to the Default BD's VLAN ID, or don't have 
+ *                  a VLAN tag at all (untagged Ethernet frames).
+ *                - For a simple (non-VLAN aware) Bridge, this domain is used as a representation
+ *                  of the simple bridge.
+ *              - <b>Fall-back BD:</b>
+ *                This domain is used by a VLAN-aware Bridge to process ingress frames which 
+ *                have an unknown VLAN tag. Unknown VLAN tag means that the VLAN tag does not 
+ *                match any existing standard BD nor the default BD.
+ *              - <b>Standard BD:</b>
+ *                Standard user-defined bridge domains. Used by a VLAN-aware Bridge. These BDs
+ *                process ingress frames which have a VLAN tag that matches the BD's VLAN ID.
+ *
+ *              Configuration (VLAN-aware Bridge)
+ *              ---------------------------------
+ *              -# Create a bridge domain (VLAN domain).
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_REGISTER)
+ *              -# Configure hit/miss actions of the bridge domain.
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_UPDATE)
+ *              -# Configure which physical interfaces are considered members (ports) of the bridge domain.
+ *                 Also specify which ports are VLAN tagged and which ports are not.
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_UPDATE)
+ *              -# Repeat previous steps to create all required bridge domains (VLAN domains).
+ *                 Physical interfaces can be members of multiple bridge domains.
+ *              -# Configure the physical interfaces which shall classify their ingress traffic
+ *                 by the VLAN-aware Bridge classification algorithm. Use steps described in
+ *                 @ref mgmt_phyif (section @b modify) and do the following for each desired physical interface:
+ *                 - Set mode of the interface to @ref FPP_IF_OP_VLAN_BRIDGE.
+ *                 - Enable the promiscuous mode by setting the flag @ref FPP_IF_PROMISC.
+ *                 - Enable the interface by setting the flag @ref FPP_IF_ENABLED.
+ *
+ *              Configuration (simple non-VLAN aware Bridge)
+ *              --------------------------------------------
+ *              -# Configure hit/miss actions of the @link ref__default_bd Default BD @endlink.
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_UPDATE)
+ *              -# Configure which physical interfaces are considered members (ports) of the Default BD.
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_UPDATE)
+ *              -# Configure the physical interfaces which shall classify their ingress traffic
+ *                 by the simple (non-VLAN aware) Bridge classification algorithm. Use steps described in
+ *                 @ref mgmt_phyif (section @b modify) and do the following for each desired physical interface:
+ *                 - Set mode of the interface to @ref FPP_IF_OP_BRIDGE.
+ *                 - Enable the promiscuous mode by setting the flag @ref FPP_IF_PROMISC.
+ *                 - Enable the interface by setting the flag @ref FPP_IF_ENABLED.
+ *
+ *              Once the L2 Bridge is operational, ingress Ethernet frames of the Bridge-configured
+ *              physical interfaces are processed according to setup of bridge domains. In case of 
+ *              a VLAN-aware Bridge, VLAN tag of every ingress frame is inspected and the frame is then 
+ *              processed by an appropriate bridge domain. In case of a simple (non-VLAN aware) Bridge,
+ *              all ingress frames are always processed by the default BD.
+ *
+ *              Additional operations
+ *              ---------------------
+ *              To @b remove a bridge domain:
+ *              <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_DEREGISTER)
+ *
+ *              <small>
+ *              Note: <br>
+ *              Default BD and Fall-back BD cannot be removed.
+ *              </small> <br>
+ *
+ *              To @b list available bridge domains:
+ *              <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *
+ *              To @b modify properties of a bridge domain (read-modify-write):
+ *              -# Read properties of the target bridge domain.
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              -# Locally modify the properties. See fpp_l2_bd_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_L2_BD + FPP_ACTION_UPDATE)
+ *
+ *              Operations related to MAC table static entries
+ *              ----------------------------------------------
+ *              To @b create a new static entry:
+ *              <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_REGISTER)
+ *
+ *              To @b remove a static entry:
+ *              <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_DEREGISTER)
+ *
+ *              To @b list available static entries:
+ *              <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *
+ *              To @b modify properties of a static entry (read-modify-write):
+ *              -# Read properties of the target static entry.
+ *                 <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              -# Locally modify the properties. See fpp_l2_static_ent_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_UPDATE)
+ *
+ *              To @b flush all static entries in PFE:
+ *              <br> (@ref FPP_CMD_L2_FLUSH_STATIC)
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_L2_bridge_simple.c, @ref demo_feature_L2_bridge_vlan.c
+ *
+ * @subsection  l2l3_bridge  L2L3 Bridge
+ *              Introduction
+ *              ------------
+ *              L2L3 Bridge is an extension of the L2 Bridge and IP Router features. 
+ *              It allows both features to be simultaneously available on a physical interface.
+ *              Traffic with specific destination MAC addresses is passed to the IP Router.
+ *              The rest is handled by the L2 Bridge.
+ *
+ *              Configuration
+ *              -------------
+ *              -# Configure @ref l3_router.
+ *              -# Configure @ref l2_bridge.
+ *              -# Create at least one MAC table static entry with the 'local' flag. Note that
+ *                 if a static entry is configured as local, then its egress list is ignored.
+ *                   - In case of a simple (non-VLAN aware) L2L3 Bridge, all 'local' static entries
+ *                     should belong to the @link ref__default_bd Default BD @endlink.
+ *                   - In case of VLAN-aware L2L3 Bridge, 'local' static entries must have
+ *                     a correct VLAN (and MAC address) in order to properly match the ingress traffic.
+ *
+ *                 <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_REGISTER)
+ *                 <br> (@ref FPP_CMD_L2_STATIC_ENT + FPP_ACTION_UPDATE)
+ *              -# Configure the physical interfaces which shall classify their ingress traffic
+ *                 by the L2L3 Bridge classification algorithm. Use steps described in
+ *                 @ref mgmt_phyif (section @b modify) and do the following for each desired physical interface:
+ *                 - Set mode of the interface either to @ref FPP_IF_OP_L2L3_BRIDGE or to @ref FPP_IF_OP_L2L3_VLAN_BRIDGE.
+ *                 - Enable the promiscuous mode by setting the flag @ref FPP_IF_PROMISC.
+ *                 - Enable the interface by setting the flag @ref FPP_IF_ENABLED.
+ *
+ *              Once the L2L3 Bridge is operational, it checks the ingress traffic of 
+ *              L2L3 Bridge-configured physical interfaces against 'local' static entries 
+ *              in the L2 Bridge MAC table. If traffic's destination MAC matches a MAC address 
+ *              of some 'local' static entry, then the traffic is passed to the IP Router.
+ *              Otherwise the traffic is passed to the L2 Bridge.
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_L2L3_bridge_simple.c, @ref demo_feature_L2L3_bridge_vlan.c
+ *
+ * @subsection  flex_parser  Flexible Parser
+ *              Introduction
+ *              ------------
+ *              Flexible Parser is a PFE firmware-based feature which can classify ingress traffic
+ *              according to a set of custom classification rules. The feature is intended to be used
+ *              as an extension of other PFE features/classification algorithms. Flexible Parser consists 
+ *              of the following elements:
+ *              - <b>FP rule:</b>
+ *                A classification rule. See @ref FPP_CMD_FP_RULE.
+ *                FP rules inspect content of Ethernet frames. Based on the inspection result
+ *                (whether the condition of a rule is satisfied or not), a next step of the Flexible Parser 
+ *                classification process is taken.
+ *              - <b>FP table:</b> @anchor ref__fp_table 
+ *                An ordered set of FP rules. See @ref FPP_CMD_FP_TABLE. These tables can be assigned 
+ *                as extensions of other PFE features/classification algorithms. Namely, they can be used 
+ *                as an argument for:
+ *                - Flexible Filter of a physical interface. See @ref fpp_phy_if_cmd_t (`.ftable`).
+ *                  Flexible Filter acts as a traffic filter, pre-emptively discarding ingress traffic
+ *                  which is rejected by the associated FP table. Accepted traffic is then processed
+ *                  according to mode of the physical interface.
+ *                - @ref FPP_IF_MATCH_FP0 / @ref FPP_IF_MATCH_FP1 match rules of a logical interface.
+ *                  See @ref flex_router.
+ *
+ *              Flexible Parser classification introduces a performance penalty which is proportional to a count
+ *              of rules and complexity of a used table. Always consider whether the use of this feature is 
+ *              really necessary. If it is necessary, then try to use FP tables with as few rules as possible.
+ *
+ *              Configuration
+ *              -------------
+ *              -# Create one or multiple FP rules.
+ *                 <br> (@ref FPP_CMD_FP_RULE + FPP_ACTION_REGISTER)
+ *              -# Create one or multiple FP tables.
+ *                 <br> (@ref FPP_CMD_FP_TABLE + FPP_ACTION_REGISTER)
+ *              -# Assign rules to tables. Each rule can be assigned only to one table.
+ *                 <br> (@ref FPP_CMD_FP_TABLE + FPP_ACTION_USE_RULE)
+ *              -# [optional] If required, an FP rule can be removed from an FP table.
+ *                 The rule can be then assigned to a different table.
+ *                 <br> (@ref FPP_CMD_FP_TABLE + FPP_ACTION_UNUSE_RULE)
+ *              -# Use FP tables wherever they are required. See @link ref__fp_table FP table @endlink.
+ *
+ *              @b WARNING: <br>
+ *              Do not modify FP tables which are already in use! Always first remove the FP table
+ *              from use, then modify it (add/delete/rearrange rules), then put it back to its use.
+ *              Failure to adhere to this warning will result in an undefined behavior of Flexible Parser.
+ *              <br>
+ *
+ *              Once an FP table is configured and put to use, it will start classifying the ingress traffic
+ *              in whatever role it was assigned to (see @link ref__fp_table FP table @endlink).
+ *              Classification always starts from the very first rule of the table (index 0). Normally,
+ *              rules of the table are evaluated sequentially till the traffic is either accepted, rejected,
+ *              or the end of the table is reached. If the end of the table is reached and the traffic is 
+ *              still not accepted nor rejected, then Flexible Parser automatically rejects it.
+ *
+ *              Based on the action of an FP rule, it is possible to make a jump from the currently
+ *              evaluated rule to any other rule in the same table. This can be used in some complex scenarios.
+ *
+ *              @b WARNING: <br>
+ *              It is prohibited to use jumps to create loops. Failure to adhere to this warning 
+ *              will result in an undefined behavior of Flexible Parser.
+ *
+ *              Additional operations
+ *              ---------------------
+ *              It is advised to always remove rules and tables which are not needed, because these
+ *              unused objects would needlessly occupy limited internal memory of PFE. To @b remove
+ *              an FP rule or an FP table:
+ *              - (@ref FPP_CMD_FP_RULE + FPP_ACTION_DEREGISTER)
+ *              - (@ref FPP_CMD_FP_TABLE + FPP_ACTION_DEREGISTER)
+ *
+ *              To @b list FP rules or FP tables:
+ *              - (@ref FPP_CMD_FP_RULE + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *              - (@ref FPP_CMD_FP_TABLE + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)
+ *
+ *              FP table example
+ *              ----------------
+ *              This is an example of how a Flexible Parser table can look like.
+ *              - Every row is one FP rule.
+ *              - The classification process starts from the rule 0.
+ *              - ACCEPT/REJECT means the classification is terminated with the given result.
+ *              - CONTINUE means that the next rule in a sequence (next row) shall be evaluated.
+ *              - NEXT_RULE <name> means that the next rule to evaluate shall be the rule <name>.
+ *              - FrameData is an inspected value from an ingress Ethernet frame.
+ *                Each rule can inspect a different value from the frame.
+ *                See @ref FPP_CMD_FP_RULE and @ref fpp_fp_rule_props_t, fields `.offset` and `.offset_from`.
+ *              - RuleData is a template value inside the FP rule. It is compared with the inspected value 
+ *                from the ingress Ethernet frame.
+ *              - Mask is a bitmask specifying which bits of the RuleData and FrameData shall be compared
+ *                (the rest of the bits is ignored).
+ *
+ *               i | Rule   | Flags                          | Mask | Condition of the rule + actions
+ *              ---|--------|--------------------------------|------|------------------------------------------
+ *               0 | MyR_01 | @b FP_INVERT <br> FP_REJECT    | != 0 | if ((FrameData & Mask) @b != (RuleData & Mask)) <br> then REJECT <br> else CONTINUE
+ *               1 | MyR_02 |    FP_ACCEPT                   | != 0 | if ((FrameData & Mask)==(RuleData & Mask)) <br> then ACCEPT <br> else CONTINUE
+ *               2 | MyR_03 |    FP_NEXT_RULE                | != 0 | if ((FrameData & Mask)==(RuleData & Mask)) <br> then NEXT_RULE MyR_11 <br> else CONTINUE
+ *               3 | MyR_0r |    FP_REJECT                   | == 0 | REJECT
+ *               4 | MyR_11 | @b FP_INVERT <br> FP_NEXT_RULE | != 0 | if ((FrameData & Mask) @b != (RuleData & Mask)) <br> then NEXT_RULE MyR_21 <br> else CONTINUE
+ *               5 | MyR_1a |    FP_ACCEPT                   | == 0 | ACCEPT
+ *               6 | MyR_21 | @b FP_INVERT <br> FP_ACCEPT    | != 0 | if ((FrameData & Mask) @b != (RuleData & Mask)) <br> then ACCEPT <br> else CONTINUE
+ *               7 | MyR_2r |    FP_REJECT                   | == 0 | REJECT
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_flexible_filter.c
+ *
+ * @subsection  flex_router  Flexible Router
+ *              Introduction
+ *              ------------
+ *              Flexible Router is a PFE firmware-based feature which uses logical interfaces
+ *              (and their match rules) to classify ingress traffic. Replicas of the accepted traffic
+ *              can be forwarded to one or multiple physical interfaces.
+ *
+ *              Flexible Router classification introduces a performance penalty which is proportional to a count
+ *              of used logical interfaces (and their match rules). Always consider whether the use of this feature
+ *              is really necessary. If it is necessary, then try to use as few logical interfaces as possible.
+ *
+ *              Configuration
+ *              -------------
+ *              -# Lock the interface database.
+ *                 <br> (@ref FPP_CMD_IF_LOCK_SESSION)
+ *              -# Create one or multiple logical interfaces. See @ref mgmt_logif for more info.
+ *                 For Flexible Router purposes, pay attention to the order of logical interfaces.
+ *                 <br> (@ref FPP_CMD_LOG_IF + FPP_ACTION_REGISTER)
+ *              -# Configure the logical interfaces. Use steps described in
+ *                 @ref mgmt_logif (section @b modify) and do the following for each desired logical interface:
+ *                 - [optional] Set interface properties such as egress, match rules and match rule arguments.
+ *                 - [optional] If multiple match rules are used, then set or clear the flag
+ *                   @ref FPP_IF_MATCH_OR in order to specify a logical relation between the rules.
+ *                 - Enable the interface by setting the flag @ref FPP_IF_ENABLED.
+ *              -# Configure the physical interfaces which shall classify their ingress traffic
+ *                 by the Flexible Router classification algorithm. Use steps described in
+ *                 @ref mgmt_phyif (section @b modify) and do the following for each desired physical interface:
+ *                 - Set mode of the interface to @ref FPP_IF_OP_FLEXIBLE_ROUTER.
+ *                 - Enable the interface by setting the flag @ref FPP_IF_ENABLED.
+ *              -# Unlock the interface database with @ref FPP_CMD_IF_UNLOCK_SESSION.
+ *
+ *              Once the Flexible Router is operational, it classifies the ingress traffic of
+ *              Flexible Router-configured physical interfaces. The process is based on the 
+ *              classification sequence of logical interfaces (see @ref mgmt_logif). Classifier walks 
+ *              through the sequence from the head position back to tail, matching the ingress 
+ *              traffic against match rules of logical interfaces which are in the sequence.
+ *              If a match is found (traffic conforms with match rules of the given logical interface),
+ *              then the traffic is processed according to the interface's configuration (forwarded, 
+ *              dropped, sent to a host, etc.).
+ *
+ *              Configuration example
+ *              ---------------------
+ *              This example shows a scenario where emac1 physical interface is configured in
+ *              the @ref FPP_IF_OP_FLEXIBLE_ROUTER mode. Goal is to classify ingress traffic
+ *              on emac1 interface. If the traffic matches classification criteria,
+ *              a replica of the traffic is egressed through both emac2 and hif0 interfaces.
+ *              <br>
+ *              @image latex flexible_router.eps "Configuration Example" width=7cm
+ *              -# Traffic is ingressed (received) through emac1 port of PFE.
+ *              -# Classifier walks through the list of logical interfaces associated with the emac1
+ *                 physical interface.
+ *              -# If some logical interface accepts the traffic, then information about the matching 
+ *                 logical interface (and its parent physical interface) is passed to the Routing and 
+ *                 Forwarding Algorithm. Algorithm reads the logical interface and retrieves forwarding properties.
+ *              -# Traffic is forwarded by the Routing and Forwarding Algorithm based on the provided information.
+ *                 In this example, the logical interface specified that a replica of the traffic shall be 
+ *                 forwarded to both emac2 and hif0 interfaces.
+ *              -# Traffic is transmitted via physical interfaces.
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_flexible_router.c
+ *
+ * @subsection  ipsec_offload IPsec Offload
+ *              Introduction
+ *              ------------
+ *              The IPsec offload feature is a premium one and requires a special premium firmware version
+ *              to be available for use. It allows the chosen IP frames to be transparently encoded by the IPsec and
+ *              IPsec frames to be transparently decoded without the CPU intervention using just the PFE and HSE engines.
+ *
+ *              @b WARNING: <br>
+ *              The IPsec offload feature is available only for some Premium versions of PFE firmware.
+ *              The feature should @b not be used with a firmware which does not support it.
+ *              Failure to adhere to this warning will result in an undefined behavior of PFE.
+ *              <br>
+ *
+ *              The SPD database needs to be established on an interface which contains entries describing frame
+ *              match criteria together with the SA ID reference to the SA established within the HSE describing
+ *              the IPsec processing criteria. Frames matching the criteria are then processed by the HSE according
+ *              to the chosen SA and returned for the classification via physical interface of UTIL PE. Normal
+ *              classification follows the IPsec processing thus the decrypted packets can be e.g. routed.
+ *
+ *              <br>Supported operations related to the IPsec offload:
+ *
+ *              To @b create a new SPD entry in the SPD table of a physical interface:
+ *              <br> (@ref FPP_CMD_SPD + FPP_ACTION_REGISTER)
+ *
+ *              To @b remove an SPD entry from the SPD table of a physical interface:
+ *              <br> (@ref FPP_CMD_SPD + FPP_ACTION_DEREGISTER)
+ *
+ *              To @b list existing SPD entries from the SPD table of a physical interface:
+ *              <br> (@ref FPP_CMD_SPD + FPP_ACTION_QUERY and FPP_ACTION_QUERY_CONT)    
+ *
+ *              The HSE also requires the configuration via interfaces of the HSE firmware which is out of the scope of this
+ *              document. The SAs referenced within the SPD entries must exist prior creation of the respective SPD entry.
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_spd.c
+ *
+ * @subsection  egress_qos Egress QoS
+ *              Introduction
+ *              ------------
+ *              The egress QoS allows user to prioritize, aggregate and shape traffic intended to
+ *              leave the accelerator through some @link mgmt_phyif physical interface @endlink.
+ *              Egress QoS is implemented as follows:
+ *              - Each @b emac physical interface has its own QoS block.
+ *              - All @b hif physical interfaces share one common QoS block.    
+ *
+ *              Every QoS block has a platform-specific number of queues, schedulers and shapers.
+ *
+ *              @if S32G2
+ *                The following applies for each @b S32G2/PFE QoS block:
+ *                - @b Queues:
+ *                     - Number of queues: 8
+ *                     - Maximum queue depth: 255
+ *                     - Probability zones per queue: 8    
+ *                       <small><br>
+ *                       Queues of @b hif interfaces:    
+ *                       Every hif interface has only @b 2 queues, indexed as follows:
+ *                         - [0] : low priority queue (L)
+ *                         - [1] : high priority queue (H)
+ *
+ *                       Use only these indexes if hif queues are configured via FCI commands.
+ *                       </small>
+ *
+ *                - @b Schedulers:
+ *                     - Number of schedulers: 2
+ *                     - Number of scheduler inputs: 8
+ *                     - Traffic sources which can be connected to scheduler inputs:    
+ *                       (see @link fpp_qos_scheduler_cmd_t @endlink.input_src)
+ *                         Source|Description
+ *                         ------|----------------------
+ *                         0 - 7 | Queue 0 - 7
+ *                         8     | Output of Scheduler 0
+ *                         255   | Invalid (nothing connected)
+ *
+ *                - @b Shapers:
+ *                     - Number of shapers: 4
+ *                     - Shaper positions:    
+ *                       (see @link fpp_qos_shaper_cmd_t @endlink.position)
+ *                         Position  |Description
+ *                         ----------|------------------------------------------
+ *                         0         | Output of Scheduler 1 (QoS master output)
+ *                         1 - 8     | Input 0 - 7 of Scheduler 1
+ *                         9 - 16    | Input 0 - 7 of Scheduler 0
+ *                         255       | Invalid (shaper disconnected)
+ *                     Note that only shapers connected to common scheduler inputs are aware
+ *                     of each other and do share the 'conflicting transmission' signal.
+ *              @endif
+ *
+ *              Traffic queueing algorithm
+ *              --------------------------
+ *              The following pseudocode explains traffic queueing algorithm of PFE:
+ *              @code{.c}
+ *              .............................................  
+ *              get_queue_for_packet(pkt)
+ *              {
+ *                queue = 0;
+ *                  
+ *                if (pkt.hasVlanTag)
+ *                {
+ *                  queue = pkt.VlanHdr.PCP;
+ *                }
+ *                else
+ *                {
+ *                  if (pkt.isIPv4)
+ *                  {
+ *                    queue = (pkt.IPv4Hdr.DSCP) / 8;
+ *                  }
+ *                  if (pkt.isIPv6)
+ *                  {
+ *                    queue = (pkt.IPv6Hdr.TrafficClass.DS) / 8;
+ *                  }
+ *                }
+ *                  
+ *                return queue;
+ *              }
+ *              .............................................  
+ *              @endcode
+ *
+ *              <small>
+ *              @b Note:    
+ *              Hif interfaces have only two queues. Their queueing algorithm is similar to the 
+ *              aforementioned pseudocode, but is modified to produce only two results:
+ *                - 0 : traffic belongs to the hif's low priority queue.
+ *                - 1 : traffic belongs to the hif's high priority queue.
+ *
+ *              </small>
+ *
+ *              Configuration
+ *              -------------
+ *              By default, the egress QoS topology looks like this:
+ *              @verbatim
+                         SCH1
+                         (RR)
+                      +--------+
+                Q0--->| 0      |
+                Q1--->| 1      |
+                Q2--->| 2      |
+                Q3--->| 3      +--->
+                Q4--->| 4      |
+                ...   | ...    |
+                Q7--->| 7      |
+                      +--------+
+                @endverbatim
+ *
+ *              All queues are connected to Scheduler 1 and the scheduler discipline
+ *              is set to Round Robin. Rate mode is set to Data Rate (bps). Queues are 
+ *              in Tail Drop mode.
+ *
+ *              To <b> list QoS queue </b> properties:
+ *              -# Read QoS queue properties.
+ *                 <br> (@ref FPP_CMD_QOS_QUEUE + FPP_ACTION_QUERY)
+ *
+ *              To <b> list QoS scheduler </b> properties:
+ *              -# Read QoS scheduler properties.
+ *                 <br> (@ref FPP_CMD_QOS_SCHEDULER + FPP_ACTION_QUERY)
+ *
+ *              To <b> list QoS shaper </b> properties:
+ *              -# Read QoS shaper properties.
+ *                 <br> (@ref FPP_CMD_QOS_SHAPER + FPP_ACTION_QUERY)
+ *
+ *              To <b> modify QoS queue </b> properties (read-modify-write):
+ *              -# Read QoS queue properties.
+ *                 <br> (@ref FPP_CMD_QOS_QUEUE + FPP_ACTION_QUERY)
+ *              -# Locally modify the properties. See fpp_qos_queue_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_QOS_QUEUE + FPP_ACTION_UPDATE)
+ *
+ *              To <b> modify QoS scheduler </b> properties (read-modify-write):
+ *              -# Read QoS scheduler properties.
+ *                 <br> (@ref FPP_CMD_QOS_SCHEDULER + FPP_ACTION_QUERY)
+ *              -# Locally modify the properties. See fpp_qos_scheduler_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_QOS_SCHEDULER + FPP_ACTION_UPDATE)
+ *
+ *              To <b> modify QoS shaper </b> properties (read-modify-write):
+ *              -# Read QoS shaper properties.
+ *                 <br> (@ref FPP_CMD_QOS_SHAPER + FPP_ACTION_QUERY)
+ *              -# Locally modify the properties. See fpp_qos_shaper_cmd_t.
+ *              -# Write the modified properties back to PFE.
+ *                 <br> (@ref FPP_CMD_QOS_SHAPER + FPP_ACTION_UPDATE)
+ *
+ *              Examples
+ *              --------
+ *              @ref demo_feature_qos.c
  *
  */
 
 /**
- * @example fpp_cmd_phy_if.c
- * @example fpp_cmd_log_if.c
- * @example fpp_cmd_ip_route.c
- * @example fpp_cmd_ipv4_conntrack.c
- * @example fpp_cmd_ipv6_conntrack.c
- * @example fpp_cmd_qos_queue.c
- * @example fpp_cmd_qos_scheduler.c
- * @example fpp_cmd_qos_shaper.c
- * @example fpp_cmd_l2_bd.c
- * @example fpp_cmd_fp_table.c
+ * @example demo_feature_L2_bridge_simple.c
+ * @example demo_feature_L2_bridge_vlan.c
+ * @example demo_feature_router_simple.c
+ * @example demo_feature_router_nat.c
+ * @example demo_feature_L2L3_bridge_simple.c
+ * @example demo_feature_L2L3_bridge_vlan.c
+ * @example demo_feature_flexible_filter.c
+ * @example demo_feature_flexible_router.c
+ * @example demo_feature_spd.c
+ * @example demo_feature_qos.c
+ * 
+ * @example demo_common.c
+ * @example demo_phy_if.c
+ * @example demo_log_if.c
+ * @example demo_l2_bd.c
+ * @example demo_fp.c
+ * @example demo_rt_ct.c
+ * @example demo_spd.c
+ * @example demo_qos.c
+ * @example demo_fwfeat.c
  */
 
 /**
@@ -698,6 +919,32 @@
 #endif /* FALSE */
 
 
+/**
+ * @def         CTCMD_FLAGS_ORIG_DISABLED
+ * @brief       Disable connection originator.
+ * @details      <!-- empty, but is needed by Doxygen generator -->
+ * @hideinitializer
+ */
+#define CTCMD_FLAGS_ORIG_DISABLED           (1U << 0)
+
+/**
+ * @def         CTCMD_FLAGS_REP_DISABLED
+ * @brief       Disable connection replier.
+ * @details     Used to create uni-directional connections (see @ref FPP_CMD_IPV4_CONNTRACK,
+ *              @ref FPP_CMD_IPV4_CONNTRACK)
+ * @hideinitializer
+ */
+#define CTCMD_FLAGS_REP_DISABLED            (1U << 1)
+
+/**
+ * @def         CTCMD_FLAGS_TTL_DECREMENT
+ * @brief       Enable TTL decrement
+ * @details     Used to decrement TTL field when the pkt is routed
+ * @hideinitializer
+ */
+#define CTCMD_FLAGS_TTL_DECREMENT            (1U << 2)
+
+
 /* TODO put to config file: */
 /**
  * @def FCI_CFG_FORCE_LEGACY_API
@@ -754,30 +1001,6 @@
     #define FPP_CMD_IPV6_CONNTRACK_CHANGE   0x0415u
 #endif /* FCI_CFG_FORCE_LEGACY_API */
 
-/**
- * @def CTCMD_FLAGS_ORIG_DISABLED
- * @brief Disable connection originator
- * @hideinitializer
- */
-#define CTCMD_FLAGS_ORIG_DISABLED           (1U << 0)
-
-/**
- * @def         CTCMD_FLAGS_REP_DISABLED
- * @brief       Disable connection replier
- * @details     Used to create uni-directional connections (see @ref FPP_CMD_IPV4_CONNTRACK,
- *              @ref FPP_CMD_IPV4_CONNTRACK)
- * @hideinitializer
- */
-#define CTCMD_FLAGS_REP_DISABLED            (1U << 1)
-
-/**
- * @def         CTCMD_FLAGS_TTL_DECREMENT
- * @brief       Enable TTL decrement
- * @details     Used to decrement TTL field when the pkt is routed
- * @hideinitializer
- */
-#define CTCMD_FLAGS_TTL_DECREMENT            (1U << 2)
-
 
 /**
  * @struct      FCI_CLIENT
-- 
2.31.1

